```
Programa de Ingeniería de Sistemas y Computación
Universidad del Quindío

Título: Implementación de Servicios REST en Spring Boot
Duración estimada: 120
Docentes: Carlos Andrés Florez, Christian Andrés Candela
Guía: 05
```
# **Controladores REST en Spring Boot**

## **🎯 Objetivo**  
Implementar una API REST utilizando **Spring Boot**, basada en un diseño previo realizado con **OpenAPI**. Los estudiantes aprenderán a traducir un diseño de API en una implementación funcional en Java, aplicando principios de programación empresarial y buenas prácticas de desarrollo.

---

## **Conceptos Básicos**  
Antes de iniciar con el diseño, es importante comprender algunos conceptos fundamentales:

#### **1. REST (Representational State Transfer)**  
Estilo arquitectónico basado en principios como:
- Separación cliente-servidor.
- Uso de recursos identificados por URIs.
- Uso de métodos HTTP estándar (GET, POST, PUT, DELETE, PATCH, etc.).
- Implementación de respuestas sin estado (**stateless**).
- Cacheabilidad y escalabilidad.

**Referencia:** Fielding, R. T. (2000). *Architectural Styles and the Design of Network-based Software Architectures*. University of California, Irvine.

#### **2. HTTP (Hypertext Transfer Protocol)**  
Protocolo de comunicación para la transferencia de datos en la web. Define métodos estándar como:
- **GET**: Obtener información.
- **POST**: Crear un nuevo recurso.
- **PUT**: Actualizar un recurso existente.
- **DELETE**: Eliminar un recurso.

**Referencia:** RFC 7231 - *Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content*. [IETF RFC 7231](https://tools.ietf.org/html/rfc7231).

#### **3. OpenAPI**  
Especificación abierta para describir APIs RESTful, permitiendo generar documentación interactiva, facilitar la integración con herramientas de prueba y mejorar la interoperabilidad.

**Referencia:** OpenAPI Initiative. (2023). *OpenAPI Specification*. [OpenAPI Docs](https://www.openapis.org/).

---

## **Contextualización Teórica**  

### **Diseño de APIs y Documentación con OpenAPI**  
La documentación de APIs es crucial para garantizar que los desarrolladores puedan entender y utilizar los servicios web de manera efectiva. **OpenAPI** permite:  
- Generar documentación interactiva (Swagger UI).  
- Facilitar la integración con herramientas de prueba como Postman.  
- Mejorar la interoperabilidad entre sistemas heterogéneos.  

#### **Herramientas para Documentación y Pruebas de APIs**  
- **Swagger UI:** Interfaz interactiva para explorar y probar APIs.  
- **Postman:** Herramienta para realizar pruebas y validar respuestas.  
- **Insomnia:** Alternativa ligera para pruebas de APIs.  

#### **API REST en Spring Boot**
Spring Boot facilita la creación de APIs REST mediante la utilización de anotaciones y convenciones que simplifican el desarrollo. Algunas características clave incluyen:
- **Controladores REST:** Clases anotadas con `@RestController` que manejan las solicitudes HTTP.
- **Serialización/Deserialización:** Conversión automática entre objetos Java y JSON/XML.
- **Manejo de Errores:** Respuestas de error estandarizadas mediante `@RestControllerAdvice`.

En el siguiente diagrama se muestra una arquitectura simplificada del acceso a la información desde la capa de presentación (cliente).

```mermaid
graph LR
    CA[Client Application] <--> |APIs| C[Controller<br/>Request mapping]
    
    C <--> S[Service<br/>Business logic]

    S <--> R[Repository<br/>DB interactions]
    
    M[Model<br/>DAO] <--> R

    M <--> DB[(DB)]
    
    classDef clientApp fill:#f9ca24
    classDef controller fill:#f0b3b3
    classDef service fill:#a4d7f5
    classDef repository fill:#a8e6a3
    classDef model fill:#ddb3dd
    classDef database fill:#d3d3d3
    
    class CA clientApp
    class C controller
    class S service
    class R repository
    class M model
    class DB database
```
El proceso de petición desde el cliente a los servicios de Spring Boot sigue el modelo de arquitectura Cliente-Servidor y se basa en el protocolo HTTP (o HTTPS). Aquí hay un resumen general del proceso:

- Un cliente (como un navegador web o una aplicación móvil) inicia una solicitud enviando una petición HTTP al servidor Spring Boot.

- En el servidor Spring Boot, las peticiones son manejadas por controladores. Los controladores están anotados con `@Controller`, `@RestController` u otras anotaciones específicas de Spring.

- El controlador realiza las operaciones necesarias en función de la lógica de negocio. Puede interactuar con servicios, acceder a bases de datos, realizar operaciones y preparar datos para enviar como respuesta.

- Generación de la respuesta: Una vez que el controlador ha completado su lógica, genera una respuesta. La respuesta generada por el controlador se envía de vuelta al cliente a través del protocolo HTTP.

- El cliente (por ejemplo, un navegador web o una aplicación móvil) recibe la respuesta y realiza acciones según la lógica de la aplicación.


**Referencias:**

  - [Documentación de Spring Boot sobre REST](https://spring.io/guides/gs/rest-service)
  - [Documentación de la API de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/apidocs/jakarta/validation/constraints/package-summary)  
  - [Introducción a la Validación de Beans en Jakarta EE](https://jakarta.ee/learn/docs/jakartaee-tutorial/current/beanvalidation/bean-validation/bean-validation.html)
  - [Especificación de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0)  

---

## Procedimiento

#### 1. Configuración inicial

Asegúrese que tiene la siguiente dependencia añadida en el archivo `build.grade.kts` del proyecto de Spring Boot:

```kotlin
implementation("org.springframework.boot:spring-boot-starter-web")
```

#### 2. Crear un controlador simple

Cree una clase que se llame `GreetingController`. Para esto primero cree un paquete que se llame `co.edu.uniquindio.application.controllers`. A esta clase añádale la anotación `@RestController`. Y haga que quede así:

```java
package co.edu.uniquindio.application.controllers;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/greeting") // Prefijo común para todas las rutas del controlador
public class GreetingController {

    @GetMapping
    public String greet(){
        return "Hola, bienvenido a la aplicación";
    }

    @GetMapping("/{name}")
    public String greetName(@PathVariable String name){
        return "Hola %s, bienvenido a la aplicación".formatted(name);
    }
}
```

Con base en el código anterior, podemos destacar lo siguiente:

- `@RestController`: Indica que esta clase es un controlador REST, lo que significa que manejará solicitudes HTTP y devolverá respuestas en formato de texto o JSON.
- `@RequestMapping("/greeting")` para que todas las rutas comiencen con `/greeting`. Esto permite que las rutas queden más organizadas y evitamos posibles conflictos con otras rutas en la aplicación.
- `@GetMapping`: Especifica que los métodos dentro del controlador responderán a solicitudes HTTP GET.

El primer método se "activa" cuando un cliente hace una solicitud GET a la raíz del controlador (`/greeting`). Por ejemplo: `http://localhost:8080/greeting` Devuelve el mensaje: "Hola, bienvenido a la aplicación".

El segundo método se "activa" cuando un cliente hace una solicitud GET a la raíz del controlador (`/greeting`), con un parámetro en la URL. Por ejemplo: `http://localhost:8080/greeting/Carlos` Devuelve el mensaje "Hola Carlos, bienvenido a la aplicación".

> **NOTA:** El puerto por defecto es el 8080, pero puede variar según la configuración del proyecto en el archivo `application.properties`.

#### 3. Crear archivo de pruebas HTTP

Para probar estas peticiones se recomienda crear un archivo en la carpeta `test/resources` que se llame por ejemplo `greeting.http` y puede quedar así:

```http
### Saludo
GET http://localhost:8080/greeting

### Saludo con un nombre dado como parámetro
GET http://localhost:8080/greeting/Carlos
```

#### 4. Probar las rutas

Pruebe cada ruta (para esto el servidor debe estar en ejecución). También puede acceder a las rutas desde su navegador web.

#### 5. Crear UserController

Cree una nueva clase que se llame `UserController`. En el paquete `co.edu.uniquindio.aplicacion.controllers`. A esta clase añádale la anotación `@RestController`. Así:

```java
package co.edu.uniquindio.aplicacion.controllers;

import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {

}
```

#### 6. Configurar endpoint

Adicione a dicha clase la url (endpoint) que reconocerá el controlador para dar respuesta a las peticiones HTTP. Agregue lo siguiente debajo de `@RestController`:

```java
@RequestMapping("/api/users")
```

Esto significa que cuando se pida la url `http://localhost:8080/api/users` será el controlador REST que estamos programando quien responda ante las peticiones realizadas.

#### 7. Crear UserService

Cree una variable de tipo `UserService` en la clase `UserController`:

```java
private UserService userService;
```

Para que esto funcione, debe crear una interface con el nombre `UserService` en el paquete `co.edu.uniquindio.application.services`. La idea es que esta interface tenga la definición de los métodos que deben ser implementados con su respectiva lógica de negocio. Por ahora solo nos interesa hacer la definición de los métodos (no su implementación).

#### 8. Crear métodos CRUD

Cree un método para cada servicio de negocio de los usuarios que sea pertinente para la API. A manera de ejemplo se hará el controlador implementando solamente los métodos para hacer un CRUD básico en la entidad. Estos métodos se deben crear en la clase `UserController`:

```java
public void create(CreateUserDTO account) throws Exception{
}

public void edit(EditUserDTO account) throws Exception{
}

public void delete(String id) throws Exception{
}

public DetailUserDTO get(String id) throws Exception{
}

public List<UserDTO> listAll(){
}
```

> **NOTA:** Cada método del controlador debe ser equivalente a los métodos del servicio de los usuarios (tanto en su retorno, su nombre, sus excepciones y sus parámetros). Es necesario crear DTOs que encapsulan los datos tanto de entrada como de salida de la API. Estos DTOs deben estar en el paquete: `co.edu.uniquindio.application.dto`.

#### 9. Crear DTOs con records

Cree los DTOs con los atributos correspondientes para cada método del CRUD. Un DTO es una clase que encapsula la información necesaria para cada requisito específico de la aplicación, separando la lógica de negocio de la estructura de los datos que se intercambian entre el cliente y el servidor.

Dado que los DTO son objetos que no tienen lógica y solo sirven para encapsular atributos, podemos hacer uso de los record de Java, entonces, por ejemplo el DTO `CreateUserDTO` se puede crear así:

```java
package co.edu.uniquindio.application.dto;

public record CreateUserDTO(
    String name,
    String phone,
    String city,
    String address,
    String email,
    String password
) {
}
```

Para más información sobre DTO y los records de Java:
- [Java Record Class y JDK 14](https://www.arquitecturajava.com/java-record-class-y-jdk-14/)
- [Data Transfer Object DTO](https://www.arquitecturajava.com/data-transfer-object-dto-un-concepto-clave/)
- [Patrones Arquitectónicos - DTO](https://reactiveprogramming.io/blog/es/patrones-arquitectonicos/dto)

#### 10. Agregar validaciones a DTOs

Es necesario realizar validaciones sobre cada uno de los atributos de los DTOs que se utilizan para registrar o actualizar información en el backend (por ejemplo, en una base de datos). Con estas validaciones aplicadas, el DTO `CreateUserDTO` quedaría de la siguiente manera:

```java
package co.edu.uniquindio.application.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import org.hibernate.validator.constraints.Length;

public record CreateUserDTO(
    @NotBlank @Length(max = 100) String name,
    @Length(max = 10) String phone,
    @NotBlank @Length(max = 100) String city,
    @NotBlank @Length(max = 100) String address,
    @NotBlank @Length(max = 50) @Email String email,
    @NotBlank @Length(min = 7, max = 20) String password
) {
}
```

El DTO debe tener las validaciones pertinentes para garantizar una buena integridad de los datos. Todos los DTO que represente un objeto que será guardado en la base de datos debe tener las validaciones.

Para más información sobre las anotaciones de validaciones:
- [Validation Constraints](https://javaee.github.io/javaee-spec/javadocs/javax/validation/constraints/package-summary.html)

#### 11. Crear EditUserDTO y UserDTO

Cree el DTO `EditUserDTO` con las validaciones pertinentes. Adicionalmente, cree el DTO `UserDTO`, el cual será utilizado para devolver información al cliente. Dado que este último DTO es una respuesta generada por el backend, no requiere validaciones, ya que los datos ya fueron previamente procesados y verificados.

Para `EditUserDTO`, puede estructurarse de la siguiente manera (se asume que el usuario no puede modificar su correo electrónico ni su contraseña; para cambiar la contraseña, deberá utilizar otro mecanismo):

```java
package co.edu.uniquindio.proyecto.dto;

import jakarta.validation.constraints.NotBlank;
import org.hibernate.validator.constraints.Length;

public record EditUserDTO(
    @NotBlank String id,
    @NotBlank @Length(max = 100) String name,
    @NotBlank @Length(max = 100) String city,
    @NotBlank @Length(max = 100) String address,
    @Length(max = 10) String phone
) {
}
```

#### 12. Agregar anotaciones HTTP a métodos

Como se explicó previamente, a cada método de `UserController` se le debe añadir una anotación de acuerdo al método HTTP que deba dar respuesta. Para obtener se usa GET, para guardar o registrar se usa POST, para borrar DELETE y para modificar PUT.

```java
@PostMapping
public void create(CreateUserDTO account) throws Exception{
}

@PutMapping
public void edit(EditUserDTO account) throws Exception{
}

@DeleteMapping("/{id}")
public void delete(String id) throws Exception{
}

@GetMapping("/{id}")
public UserDTO get(String id) throws Exception{
    return null;
}

@GetMapping
public List<UserDTO> listAll(){
    return null;
}
```

#### 13. Configurar parámetros de entrada

Algunos métodos necesitan información que puede venir por la url o en el cuerpo de la petición. Para esos casos se debe indicar explícitamente como va a llegar dicha información. Si es por la url se debe usar la anotación `@PathVariable` y si es dentro del cuerpo de la petición se usa `@RequestBody`, para este último caso se recomienda que vaya acompañado de la anotación `@Valid` (para que tenga en cuenta las anotaciones de validación de los atributos de los DTO).

Por ejemplo, si deseo obtener la información de todo un objeto, lo más obvio sería enviar el código (id) de dicho objeto y con base en ese valor retornar toda la información restante. Por lo tanto en la url se puede enviar el código. Pero, para el registro de un usuario se debe enviar todo el objeto que se quiera guardar, por lo tanto lo ideal es escribir esta información en el cuerpo de la petición.

> **NOTA:** Para el caso de `@PathVariable`, el nombre del atributo debe coincidir con el nombre que está entre llaves en la url del mapping. Por ejemplo, si tenemos `@PathVariable int id`, entonces la url sería `"/{id}"`, como se observa en el código anterior.

Se puede implementar cada uno de los métodos del controlador REST haciendo uso de las anotaciones correspondientes y del servicio de negocio de los usuarios, así:

```java
@PostMapping
public void create(@Valid @RequestBody CreateUserDTO account) throws Exception{
    userService.create(account);
}

@PutMapping
public void edit(@Valid @RequestBody EditUserDTO account) throws Exception{
    userService.edit(account);
}

@DeleteMapping("/{id}")
public void delete(@PathVariable String id) throws Exception{
    userService.delete(id);
}

@GetMapping("/{id}")
public UserDTO get(@PathVariable String id) throws Exception{
    return userService.get(id);
}

@GetMapping
public List<UserDTO> listAll(){
    return userService.listAll();
}
```

Fíjese que los métodos del controlador no tienen lógica de negocio, simplemente se hace el llamado correspondiente a cada método que está programado en los servicios y se le pasan los mismos parámetros.

#### 14. Implementar ResponseEntity

Como vimos en los métodos anteriores, algunos métodos son void, otros lanzan excepciones que puedan aparecer al momento de realizar alguna operación de consulta, registro, etc. Lo ideal es retroalimentar al usuario siempre, cuando todo funcione bien informarle y cuando algo falla también.

Por ejemplo, para la creación de una nueva cuenta de usuario podemos modificarlo de la siguiente manera para que siempre haya una respuesta:

```java
@PostMapping
public ResponseEntity<ResponseDTO<String>> create(@Valid @RequestBody CreateUserDTO account) throws Exception{
    userService.create(account);
    return ResponseEntity.ok(new ResponseDTO<>(false, "Your registration has been successful"));
}
```

El objeto `ResponseEntity` nos permite asignar un código de respuesta (status) y un contenido, para este caso estamos devolviendo un mensaje en formato JSON. El objetivo del DTO `ResponseDTO` es que todas las respuestas del servidor tengan la misma estructura.

#### 15. Crear RespuestaDTO

Cree `ResponseDTO` en el paquete `co.edu.uniquindio.proyecto.dto` así:

```java
package co.edu.uniquindio.proyecto.dto;

public record ResponseDTO<T>(
    boolean error,
    T content
) {
}
```

Este record tiene un atributo de tipo boolean que indica si hay error o no, y otro atributo de tipo T (genérico) que representará la respuesta como tal. Eso implica que el contenido de la respuesta puede tomar el valor que se requiera: un String, un objeto, una lista, etc.

#### 16. Completar métodos con ResponseEntity

En este otro ejemplo, si existe el codigo de la cuenta de usuario retornamos el detalle de la misma, este detalle está en el objeto `UserDTO`:

```java
@GetMapping("/{id}")
public ResponseEntity<ResponseDTO<UserDTO>> get(@PathVariable String id) throws Exception{
    UserDTO info = userService.get(id);
    return ResponseEntity.ok(new ResponseDTO<>(false, info));
}
```

Este sería el código para eliminar la cuenta de un usuario con el ajuste indicado anteriormente:

```java
@DeleteMapping("/{id}")
public ResponseEntity<ResponseDTO<String>> delete(@PathVariable String id) throws Exception{
    userService.delete(id);
    return ResponseEntity.ok(new ResponseDTO<>(false, "Account deleted successfully"));
}
```

Este sería el código para listar todas las cuentas de los usuarios:

```java
@GetMapping
public ResponseEntity<ResponseDTO<List<UserDTO>>> listAll(){
    List<UserDTO> list = userService.listAll();
    return ResponseEntity.ok(new ResponseDTO<>(false, list));
}
```

Y finalmente, este sería el método de editar su perfil:

```java
@PutMapping
public ResponseEntity<ResponseDTO<String>> edit(@Valid @RequestBody EditUserDTO account) throws Exception{
    userService.edit(account);
    return ResponseEntity.ok(new ResponseDTO<>(false, "Account edited successfully"));
}
```

Códigos de estado HTTP: [HTTP Status Codes - MDN](https://developer.mozilla.org/es/docs/Web/HTTP/Status)

#### 17. Manejo de excepciones

El manejo de las excepciones se debe programar en una nueva clase a la que llamaremos `RestExceptionHandler`. Básicamente esta clase mostrará un mensaje de error personalizado al usuario según el tipo de excepción que arroje el servicio (cualquier servicio).

Dentro del paquete `co.edu.uniquindio.application.exceptions` cree la clase `RestExceptionHandler` con la anotación `@RestControllerAdvice` así:

```java
package co.edu.uniquindio.application.exceptions;

import co.edu.uniquindio.application.dto.ResponseDTO;
import co.edu.uniquindio.application.dto.ValidationDTO;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.servlet.resource.NoResourceFoundException;

import java.util.ArrayList;
import java.util.List;

@RestControllerAdvice
public class RestExceptionHandler {

    @ExceptionHandler(NoResourceFoundException.class)
    public ResponseEntity<ResponseDTO<String>> noResourceFoundExceptionHandler(NoResourceFoundException ex){
        return ResponseEntity.status(404).body( new ResponseDTO<>(true, "The resource was not found") );
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ResponseDTO<String>> generalExceptionHandler (Exception e){
        return ResponseEntity.internalServerError().body( new ResponseDTO<>(true, e.getMessage()) );
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ResponseDTO<List<ValidationDTO>>> validationExceptionHandler ( MethodArgumentNotValidException ex ) {
        List<ValidationDTO> errors = new ArrayList<>();
        BindingResult results = ex.getBindingResult();
        for (FieldError e: results.getFieldErrors()) {
            errors.add( new ValidationDTO(e.getField(), e.getDefaultMessage()) );
        }
        return ResponseEntity.badRequest().body( new ResponseDTO<>(true, errors) );
    }
}
```

Cada método de la clase `RestExceptionHandler` responde a una excepción que puede ser arrojada en cualquier momento por cualquier servicio de negocio. Para diferenciar cada método se hace uso de la anotación `@ExceptionHandler`. Acá una breve descripción de cada una:

- **NoResourceFoundException:** Excepción que se lanza cuando se trata de acceder a un recurso que no existe.
- **Exception:** Excepción general de Java. Lo ideal es tener excepciones propias para cada tipo de error y no ponerle a todas las excepciones simplemente Exception.
- **MethodArgumentNotValidException:** Excepción que se lanza cuando no se cumple alguna validación puesta en los DTO (@NotNull, @Email, @Max, etc..). Para este caso debe crear un nuevo DTO con el nombre: `ValidationDTO`, este record debe debe tener dos String: campo y mensaje.

#### 18. Crear archivo de pruebas para usuarios

Pruebe cada ruta, para esto, cree un nuevo archivo en la carpeta `test/resources` que se llame `users.http` y que tenga lo siguiente:

```http
### Get all users
GET http://localhost:8080/api/users

### Get a user by id
GET http://localhost:8080/api/users/1

### Create a user
POST http://localhost:8080/api/users
Content-Type: application/json

{
  "name": "Carlos",
  "city": "Armenia",
  "address": "Street 123",
  "email": "carlos@email.com",
  "password": "123456"
}

### Update a user
PUT http://localhost:8080/api/users
Content-Type: application/json

{
  "id": 1,
  "name": "Carlos",
  "city": "Armenia",
  "address": "New address"
}

### Delete a user
DELETE http://localhost:8080/api/users/1
```

Lo más probable es que falle ya que la interface `UserService` aún no tiene ninguna implementación, por lo tanto puede hacer una implementación básica con datos "quemados" para probar o incluso dejar los métodos vacíos. Para esto, cree la clase `UserServiceImpl` en el paquete `co.edu.uniquindio.application.services.impl`.

```java
package co.edu.uniquindio.application.services.impl;

import co.edu.uniquindio.application.services.UserService;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class UserServiceImpl implements UserService {
    //TODO implement all interface methods
}
```

`@Service` es una anotación de Spring que indica que esta clase es un servicio. Se usa en la capa de servicio para manejar la lógica de negocio.

#### 19. Configurar inyección de dependencias

Modifique la clase `UserController` para que use la implementación de la interfaz hecha en el punto anterior. Para esto, debe hacer que la variable userService sea final, así:

```java
private final UserService userService;
```

Para que esta variable se inicialice, se debe agregar la anotación `@RequiredArgsConstructor` (de Lombok) a nivel de la clase (debajo de la anotación `@RestController`).

Esta anotación genera automáticamente un constructor con los argumentos requeridos. Se aplica a los atributos marcados como final, lo que significa que Spring los inyectará automáticamente cuando lo requiera. Esto evita el código repetitivo de escribir un constructor manualmente.

Si no usamos la anotación `@RequiredArgsConstructor`, nos tocaría escribir el constructor así:

```java
public UserController(UserService userService) {
    this.userService = userService;
}
```

#### 20. Probar funcionalidad

Pruebe cada ruta y verifique su correcto funcionamiento, incluyendo los casos en los que falle. (para esto el servidor debe estar en ejecución).

#### 21. Implementar filtros con @RequestParam

Modifique el método `listAll` de la clase `UserController` para que permita obtener usuarios filtrados por su nombre y por su ciudad (ambos opcionales). En este caso, se aconseja hacer algo así:

```java
@GetMapping
public ResponseEntity<ResponseDTO<List<UserDTO>>> listAll(
    @RequestParam(required = false) String name,
    @RequestParam(required = false) String city
) {
    List<UserDTO> users = userService.listAll(name, city);
    return ResponseEntity.ok(new ResponseDTO<>(false, users));
}
```

`@RequestParam` se usa para enviar parámetros por la url a la petición. En este caso, estas peticiones son válidas:

```http
### Get all users that have a given name
GET http://localhost:8080/api/users?name=Carlos

### Get all users whose city of residence is Armenia
GET http://localhost:8080/api/users?city=Armenia

### Get all users whose city of residence is Armenia and their name is Carlos
GET http://localhost:8080/api/users?city=Armenia&name=Carlos
```

> **NOTA:** Se recomienda crear un DTO cuando se requieren múltiples filtros y utilizar `@ModelAttribute` en lugar de `@RequestParam` individuales, esto para mantener un código más limpio y organizado.

#### 22. Implementar filtros en el servicio

Modifique el servicio `listAll` para que acepte los filtros, cree algunos datos de prueba y verifique que el filtro funciona correctamente.

#### 23. Crear controlador de reportes

Cree una nueva clase y programe un nuevo `@RestController` para manejar la parte de los reportes (alertas) del proyecto final (puede empezar con el CRUD). Consulte las buenas prácticas para crear las rutas y los códigos de respuesta. Y haga el respectivo archivo de pruebas (.http).

#### 24. Programar todos los RestControllers

Programe los demás `@RestController` para todos requerimientos del proyecto final. Consulte las buenas prácticas para crear las rutas y los códigos de respuesta.

#### 25. Identificar rutas protegidas

Piense qué rutas deben estar protegidas (se requiere autenticación para usarla)

#### 26. Métodos de prueba

Para probar los diferentes métodos de los controladores podemos hacerlo de muchas maneras, en esta guía veremos tres: Postman, Swagger (OpenAPI) y pruebas unitarias con MockMvc. No es necesario que use los tres métodos para probar la API, con que use uno es suficiente.

---

## Para la próxima clase

- ¿Cómo se pueden obtener respuestas paginadas? Investigar sobre `PageRequest` y `Pageable`.
- ¿Qué otras herramientas sirven para probar APIs?
- Investigue sobre GraphQL, ¿para qué sirve? ¿Qué ventajas y desventajas tiene frente a REST?

---

## **Referencias Bibliográficas**  

1. Fielding, R. T. (2000). *Architectural Styles and the Design of Network-based Software Architectures*. University of California, Irvine.  
2. RFC 7231 - *Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content*. [IETF RFC 7231](https://tools.ietf.org/html/rfc7231).  
3. OpenAPI Initiative. (2023). *OpenAPI Specification*. [OpenAPI Docs](https://www.openapis.org/).  
4. Richardson, L., & Amundsen, M. (2016). *RESTful Web APIs*. O'Reilly Media.  
5. OWASP. (2021). *OWASP Top Ten*. [OWASP Docs](https://owasp.org/www-project-top-ten/).
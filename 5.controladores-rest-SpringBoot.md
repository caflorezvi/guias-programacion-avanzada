```
Programa de Ingenier铆a de Sistemas y Computaci贸n
Universidad del Quind铆o

T铆tulo: Implementaci贸n de Servicios REST en Spring Boot
Duraci贸n estimada: 120
Docentes: Carlos Andr茅s Florez, Christian Andr茅s Candela
Gu铆a: 05
```
# **Controladores REST en Spring Boot**

## ** Objetivo**  
Implementar una API REST utilizando **Spring Boot**, basada en un dise帽o previo realizado con **OpenAPI**. Los estudiantes aprender谩n a traducir un dise帽o de API en una implementaci贸n funcional en Java, aplicando principios de programaci贸n empresarial y buenas pr谩cticas de desarrollo.

---

## **Conceptos B谩sicos**  
Antes de iniciar con el dise帽o, es importante comprender algunos conceptos fundamentales:

#### **1. REST (Representational State Transfer)**  
Estilo arquitect贸nico basado en principios como:
- Separaci贸n cliente-servidor.
- Uso de recursos identificados por URIs.
- Uso de m茅todos HTTP est谩ndar (GET, POST, PUT, DELETE, PATCH, etc.).
- Implementaci贸n de respuestas sin estado (**stateless**).
- Cacheabilidad y escalabilidad.

**Referencia:** Fielding, R. T. (2000). *Architectural Styles and the Design of Network-based Software Architectures*. University of California, Irvine.

#### **2. HTTP (Hypertext Transfer Protocol)**  
Protocolo de comunicaci贸n para la transferencia de datos en la web. Define m茅todos est谩ndar como:
- **GET**: Obtener informaci贸n.
- **POST**: Crear un nuevo recurso.
- **PUT**: Actualizar un recurso existente.
- **DELETE**: Eliminar un recurso.

**Referencia:** RFC 7231 - *Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content*. [IETF RFC 7231](https://tools.ietf.org/html/rfc7231).

#### **3. OpenAPI**  
Especificaci贸n abierta para describir APIs RESTful, permitiendo generar documentaci贸n interactiva, facilitar la integraci贸n con herramientas de prueba y mejorar la interoperabilidad.

**Referencia:** OpenAPI Initiative. (2023). *OpenAPI Specification*. [OpenAPI Docs](https://www.openapis.org/).

---

## **Contextualizaci贸n Te贸rica**  

### **Dise帽o de APIs y Documentaci贸n con OpenAPI**  
La documentaci贸n de APIs es crucial para garantizar que los desarrolladores puedan entender y utilizar los servicios web de manera efectiva. **OpenAPI** permite:  
- Generar documentaci贸n interactiva (Swagger UI).  
- Facilitar la integraci贸n con herramientas de prueba como Postman.  
- Mejorar la interoperabilidad entre sistemas heterog茅neos.  

#### **Herramientas para Documentaci贸n y Pruebas de APIs**  
- **Swagger UI:** Interfaz interactiva para explorar y probar APIs.  
- **Postman:** Herramienta para realizar pruebas y validar respuestas.  
- **Insomnia:** Alternativa ligera para pruebas de APIs.  

**Referencia:** Richardson, L., & Amundsen, M. (2016). *RESTful Web APIs*. O'Reilly Media.  

---

### Validaci贸n de Datos con Bean Validation
La validaci贸n de datos es una parte fundamental en el desarrollo de APIs RESTful, ya que garantiza que los datos proporcionados por los usuarios cumplan con ciertos criterios antes de ser procesados. **Bean Validation** es un est谩ndar de Java (Jakarta EE) que permite validar objetos de manera declarativa mediante anotaciones. Esto simplifica el proceso de validaci贸n y reduce la cantidad de c贸digo necesario.

#### **Validaciones Comunes**
A continuaci贸n, se presenta un listado de las anotaciones m谩s comunes para validar datos en Java, junto con ejemplos simples:

1. **`@NotNull`**: Asegura que el campo no sea nulo.
   ```java
   @NotNull(message = "El nombre no puede ser nulo")
   private String nombre;
   ```

2. **`@NotBlank`**: Asegura que el campo no sea nulo ni est茅 vac铆o (ignora espacios en blanco).
   ```java
   @NotBlank(message = "El email no puede estar vac铆o")
   private String email;
   ```

3. **`@Size`**: Verifica que el tama帽o del campo est茅 dentro de un rango espec铆fico.
   ```java
   @Size(min = 5, max = 50, message = "El nombre debe tener entre 5 y 50 caracteres")
   private String nombre;
   ```

4. **`@Min` y `@Max`**: Valida que un n煤mero est茅 dentro de un rango m铆nimo o m谩ximo.
   ```java
   @Min(value = 18, message = "La edad m铆nima es 18 a帽os")
   @Max(value = 99, message = "La edad m谩xima es 99 a帽os")
   private int edad;
   ```

5. **`@Email`**: Verifica que el campo sea un correo electr贸nico v谩lido.
   ```java
   @Email(message = "Debe ser un email v谩lido")
   private String email;
   ```

6. **`@Pattern`**: Valida que el campo coincida con una expresi贸n regular.
   ```java
   @Pattern(regexp = "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).*$", message = "La contrase帽a debe contener al menos un n煤mero, una letra min煤scula y una may煤scula")
   private String password;
   ```

7. **`@Past` y `@Future`**: Verifica que una fecha sea pasada o futura.
   ```java
   @Past(message = "La fecha de nacimiento debe ser en el pasado")
   private LocalDate fechaNacimiento;

   @Future(message = "La fecha de vencimiento debe ser en el futuro")
   private LocalDate fechaVencimiento;
   ```

8. **`@Positive` y `@Negative`**: Valida que un n煤mero sea positivo o negativo.
   ```java
   @Positive(message = "El saldo debe ser positivo")
   private double saldo;

   @Negative(message = "El descuento debe ser negativo")
   private double descuento;
   ```

9. **`@Digits`**: Valida que un n煤mero tenga una cantidad espec铆fica de d铆gitos enteros y decimales.
   ```java
   @Digits(integer = 5, fraction = 2, message = "El precio debe tener hasta 5 d铆gitos enteros y 2 decimales")
   private BigDecimal precio;
   ```

10. **`@AssertTrue` y `@AssertFalse`**: Valida que un valor booleano sea verdadero o falso.
    ```java
    @AssertTrue(message = "Debe aceptar los t茅rminos y condiciones")
    private boolean terminosYCondiciones;
    ```

#### **Uso de `@Valid`**
Para activar las validaciones en un controlador Spring Boot, se utiliza la anotaci贸n `@Valid` junto con `@RequestBody`:
```java
@PostMapping("/usuarios")
public ResponseEntity<?> crearUsuario(@Valid @RequestBody UsuarioRequest usuario) {
    // L贸gica para crear el usuario
    return ResponseEntity.status(HttpStatus.CREATED).body(usuario);
}
```

**Referencia:**

  - [Documentaci贸n de la API de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/apidocs/jakarta/validation/constraints/package-summary)  
  - [Introducci贸n a la Validaci贸n de Beans en Jakarta EE](https://jakarta.ee/learn/docs/jakartaee-tutorial/current/beanvalidation/bean-validation/bean-validation.html)
  - [Especificaci贸n de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0)  

---

### Representaci贸n de M茅todos HTTP en Spring Boot
Spring Boot utiliza anotaciones espec铆ficas para mapear m茅todos a operaciones HTTP. Estas anotaciones permiten definir c贸mo se manejan las solicitudes entrantes.

#### **Anotaciones Principales**
1. **`@GetMapping`**: Maneja solicitudes HTTP GET.
   ```java
   @GetMapping("/usuarios/{id}")
   public ResponseEntity<Usuario> obtenerUsuarioPorId(@PathVariable Long id) {
       // L贸gica para obtener el usuario por ID
       return ResponseEntity.ok(usuario);
   }
   ```

2. **`@PostMapping`**: Maneja solicitudes HTTP POST.
   ```java
   @PostMapping("/usuarios")
   public ResponseEntity<Usuario> crearUsuario(@RequestBody Usuario usuario) {
       // L贸gica para crear el usuario
       return ResponseEntity.status(HttpStatus.CREATED).body(usuario);
   }
   ```

3. **`@PutMapping`**: Maneja solicitudes HTTP PUT.
   ```java
   @PutMapping("/usuarios/{id}")
   public ResponseEntity<Usuario> actualizarUsuario(@PathVariable Long id, @RequestBody Usuario usuarioActualizado) {
       // L贸gica para actualizar el usuario
       return ResponseEntity.ok(usuarioActualizado);
   }
   ```

4. **`@DeleteMapping`**: Maneja solicitudes HTTP DELETE.
   ```java
   @DeleteMapping("/usuarios/{id}")
   public ResponseEntity<Void> eliminarUsuario(@PathVariable Long id) {
       // L贸gica para eliminar el usuario
       return ResponseEntity.noContent().build();
   }
   ```

5. **`@PatchMapping`**: Maneja solicitudes HTTP PATCH (actualizaciones parciales).
   ```java
   @PatchMapping("/usuarios/{id}")
   public ResponseEntity<Usuario> actualizarParcialmenteUsuario(@PathVariable Long id, @RequestBody Map<String, Object> camposActualizados) {
       // L贸gica para actualizar parcialmente el usuario
       return ResponseEntity.ok(usuarioActualizado);
   }
   ```

---

### Tipos de Entrada de Datos en un M茅todo
En Spring Boot, existen varias formas de recibir datos de entrada en un m茅todo de un controlador. Cada forma tiene su prop贸sito espec铆fico y se utiliza con anotaciones diferentes.

#### **1. Datos en el Cuerpo de la Solicitud (`@RequestBody`)**
Se utiliza para recibir datos en formato JSON o XML en el cuerpo de la solicitud.
```java
@PostMapping("/usuarios")
public ResponseEntity<Usuario> crearUsuario(@RequestBody Usuario usuario) {
    // L贸gica para crear el usuario
    return ResponseEntity.status(HttpStatus.CREATED).body(usuario);
}
```

#### **2. Datos en la URL (`@PathVariable`)**
Se utiliza para extraer valores de la URL.
```java
@GetMapping("/usuarios/{id}")
public ResponseEntity<Usuario> obtenerUsuarioPorId(@PathVariable Long id) {
    // L贸gica para obtener el usuario por ID
    return ResponseEntity.ok(usuario);
}
```

#### **3. Datos en los Par谩metros de Consulta (`@RequestParam`)**
Se utiliza para recibir datos como par谩metros de consulta en la URL.
```java
@GetMapping("/usuarios")
public ResponseEntity<List<Usuario>> buscarUsuariosPorNombre(@RequestParam String nombre) {
    // L贸gica para buscar usuarios por nombre
    return ResponseEntity.ok(usuarios);
}
```

#### **4. Datos en Encabezados (`@RequestHeader`)**
Se utiliza para recibir datos de los encabezados HTTP.
```java
@GetMapping("/usuarios")
public ResponseEntity<List<Usuario>> obtenerUsuarios(@RequestHeader("Authorization") String token) {
    // L贸gica para verificar el token y devolver usuarios
    return ResponseEntity.ok(usuarios);
}
```

#### **5. Datos en Cookies (`@CookieValue`)**
Se utiliza para recibir datos almacenados en cookies.
```java
@GetMapping("/usuarios")
public ResponseEntity<List<Usuario>> obtenerUsuarios(@CookieValue("sessionId") String sessionId) {
    // L贸gica para verificar la sesi贸n y devolver usuarios
    return ResponseEntity.ok(usuarios);
}
```

#### **6. Datos en Formularios (`@ModelAttribute`)**
Se utiliza para recibir datos enviados desde formularios HTML.
```java
@PostMapping("/usuarios/formulario")
public ResponseEntity<Usuario> crearUsuarioDesdeFormulario(@ModelAttribute Usuario usuario) {
    // L贸gica para crear el usuario
    return ResponseEntity.status(HttpStatus.CREATED).body(usuario);
}
```
---

## **Buenas pr谩cticas y recomendaciones**  

1. **Consistencia en las Rutas:**  
   - Utilizar nombres de recursos en plural (e.g., `/users` en lugar de `/user`).
   - Evitar verbos en las rutas (e.g., `/users/{id}` en lugar de `/getUserById/{id}`).
   
2. **Uso de C贸digos de Estado HTTP:**  
   - `200 OK`: Solicitud exitosa.
   - `201 Created`: Recurso creado.
   - `400 Bad Request`: Error en la solicitud del cliente.
   - `404 Not Found`: Recurso no encontrado.
   - `500 Internal Server Error`: Error en el servidor.

3. **Seguridad en APIs:**  
   - Implementar autenticaci贸n y autorizaci贸n con **OAuth2** o **JWT**.
   - Proteger los datos sensibles con HTTPS.
   - Validar y sanitizar entradas para prevenir ataques **SQL Injection** y **XSS**.

**Referencia:** OWASP. (2021). *OWASP Top Ten*. [OWASP Docs](https://owasp.org/www-project-top-ten/).

---

## **Procedimiento**  
A continuaci贸n, se presentan un conjunto de pasos y requerimientos generales para la construcci贸n de su API REST. Los estudiantes deben usar el dise帽o OpenAPI previamente elaborado como elemento base para la construcci贸n de su API en Spring Boot:


### **1. Configuraci贸n del Proyecto Spring Boot**  

#### **Creaci贸n del Proyecto:**  
   - Ingresa al siguiente enlace: [https://start.spring.io/](https://start.spring.io/).  
   - Selecciona las siguientes dependencias:
     - **Spring Web**: Para construir aplicaciones web, incluyendo RESTful.
     - **Spring Boot DevTools**: Para desarrollo r谩pido.
     - **Validation**: Para hacer uso de los bean validation.
   - Descarga el proyecto y 谩brelo en tu IDE favorito.

#### **Modificaci贸n del Proyecto:**  
   - En su archivo build.gradle adicione las siguientes dependencias:
  
  ```grovy
  implementation 'org.springframework.boot:spring-boot-starter-validation'
  implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.5'
  ```

#### **Estructura del Proyecto:**  
   - El proyecto generado incluye:  
     - `src/main/java`: C贸digo fuente.  
     - `src/main/resources`: Archivos de configuraci贸n (`application.properties`, OpenAPI).  
     - `build.gradle`: Archivo Gradle para gesti贸n de dependencias.  

---

### **2. Implementaci贸n de Operaciones REST**

#### **Creaci贸n de Estructuras para Representaci贸n de Datos**  
- Basado en su archivo de especificaci贸n OpenAPI, cree estructuras de c贸digo que representen los esquemas de informaci贸n usados en cada una de sus operaciones.
- Adicione a cada uno de los campos de sus clases las validaciones que correspondan. 

**Ejemplo**  

```java

import co.edu.uniquindio.ingesis.domain.Rol;
import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.validation.constraints.*;

import java.time.LocalDate;
import java.util.Objects;

public record UserRegistrationRequest(
   @NotBlank(message = "El campo es requerido")
   @Email(message = "Debe ser un email v谩lido")
   String email,
   @NotBlank(message = "El campo es requerido")
   @Pattern(regexp = "^(?=.*\\\\d)(?=.*[a-z])(?=.*[A-Z]).*$",message = "Debe contener al menos: un n煤mero, una letra min煤scula y una may煤scula ")
   @Size(min = 8,message = "La longitud m铆nima es 8")
   String password,
   @NotBlank(message = "El campo es requerido")
   @Size(max = 100,message = "No debe exceder los 100 caracteres")
   String fullName,
   @NotNull(message = "La fecha no puede ser nula")
   @PastOrPresent(message = "La fecha no puede ser futura")
   @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
   LocalDate dateBirth,
   Rol rol) {

   public UserRegistrationRequest {
      rol = Objects.requireNonNullElse(rol,Rol.USER);
   }
}
```

#### **Implementaci贸n de la Clase Controlador**  
- Cree una clase controlador para su API, por ejemplo, `UserController`. Esta clase debe estar en un paquete espec铆fico, como `co.edu.uniquindio.ingesis.api.controllers`.

**Ejemplo:**  

```java
package co.edu.uniquindio.ingesis.api.controllers;

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/users")
public class UserController {

   
}
```

#### **Implementaci贸n de Operaciones**  
- Implemente uno a uno los m茅todos que componen su API.

**Ejemplo:**  

```java
@PostMapping
public ResponseEntity<UserResponse> createUser(@Valid @RequestBody UserRegistrationRequest request) {
   // L贸gica para crear un usuario

   // Construir la URL del nuevo recurso
   URI location = ServletUriComponentsBuilder
            .fromCurrentRequest()
            .path("/{id}")
            .buildAndExpand(usuarioCreado.getId())
            .toUri();

   // Devolver la respuesta con el c贸digo 201 y la URL en la cabecera Location
   return ResponseEntity
            .created(location) // Establece el c贸digo 201 y la cabecera Location
            .body(usuarioCreado); // Devuelve el usuario en el cuerpo de la respuesta
}
```

o

```java
@PostMapping
public UserResponse createUser(@Valid @RequestBody UserRegistrationRequest request) {
   // L贸gica para crear un usuario

   // Devolver la respuesta 
   return usuarioCreado;
}
```


Nota:
   - `@PostMapping` identifica el m茅todo HTTP a ser usado
   - `@Valid` le indica al sistema que debe validar los datos de entrada usando las anotaciones.
   - `@RequestBody` le indica al sistema que los datos de entrada para el registro del usuario est谩n en el cuerpo de la solicitud.
   - La diferencia entre usar el DTO `UserResponse` y el `ResponseEntity`, es que al usar el Response podemos controlar el status code retornado, al retornar un DTO, la implementaci贸n es m谩s simple, pero se retorna por defecto un status code 200.

---

### **3. Prueba de Operaciones**  

- Usa Postman o Swagger UI para enviar solicitudes a tu API.
- Inicia el servidor Spring Boot:  
```bash
./gradlew bootRun
```  
o Acceda al Main de su aplicaci贸n y ejec煤telo.

- Accede a Swagger UI en: [http://localhost:8080/swagger-ui.html](http://localhost:8080/swagger-ui.html). 

---

### **4. Avance de proyecto**

Del proyecto final identifique al menos un recurso m谩s dise帽e el conjunto de operaciones para dicho recurso y posteriormente implemente las estructuras de representaci贸n de datos y la clase controladora para dichos recursos.

---

## **Referencias Bibliogr谩ficas**  

1. Fielding, R. T. (2000). *Architectural Styles and the Design of Network-based Software Architectures*. University of California, Irvine.  
2. RFC 7231 - *Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content*. [IETF RFC 7231](https://tools.ietf.org/html/rfc7231).  
3. OpenAPI Initiative. (2023). *OpenAPI Specification*. [OpenAPI Docs](https://www.openapis.org/).  
4. Richardson, L., & Amundsen, M. (2016). *RESTful Web APIs*. O'Reilly Media.  
5. OWASP. (2021). *OWASP Top Ten*. [OWASP Docs](https://owasp.org/www-project-top-ten/).
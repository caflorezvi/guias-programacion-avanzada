<!-- Aqu铆 cargamos Mermaid.js --> 
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> 
<script> document.addEventListener("DOMContentLoaded", function() { mermaid.initialize({ startOnLoad: true }); }); </script>

```
Programa de Ingenier铆a de Sistemas y Computaci贸n
Universidad del Quind铆o

T铆tulo: Implementaci贸n de Servicios REST en Spring Boot
Duraci贸n estimada: 120
Docentes: Carlos Andr茅s Florez, Christian Andr茅s Candela
Gu铆a: 05
```
# Controladores REST en Spring Boot

##  Objetivo
Implementar una API REST utilizando **Spring Boot**, basada en un dise帽o previo realizado con **OpenAPI**. Los estudiantes aprender谩n a traducir un dise帽o de API en una implementaci贸n funcional en Java, aplicando principios de programaci贸n empresarial y buenas pr谩cticas de desarrollo.

---

## Conceptos B谩sicos
Antes de iniciar con el dise帽o, es importante comprender algunos conceptos fundamentales:

#### 1. REST (Representational State Transfer)
Estilo arquitect贸nico basado en principios como:
- Separaci贸n cliente-servidor.
- Uso de recursos identificados por URIs.
- Uso de m茅todos HTTP est谩ndar (GET, POST, PUT, DELETE, PATCH, etc.).
- Implementaci贸n de respuestas sin estado (**stateless**).
- Cacheabilidad y escalabilidad.

**Referencia:** Fielding, R. T. (2000). *Architectural Styles and the Design of Network-based Software Architectures*. University of California, Irvine.

#### 2. HTTP (Hypertext Transfer Protocol) 
Protocolo de comunicaci贸n para la transferencia de datos en la web. Define m茅todos est谩ndar como:
- **GET**: Obtener informaci贸n.
- **POST**: Crear un nuevo recurso.
- **PUT**: Actualizar un recurso existente.
- **PATCH**: Actualizar parcialmente un recurso.
- **DELETE**: Eliminar un recurso.

**Referencia:** RFC 7231 - *Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content*. [IETF RFC 7231](https://tools.ietf.org/html/rfc7231).

#### 3. OpenAPI
Especificaci贸n abierta para describir APIs RESTful, permitiendo generar documentaci贸n interactiva, facilitar la integraci贸n con herramientas de prueba y mejorar la interoperabilidad.

**Referencia:** OpenAPI Initiative. (2023). *OpenAPI Specification*. [OpenAPI Docs](https://www.openapis.org/).

---

## Contextualizaci贸n Te贸rica  

### Dise帽o de APIs y Documentaci贸n con OpenAPI
La documentaci贸n de APIs es crucial para garantizar que los desarrolladores puedan entender y utilizar los servicios web de manera efectiva. **OpenAPI** permite:  
- Generar documentaci贸n interactiva (Swagger UI).  
- Facilitar la integraci贸n con herramientas de prueba como Postman.  
- Mejorar la interoperabilidad entre sistemas heterog茅neos.  

#### Herramientas para Documentaci贸n y Pruebas de APIs 
- **Swagger UI:** Interfaz interactiva para explorar y probar APIs.  
- **Postman:** Herramienta para realizar pruebas y validar respuestas.  
- **Insomnia:** Alternativa ligera para pruebas de APIs.  

### API REST en Spring Boot
Spring Boot facilita la creaci贸n de APIs REST mediante la utilizaci贸n de anotaciones y convenciones que simplifican el desarrollo. Algunas caracter铆sticas clave incluyen:
- **Controladores REST:** Clases anotadas con `@RestController` que manejan las solicitudes HTTP.
- **Serializaci贸n/Deserializaci贸n:** Conversi贸n autom谩tica entre objetos Java y JSON/XML.
- **Manejo de Errores:** Respuestas de error estandarizadas mediante `@RestControllerAdvice`.

En el siguiente diagrama se muestra una arquitectura simplificada del acceso a la informaci贸n desde la capa de presentaci贸n (cliente).

<div class="mermaid">
graph LR
    CA[Client Application] <--> |APIs| C[Controller<br/>Request mapping]
    
    C <--> S[Service<br/>Business logic]

    S <--> R[Repository<br/>DB interactions]
    
    M[Model<br/>DAO] <--> R

    M <--> DB[(DB)]
    
    classDef clientApp fill:#f9ca24
    classDef controller fill:#f0b3b3
    classDef service fill:#a4d7f5
    classDef repository fill:#a8e6a3
    classDef model fill:#ddb3dd
    classDef database fill:#d3d3d3
    
    class CA clientApp
    class C controller
    class S service
    class R repository
    class M model
    class DB database
</div>

El proceso de petici贸n desde el cliente a los servicios de Spring Boot sigue el modelo de arquitectura Cliente-Servidor y se basa en el protocolo HTTP (o HTTPS). Aqu铆 hay un resumen general del proceso:

- Un cliente (como un navegador web o una aplicaci贸n m贸vil) inicia una solicitud enviando una petici贸n HTTP al servidor Spring Boot.

- En el servidor Spring Boot, las peticiones son manejadas por controladores. Los controladores est谩n anotados con `@Controller`, `@RestController` u otras anotaciones espec铆ficas de Spring.

- El controlador realiza las operaciones necesarias en funci贸n de la l贸gica de negocio. Puede interactuar con servicios, acceder a bases de datos, realizar operaciones y preparar datos para enviar como respuesta.

- Generaci贸n de la respuesta: Una vez que el controlador ha completado su l贸gica, genera una respuesta. La respuesta generada por el controlador se env铆a de vuelta al cliente a trav茅s del protocolo HTTP.

- El cliente (por ejemplo, un navegador web o una aplicaci贸n m贸vil) recibe la respuesta y realiza acciones seg煤n la l贸gica de la aplicaci贸n.


**Referencias:**

  - [Documentaci贸n de Spring Boot sobre REST](https://spring.io/guides/gs/rest-service)
  - [Documentaci贸n de la API de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/apidocs/jakarta/validation/constraints/package-summary)  
  - [Introducci贸n a la Validaci贸n de Beans en Jakarta EE](https://jakarta.ee/learn/docs/jakartaee-tutorial/current/beanvalidation/bean-validation/bean-validation.html)
  - [Especificaci贸n de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0)  

---

## Procedimiento

### 1. Configuraci贸n inicial

Aseg煤rese que tiene las siguientes dependencias a帽adidas en el archivo `build.gradle` del proyecto de Spring Boot:

```kotlin
implementation("org.springframework.boot:spring-boot-starter-web")
implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.7")
```

### 2. Crear un controlador simple

Cree una clase que se llame `GreetingController`. Para esto primero cree un paquete que se llame `co.edu.uniquindio.application.controllers`. A esta clase a帽谩dale la anotaci贸n `@RestController`. Y haga que quede as铆:

```java
package co.edu.uniquindio.application.controllers;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/greeting") // Prefijo com煤n para todas las rutas del controlador
public class GreetingController {

    @GetMapping
    public String greet(){
        return "Hola, bienvenido a la aplicaci贸n";
    }

    @GetMapping("/{name}")
    public String greetName(@PathVariable String name){
        return "Hola %s, bienvenido a la aplicaci贸n".formatted(name);
    }
}
```

Con base en el c贸digo anterior, podemos destacar lo siguiente:

- `@RestController`: Indica que esta clase es un controlador REST, lo que significa que manejar谩 solicitudes HTTP y devolver谩 respuestas en formato de texto o JSON.
- `@RequestMapping("/greeting")` para que todas las rutas comiencen con `/greeting`. Esto permite que las rutas queden m谩s organizadas y evitamos posibles conflictos con otras rutas en la aplicaci贸n.
- `@GetMapping`: Especifica que los m茅todos dentro del controlador responder谩n a solicitudes **HTTP GET**.

El primer m茅todo se "activa" cuando un cliente hace una solicitud GET a la ra铆z del controlador (`/greeting`). Por ejemplo: `http://localhost:8080/greeting` Devuelve el mensaje: "Hola, bienvenido a la aplicaci贸n".

El segundo m茅todo se "activa" cuando un cliente hace una solicitud GET a la ra铆z del controlador (`/greeting`), con un par谩metro en la URL. Por ejemplo: `http://localhost:8080/greeting/Carlos` Devuelve el mensaje "Hola Carlos, bienvenido a la aplicaci贸n".

> **锔 NOTA:** El puerto por defecto es el 8080, pero puede variar seg煤n la configuraci贸n del proyecto en el archivo `application.properties`.

### 3. Crear archivo de pruebas HTTP

Para probar estas peticiones se recomienda crear un archivo en la carpeta `test/resources` que se llame por ejemplo `greeting.http` y puede quedar as铆:

```bash
### Saludo
GET http://localhost:8080/greeting

### Saludo con un nombre dado como par谩metro
GET http://localhost:8080/greeting/Carlos
```

### 4. Probar las rutas

Pruebe cada ruta (para esto el servidor debe estar en ejecuci贸n). Tambi茅n puede acceder a las rutas desde su navegador web.

### 5. Crear UserController

Cree una nueva clase que se llame `UserController`. En el paquete `co.edu.uniquindio.application.controllers`. A esta clase a帽谩dale la anotaci贸n `@RestController`. As铆:

```java
package co.edu.uniquindio.application.controllers;

import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {

}
```

### 6. Configurar endpoint

Adicione a dicha clase la url (endpoint) que reconocer谩 el controlador para dar respuesta a las peticiones HTTP. Agregue lo siguiente debajo de `@RestController`:

```java
@RequestMapping("/api/users")
```

Esto significa que cuando se pida la url `http://localhost:8080/api/users` ser谩 el controlador REST que estamos programando quien responda ante las peticiones realizadas.

### 7. Crear m茅todos CRUD

Cree un m茅todo para cada servicio de negocio de los usuarios que sea pertinente para la API. A manera de ejemplo se har谩 el controlador implementando solamente los m茅todos para hacer un CRUD b谩sico en la entidad. Estos m茅todos se deben crear en la clase `UserController`:

```java
public void create(CreateUserDTO userDTO) throws Exception{
}

public void edit(EditUserDTO userDTO) throws Exception{
}

public void delete(String id) throws Exception{
}

public UserDTO get(String id) throws Exception{
}

public List<UserDTO> listAll(){
}
```

> **锔 NOTA:** Cada m茅todo del controlador debe ser equivalente a los m茅todos del servicio de los usuarios (tanto en su retorno, su nombre, sus excepciones y sus par谩metros). Es necesario crear DTOs que encapsulan los datos tanto de entrada como de salida de la API. Estos DTOs deben estar en el paquete: `co.edu.uniquindio.application.dto`.

Un `DTO` (Data Transfer Object) es un objeto que transporta datos entre procesos. Su objetivo principal es encapsular los datos y enviarlos de un lugar a otro, evitando que se exponga la estructura interna de los objetos de dominio.

### 8. Crear DTOs con records

Cree los DTOs con los atributos correspondientes para cada m茅todo del CRUD. Un DTO es una clase que encapsula la informaci贸n necesaria para cada requisito espec铆fico de la aplicaci贸n, separando la l贸gica de negocio de la estructura de los datos que se intercambian entre el cliente y el servidor.

Dado que los DTO son objetos que no tienen l贸gica y solo sirven para encapsular atributos, podemos hacer uso de los record de Java, entonces, por ejemplo el DTO `CreateUserDTO` se puede crear as铆:

```java
package co.edu.uniquindio.application.dto;

public record CreateUserDTO(
    String name,
    String phone,
    String email,
    String password,
    String photoUrl,
    LocalDate dateBirth,
    Role role
) {
}
```

Para m谩s informaci贸n sobre DTO y los records de Java:
- [Java Record Class y JDK 14](https://www.arquitecturajava.com/java-record-class-y-jdk-14/)
- [Data Transfer Object DTO](https://www.arquitecturajava.com/data-transfer-object-dto-un-concepto-clave/)
- [Patrones Arquitect贸nicos - DTO](https://reactiveprogramming.io/blog/es/patrones-arquitectonicos/dto)

### 9. Agregar validaciones a DTOs

Es necesario realizar validaciones sobre cada uno de los atributos de los DTOs que se utilizan para registrar o actualizar informaci贸n en el backend (por ejemplo, en una base de datos). Con estas validaciones aplicadas, el DTO `CreateUserDTO` quedar铆a de la siguiente manera:

```java
package co.edu.uniquindio.application.dto;

import co.edu.uniquindio.application.model.Role;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import org.hibernate.validator.constraints.Length;
import java.time.LocalDate;

public record CreateUserDTO(
        @NotBlank @Length(max = 100) String name,
        @Length(max = 10) String phone,
        @NotBlank @Length(max = 50) @Email String email,
        @NotBlank @Length(min = 7, max = 20) String password,
        @Length(max = 300) String photoUrl,
        @NotNull LocalDate dateBirth,
        @NotNull Role role
) {
}
```

El DTO debe tener las validaciones pertinentes para garantizar una buena integridad de los datos. Todos los DTO que represente un objeto que ser谩 guardado en la base de datos debe tener las validaciones.

Para m谩s informaci贸n sobre las anotaciones de validaciones:
  - [Documentaci贸n de la API de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/apidocs/jakarta/validation/constraints/package-summary)  
  - [Introducci贸n a la Validaci贸n de Beans en Jakarta EE](https://jakarta.ee/learn/docs/jakartaee-tutorial/current/beanvalidation/bean-validation/bean-validation.html)
  - [Especificaci贸n de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0) 

### 10. Crear EditUserDTO y UserDTO

Cree el DTO `EditUserDTO` con las validaciones pertinentes. Adicionalmente, cree el DTO `UserDTO`, el cual ser谩 utilizado para devolver informaci贸n al cliente. Dado que este 煤ltimo DTO es una respuesta generada por el backend, no requiere validaciones, ya que los datos ya fueron previamente procesados y verificados.

El record `EditUserDTO`, puede estructurarse de la siguiente manera (se asume que el usuario no puede modificar su correo electr贸nico ni su contrase帽a; para cambiar la contrase帽a, deber谩 utilizar otro mecanismo):

```java
package co.edu.uniquindio.application.dto;

import co.edu.uniquindio.application.model.Role;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import org.hibernate.validator.constraints.Length;
import java.time.LocalDate;

public record EditUserDTO(
        @NotBlank @Length(max = 100) String name,
        @Length(max = 10) String phone,
        @Length(max = 300) String photoUrl,
        @NotNull LocalDate dateBirth,
        @NotNull Role role
) {
}
```
El record `UserDTO` puede quedar as铆:

```java
package co.edu.uniquindio.application.dto;

import co.edu.uniquindio.application.model.Role;

public record UserDTO(
        String id,
        String name,
        String email,
        String photoUrl,
        Role role
) {
}
```

> 锔 **IMPORTANTE:** Recuerde que los DTOs son objetos simples que no contienen l贸gica de negocio. Y claramente cada DTO es diferente seg煤n el contexto en el que se utilice.

### 11. Agregar anotaciones HTTP a m茅todos

Como se explic贸 previamente, a cada m茅todo de `UserController` se le debe a帽adir una anotaci贸n de acuerdo al m茅todo HTTP que deba dar respuesta. Para obtener se usa GET, para guardar o registrar se usa POST, para borrar DELETE y para modificar PUT.

```java
@PostMapping
public void create(CreateUserDTO userDTO) throws Exception{
}

@PutMapping
public void edit(EditUserDTO userDTO) throws Exception{
}

@DeleteMapping("/{id}")
public void delete(String id) throws Exception{
}

@GetMapping("/{id}")
public UserDTO get(String id) throws Exception{
    return null;
}

@GetMapping
public List<UserDTO> listAll(){
    return null;
}
```

### 12. Configurar par谩metros de entrada

Algunos m茅todos necesitan informaci贸n que puede venir por la url o en el cuerpo de la petici贸n. Para esos casos se debe indicar expl铆citamente como va a llegar dicha informaci贸n. Si es por la url se debe usar la anotaci贸n `@PathVariable` y si es dentro del cuerpo de la petici贸n se usa `@RequestBody`, para este 煤ltimo caso se recomienda que vaya acompa帽ado de la anotaci贸n `@Valid` (para que tenga en cuenta las anotaciones de validaci贸n de los atributos de los DTO).

Por ejemplo, si deseo obtener la informaci贸n de todo un objeto, lo m谩s obvio ser铆a enviar el c贸digo (`id`) de dicho objeto y con base en ese valor retornar toda la informaci贸n restante. Por lo tanto en la url se puede enviar el c贸digo. Pero, para el registro de un usuario se debe enviar todo el objeto que se quiera guardar, por lo tanto lo ideal es escribir esta informaci贸n en el cuerpo de la petici贸n.

> **NOTA:** Para el caso de `@PathVariable`, el nombre del atributo debe coincidir con el nombre que est谩 entre llaves en la url del mapping. Por ejemplo, si tenemos `@PathVariable int id`, entonces la url ser铆a `"/{id}"`, como se observa en el c贸digo anterior.

Se puede implementar cada uno de los m茅todos del controlador REST haciendo uso de las anotaciones correspondientes y del servicio de negocio de los usuarios, as铆:

```java
@PostMapping
public void create(@Valid @RequestBody CreateUserDTO userDTO) throws Exception{
    
}

@PutMapping("/{id}")
public void edit(@PathVariable String id, @Valid @RequestBody EditUserDTO userDTO) throws Exception{

}

@DeleteMapping("/{id}")
public void delete(@PathVariable String id) throws Exception{
    
}

@GetMapping("/{id}")
public UserDTO get(@PathVariable String id) throws Exception{
    return null;
}

@GetMapping
public List<UserDTO> listAll(){
    return null;
}
```

F铆jese que los m茅todos del controlador no tienen l贸gica de negocio, simplemente se hace el llamado correspondiente a cada m茅todo que est谩 programado en los servicios y se le pasan los mismos par谩metros.

### 13. Implementar ResponseEntity

Como vimos en los m茅todos anteriores, algunos m茅todos son `void`, otros lanzan excepciones que puedan aparecer al momento de realizar alguna operaci贸n de consulta, registro, etc. Lo ideal es retroalimentar al usuario siempre, cuando todo funcione bien informarle y cuando algo falla tambi茅n. Para esto, se puede utilizar el objeto `ResponseEntity`.

Por ejemplo, para la creaci贸n de una nueva cuenta de usuario podemos modificarlo de la siguiente manera para que siempre haya una respuesta:

```java
@PostMapping
public ResponseEntity<ResponseDTO<String>> create(@Valid @RequestBody CreateUserDTO userDTO) throws Exception{
    //L贸gica para crear el usuario
    return ResponseEntity.status(HttpStatus.CREATED).body(new ResponseDTO<>(false, "El registro ha sido exitoso"));
}
```

El objeto `ResponseEntity` nos permite asignar un c贸digo de respuesta (`status`) y un contenido (`body`), para este caso estamos devolviendo un mensaje en formato JSON. El objetivo del DTO `ResponseDTO` es que todas las respuestas del servidor tengan **la misma estructura**.

### 14. Crear ResponseDTO

Cree `ResponseDTO` en el paquete `co.edu.uniquindio.application.dto` as铆:

```java
package co.edu.uniquindio.application.dto;

public record ResponseDTO<T>(
    boolean error,
    T content
) {
}
```

Este record tiene un atributo de tipo `boolean` que indica si hay error o no, y otro atributo de tipo `T` (gen茅rico) que representar谩 la respuesta como tal. Eso implica que el contenido de la respuesta puede tomar el valor que se requiera: un `String`, un objeto, una lista, etc.

### 15. Completar m茅todos con ResponseEntity

En este otro ejemplo, si existe el codigo de la cuenta de usuario retornamos el detalle de la misma, este detalle est谩 en el objeto `UserDTO`:

```java
@GetMapping("/{id}")
public ResponseEntity<ResponseDTO<UserDTO>> get(@PathVariable String id) throws Exception{
    //L贸gica para consular el usuario
    return ResponseEntity.ok(new ResponseDTO<>(false, null));
}
```

Este ser铆a el c贸digo para eliminar la cuenta de un usuario con el ajuste indicado anteriormente:

```java
@DeleteMapping("/{id}")
public ResponseEntity<ResponseDTO<String>> delete(@PathVariable String id) throws Exception{
    //L贸gica para eliminar el usuario
    return ResponseEntity.ok(new ResponseDTO<>(false, "El usuario ha sido eliminado"));
}
```

Este ser铆a el c贸digo para listar todas las cuentas de los usuarios:

```java
@GetMapping
public ResponseEntity<ResponseDTO<List<UserDTO>>> listAll(){
    //L贸gica para consultar todos los usuarios
    List<UserDTO> list = new ArrayList<>();
    return ResponseEntity.ok(new ResponseDTO<>(false, list));
}
```

Y finalmente, este ser铆a el m茅todo de editar la informaci贸n de la cuenta de un usuario:

```java
@PutMapping("/{id}")
public ResponseEntity<ResponseDTO<String>> edit(@PathVariable String id, @Valid @RequestBody EditUserDTO userDTO) throws Exception{
    //L贸gica para editar el usuario
    return ResponseEntity.ok(new ResponseDTO<>(false, "El usuario ha sido actualizado"));
}
```

C贸digos de estado HTTP: [HTTP Status Codes - MDN](https://developer.mozilla.org/es/docs/Web/HTTP/Status)

### 16. Manejo de excepciones

El manejo de las excepciones se debe programar en una nueva clase a la que llamaremos `RestExceptionHandler`. B谩sicamente esta clase mostrar谩 un mensaje de error personalizado al usuario seg煤n el tipo de excepci贸n que arroje el servicio (cualquier servicio).

Dentro del paquete `co.edu.uniquindio.application.exceptions` cree la clase `RestExceptionHandler` con la anotaci贸n `@RestControllerAdvice` as铆:

```java
package co.edu.uniquindio.application.exceptions;

import co.edu.uniquindio.application.dto.ResponseDTO;
import co.edu.uniquindio.application.dto.ValidationDTO;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.servlet.resource.NoResourceFoundException;

import java.util.ArrayList;
import java.util.List;

@RestControllerAdvice
public class RestExceptionHandler {

    @ExceptionHandler(NoResourceFoundException.class)
    public ResponseEntity<ResponseDTO<String>> noResourceFoundExceptionHandler(NoResourceFoundException ex){
        return ResponseEntity.status(404).body( new ResponseDTO<>(true, "El recurso solicitado no existe") );
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ResponseDTO<String>> generalExceptionHandler (Exception e){
        return ResponseEntity.internalServerError().body( new ResponseDTO<>(true, e.getMessage()) );
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ResponseDTO<List<ValidationDTO>>> validationExceptionHandler ( MethodArgumentNotValidException ex ) {
        List<ValidationDTO> errors = new ArrayList<>();
        BindingResult results = ex.getBindingResult();
        for (FieldError e: results.getFieldErrors()) {
            errors.add( new ValidationDTO(e.getField(), e.getDefaultMessage()) );
        }
        return ResponseEntity.badRequest().body( new ResponseDTO<>(true, errors) );
    }
}
```

Cada m茅todo de la clase `RestExceptionHandler` responde a una excepci贸n que puede ser arrojada en cualquier momento por cualquier servicio de negocio. Para diferenciar cada m茅todo se hace uso de la anotaci贸n `@ExceptionHandler`. Ac谩 una breve descripci贸n de cada una:

- **NoResourceFoundException:** Excepci贸n que se lanza cuando se trata de acceder a un recurso que no existe.
- **Exception:** Excepci贸n general de Java. Lo ideal es tener excepciones propias para cada tipo de error y no ponerle a todas las excepciones simplemente Exception.
- **MethodArgumentNotValidException:** Excepci贸n que se lanza cuando no se cumple alguna validaci贸n puesta en los DTO (`@NotNull`, `@Email`, `@Max`, etc..). Para este caso debe crear un nuevo DTO con el nombre: `ValidationDTO`, este record debe debe tener dos `String`: field y message.

### 17. Crear archivo de pruebas para usuarios

Pruebe cada ruta, para esto, cree un nuevo archivo en la carpeta `test/resources` que se llame `users.http` y que tenga lo siguiente:

```bash
### Obtener todos los usuarios
GET http://localhost:8080/api/users

### Obtener un usuario por id (cambie 1 por el id del usuario que desea obtener)
GET http://localhost:8080/api/users/1

### Crear un usuario
POST http://localhost:8080/api/users
Content-Type: application/json

{
  "name": "Carlos",
  "phone": "121212",
  "email": "carlos@email.com",
  "password": "12345678",
  "photoUrl": "",
  "dateBirth": "2000-08-22",
  "role": "USER"
}

### Actualizar un usuario (cambie 1 por el id del usuario que desea actualizar)
PUT http://localhost:8080/api/users/1
Content-Type: application/json

{
  "name": "Carlos",
  "phone": "333333",
  "photoUrl": "mi foto",
  "dateBirth": "2000-08-22",
  "role": "USER"
}

### Eliminar un usuario (cambie 1 por el id del usuario que desea eliminar)
DELETE http://localhost:8080/api/users/1
```

> **锔 Importante:** Al probar cada ruta, aseg煤rese de que el servidor est茅 en ejecuci贸n y de que los datos de prueba est茅n configurados correctamente. A煤n no hay una funcionalidad implementada para manejar los datos.

### 18. Implementar filtros con @RequestParam

Modifique el m茅todo `listAll` de la clase `UserController` para que permita obtener usuarios filtrados por su nombre y por su tel茅fono (ambos opcionales). En este caso, se aconseja hacer algo as铆:

```java
@GetMapping
public ResponseEntity<ResponseDTO<List<UserDTO>>> listAll(
        @RequestParam(required = false) String name,
        @RequestParam(required = false) String phone
) {
    //L贸gica para consultar todos los usuarios con filtros
    List<UserDTO> list = new ArrayList<>();
    return ResponseEntity.ok(new ResponseDTO<>(false, list));
}
```

`@RequestParam` se usa para enviar par谩metros por la url a la petici贸n. En este caso, estas peticiones son v谩lidas:

```bash
### Obtener todos los usuarios que tienen un nombre dado
GET http://localhost:8080/api/users?name=Carlos

### Obtener todos los usuarios cuyo tel茅fono es 1234567
GET http://localhost:8080/api/users?phone=1234567

### Obtener todos los usuarios cuyo tel茅fono es 1234567 y su nombre es Carlos
GET http://localhost:8080/api/users?phone=1234567&name=Carlos
```

> **NOTA:** Se recomienda crear un DTO cuando se requieren m煤ltiples filtros y utilizar `@ModelAttribute` en lugar de `@RequestParam` individuales, esto para mantener un c贸digo m谩s limpio y organizado.

### 19. Crear controlador de alojamientos

Cree una nueva clase y programe un nuevo `@RestController` para manejar la parte de los alojamientos del proyecto final (puede empezar con el CRUD). Consulte las buenas pr谩cticas para crear las rutas y los c贸digos de respuesta. Y haga el respectivo archivo de pruebas (.http).

### 20. Programar todos los RestControllers

Programe los dem谩s `@RestController` para todos requerimientos del proyecto final. Consulte las buenas pr谩cticas para crear las rutas y los c贸digos de respuesta.

### 21. M茅todos de prueba

Para probar los diferentes m茅todos de los controladores podemos hacerlo de muchas maneras, en esta gu铆a creamos archivos de prueba (`.http`) para cada uno de los m茅todos, pero tambi茅n se pueden utilizar herramientas como Postman, Insomnia o Swagger.

---

## Para la pr贸xima clase

- 驴Qu茅 otras herramientas sirven para probar APIs? Investigue c贸mo utilizar Postman o Insomnia para probar las APIs que ha creado.
- Profundice en el concepto de DTO (Data Transfer Object) y su importancia en la comunicaci贸n entre capas de la aplicaci贸n.
- Investigue sobre GraphQL, 驴para qu茅 sirve? 驴Qu茅 ventajas y desventajas tiene frente a REST?

---

## Referencias Bibliogr谩ficas 

1. Fielding, R. T. (2000). *Architectural Styles and the Design of Network-based Software Architectures*. University of California, Irvine.  
2. RFC 7231 - *Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content*. [IETF RFC 7231](https://tools.ietf.org/html/rfc7231).  
3. OpenAPI Initiative. (2023). *OpenAPI Specification*. [OpenAPI Docs](https://www.openapis.org/).  
4. Richardson, L., & Amundsen, M. (2016). *RESTful Web APIs*. O'Reilly Media.  
5. OWASP. (2021). *OWASP Top Ten*. [OWASP Docs](https://owasp.org/www-project-top-ten/).
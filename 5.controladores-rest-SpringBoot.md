<!-- Aqu√≠ cargamos Mermaid.js --> 
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> 
<script> document.addEventListener("DOMContentLoaded", function() { mermaid.initialize({ startOnLoad: true }); }); </script>

```
Programa de Ingenier√≠a de Sistemas y Computaci√≥n
Universidad del Quind√≠o

T√≠tulo: Implementaci√≥n de Servicios REST en Spring Boot
Duraci√≥n estimada: 120
Docentes: Carlos Andr√©s Florez, Christian Andr√©s Candela
Gu√≠a: 05
```
# Controladores REST en Spring Boot

## üéØ Objetivo
Implementar una API REST utilizando **Spring Boot**, basada en un dise√±o previo realizado con **OpenAPI**. Los estudiantes aprender√°n a traducir un dise√±o de API en una implementaci√≥n funcional en Java, aplicando principios de programaci√≥n empresarial y buenas pr√°cticas de desarrollo.

---

## Conceptos B√°sicos
Antes de iniciar con el dise√±o, es importante comprender algunos conceptos fundamentales:

#### 1. REST (Representational State Transfer)
Estilo arquitect√≥nico basado en principios como:
- Separaci√≥n cliente-servidor.
- Uso de recursos identificados por URIs.
- Uso de m√©todos HTTP est√°ndar (GET, POST, PUT, DELETE, PATCH, etc.).
- Implementaci√≥n de respuestas sin estado (**stateless**).
- Cacheabilidad y escalabilidad.

**Referencia:** Fielding, R. T. (2000). *Architectural Styles and the Design of Network-based Software Architectures*. University of California, Irvine.

#### 2. HTTP (Hypertext Transfer Protocol) 
Protocolo de comunicaci√≥n para la transferencia de datos en la web. Define m√©todos est√°ndar como:
- **GET**: Obtener informaci√≥n.
- **POST**: Crear un nuevo recurso.
- **PUT**: Actualizar un recurso existente.
- **PATCH**: Actualizar parcialmente un recurso.
- **DELETE**: Eliminar un recurso.

**Referencia:** RFC 7231 - *Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content*. [IETF RFC 7231](https://tools.ietf.org/html/rfc7231).

#### 3. OpenAPI
Especificaci√≥n abierta para describir APIs RESTful, permitiendo generar documentaci√≥n interactiva, facilitar la integraci√≥n con herramientas de prueba y mejorar la interoperabilidad.

**Referencia:** OpenAPI Initiative. (2023). *OpenAPI Specification*. [OpenAPI Docs](https://www.openapis.org/).

---

## Contextualizaci√≥n Te√≥rica  

### Dise√±o de APIs y Documentaci√≥n con OpenAPI
La documentaci√≥n de APIs es crucial para garantizar que los desarrolladores puedan entender y utilizar los servicios web de manera efectiva. **OpenAPI** permite:  
- Generar documentaci√≥n interactiva (Swagger UI).  
- Facilitar la integraci√≥n con herramientas de prueba como Postman.  
- Mejorar la interoperabilidad entre sistemas heterog√©neos.  

#### Herramientas para Documentaci√≥n y Pruebas de APIs 
- **Swagger UI:** Interfaz interactiva para explorar y probar APIs.  
- **Postman:** Herramienta para realizar pruebas y validar respuestas.  
- **Insomnia:** Alternativa ligera para pruebas de APIs.  

### API REST en Spring Boot
Spring Boot facilita la creaci√≥n de APIs REST mediante la utilizaci√≥n de anotaciones y convenciones que simplifican el desarrollo. Algunas caracter√≠sticas clave incluyen:
- **Controladores REST:** Clases anotadas con `@RestController` que manejan las solicitudes HTTP.
- **Serializaci√≥n/Deserializaci√≥n:** Conversi√≥n autom√°tica entre objetos Java y JSON/XML.
- **Manejo de Errores:** Respuestas de error estandarizadas mediante `@RestControllerAdvice`.

En el siguiente diagrama se muestra una arquitectura simplificada del acceso a la informaci√≥n desde la capa de presentaci√≥n (cliente).

<div class="mermaid" style="text-align: center;">
graph TB
    subgraph "Presentation Layer"
        CA[üì± Client Application<br/>Web/Mobile Interface]
    end
    
    subgraph "API Layer"
        C[üéØ Controller<br/>Request Mapping<br/>Response Handling]
    end
    
    subgraph "Business Layer"
        S[‚öôÔ∏è Service<br/>Business Logic<br/>Data Processing]
    end
    
    subgraph "Data Access Layer"
        R[üóÉÔ∏è Repository<br/>Database Interactions<br/>Query Management]
        M[üìã Model/Entity<br/>Data Access Objects<br/>Domain Objects]
    end
    
    subgraph "Storage Layer"
        DB[(üóÑÔ∏è Database<br/>Persistent Storage)]
    end
    
    %% Connections with labeled arrows
    CA <==> |HTTP/REST APIs<br/>JSON Requests| C
    C <==> |Method Calls<br/>DTOs| S
    S <==> |Repository Pattern<br/>Business Entities| R
    R <==> |ORM/SQL<br/>Entity Mapping| M
    M <==> |Database Queries<br/>CRUD Operations| DB
    
    %% Styling
    classDef clientLayer fill:#FF6B6B,stroke:#E55555,stroke-width:2px,color:#fff
    classDef apiLayer fill:#4ECDC4,stroke:#45B7B8,stroke-width:2px,color:#fff
    classDef businessLayer fill:#45B7D1,stroke:#3498DB,stroke-width:2px,color:#fff
    classDef dataLayer fill:#96CEB4,stroke:#74B9FF,stroke-width:2px,color:#fff
    classDef storageLayer fill:#FFEAA7,stroke:#FDCB6E,stroke-width:2px,color:#2d3436
    
    class CA clientLayer
    class C apiLayer
    class S businessLayer
    class R,M dataLayer
    class DB storageLayer
</div>

El proceso de petici√≥n desde el cliente a los servicios de Spring Boot sigue el modelo de arquitectura Cliente-Servidor y se basa en el protocolo HTTP (o HTTPS). Aqu√≠ hay un resumen general del proceso:

- Un cliente (como un navegador web o una aplicaci√≥n m√≥vil) inicia una solicitud enviando una petici√≥n HTTP al servidor Spring Boot.

- En el servidor Spring Boot, las peticiones son manejadas por controladores. Los controladores est√°n anotados con `@Controller`, `@RestController` u otras anotaciones espec√≠ficas de Spring.

- El controlador realiza las operaciones necesarias en funci√≥n de la l√≥gica de negocio. Puede interactuar con servicios, acceder a bases de datos, realizar operaciones y preparar datos para enviar como respuesta.

- Generaci√≥n de la respuesta: Una vez que el controlador ha completado su l√≥gica, genera una respuesta. La respuesta generada por el controlador se env√≠a de vuelta al cliente a trav√©s del protocolo HTTP.

- El cliente (por ejemplo, un navegador web o una aplicaci√≥n m√≥vil) recibe la respuesta y realiza acciones seg√∫n la l√≥gica de la aplicaci√≥n.


**Referencias:**

  - [Documentaci√≥n de Spring Boot sobre REST](https://spring.io/guides/gs/rest-service)
  - [Documentaci√≥n de la API de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/apidocs/jakarta/validation/constraints/package-summary)  
  - [Introducci√≥n a la Validaci√≥n de Beans en Jakarta EE](https://jakarta.ee/learn/docs/jakartaee-tutorial/current/beanvalidation/bean-validation/bean-validation.html)
  - [Especificaci√≥n de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0)  

---

## Procedimiento

### 1. Configuraci√≥n inicial

Aseg√∫rese que tiene las siguientes dependencias a√±adidas en el archivo `build.gradle` del proyecto de Spring Boot:

```groovy
implementation 'org.springframework.boot:spring-boot-starter-web'
implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.9'
```

### 2. Crear un controlador simple

Cree una clase que se llame `GreetingController`. Para esto primero cree un paquete que se llame `co.edu.uniquindio.application.controllers`. A esta clase a√±√°dale la anotaci√≥n `@RestController`. Y haga que quede as√≠:

```java
package co.edu.uniquindio.application.controllers;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/greeting") // Prefijo com√∫n para todas las rutas del controlador
public class GreetingController {

    @GetMapping
    public String greet(){
        return "Hola, bienvenido a la aplicaci√≥n";
    }

    @GetMapping("/{name}")
    public String greetName(@PathVariable String name){
        return "Hola %s, bienvenido a la aplicaci√≥n".formatted(name);
    }
}
```

Con base en el c√≥digo anterior, podemos destacar lo siguiente:

- `@RestController`: Indica que esta clase es un controlador REST, lo que significa que manejar√° solicitudes HTTP y devolver√° respuestas en formato de texto o JSON.
- `@RequestMapping("/greeting")` para que todas las rutas comiencen con `/greeting`. Esto permite que las rutas queden m√°s organizadas y evitamos posibles conflictos con otras rutas en la aplicaci√≥n.
- `@GetMapping`: Especifica que los m√©todos dentro del controlador responder√°n a solicitudes **HTTP GET**.

El primer m√©todo se "activa" cuando un cliente hace una solicitud GET a la ra√≠z del controlador (`/greeting`). Por ejemplo: `http://localhost:8080/greeting` Devuelve el mensaje: "Hola, bienvenido a la aplicaci√≥n".

El segundo m√©todo se "activa" cuando un cliente hace una solicitud GET a la ra√≠z del controlador (`/greeting`), con un par√°metro en la URL. Por ejemplo: `http://localhost:8080/greeting/Carlos` Devuelve el mensaje "Hola Carlos, bienvenido a la aplicaci√≥n".

> **‚ö†Ô∏è NOTA:** El puerto por defecto es el 8080, pero puede variar seg√∫n la configuraci√≥n del proyecto en el archivo `application.properties`.

### 3. Crear archivo de pruebas HTTP

Para probar estas peticiones se recomienda crear un archivo en la carpeta `test/resources` que se llame por ejemplo `greeting.http` y puede quedar as√≠:

```bash
### Saludo
GET http://localhost:8080/greeting

### Saludo con un nombre dado como par√°metro
GET http://localhost:8080/greeting/Carlos
```

### 4. Probar las rutas

Pruebe cada ruta (para esto el servidor debe estar en ejecuci√≥n). Tambi√©n puede acceder a las rutas desde su navegador web.

### 5. Crear UserController

Cree una nueva clase que se llame `UserController`. En el paquete `co.edu.uniquindio.application.controllers`. A esta clase a√±√°dale la anotaci√≥n `@RestController`. As√≠:

```java
package co.edu.uniquindio.application.controllers;

import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {

}
```

### 6. Configurar endpoint

Adicione a dicha clase la url (endpoint) que reconocer√° el controlador para dar respuesta a las peticiones HTTP. Agregue lo siguiente debajo de `@RestController`:

```java
@RequestMapping("/api/users")
```

Esto significa que cuando se pida la url `http://localhost:8080/api/users` ser√° el controlador REST que estamos programando quien responda ante las peticiones realizadas.

### 7. Crear m√©todos CRUD

Cree un m√©todo para cada servicio de negocio de los usuarios que sea pertinente para la API. A manera de ejemplo se har√° el controlador implementando solamente los m√©todos para hacer un CRUD b√°sico en la entidad. Estos m√©todos se deben crear en la clase `UserController`:

```java
public void create(CreateUserDTO userDTO) throws Exception{
}

public void edit(EditUserDTO userDTO) throws Exception{
}

public void delete(String id) throws Exception{
}

public UserDTO get(String id) throws Exception{
}

public List<UserDTO> listAll(){
}
```

> **‚ö†Ô∏è NOTA:** Cada m√©todo del controlador debe ser equivalente a los m√©todos del servicio de los usuarios (tanto en su retorno, su nombre, sus excepciones y sus par√°metros). Es necesario crear DTOs que encapsulan los datos tanto de entrada como de salida de la API. Estos DTOs deben estar en el paquete: `co.edu.uniquindio.application.dto`.

Un `DTO` (Data Transfer Object) es un objeto que transporta datos entre procesos. Su objetivo principal es encapsular los datos y enviarlos de un lugar a otro, evitando que se exponga la estructura interna de los objetos de dominio.

### 8. Crear DTOs con records

Cree los DTOs con los atributos correspondientes para cada m√©todo del CRUD. Un DTO es una clase que encapsula la informaci√≥n necesaria para cada requisito espec√≠fico de la aplicaci√≥n, separando la l√≥gica de negocio de la estructura de los datos que se intercambian entre el cliente y el servidor.

Dado que los DTO son objetos que no tienen l√≥gica y solo sirven para encapsular atributos, podemos hacer uso de los record de Java, entonces, por ejemplo el DTO `CreateUserDTO` se puede crear as√≠:

```java
package co.edu.uniquindio.application.dto;

public record CreateUserDTO(
    String name,
    String phone,
    String email,
    String password,
    String photoUrl,
    LocalDate dateBirth,
    Role role
) {
}
```

Para m√°s informaci√≥n sobre DTO y los records de Java:
- [Java Record Class y JDK 14](https://www.arquitecturajava.com/java-record-class-y-jdk-14/)
- [Data Transfer Object DTO](https://www.arquitecturajava.com/data-transfer-object-dto-un-concepto-clave/)
- [Patrones Arquitect√≥nicos - DTO](https://reactiveprogramming.io/blog/es/patrones-arquitectonicos/dto)

### 9. Agregar validaciones a DTOs

Es necesario realizar validaciones sobre cada uno de los atributos de los DTOs que se utilizan para registrar o actualizar informaci√≥n en el backend (por ejemplo, en una base de datos). Con estas validaciones aplicadas, el DTO `CreateUserDTO` quedar√≠a de la siguiente manera:

```java
package co.edu.uniquindio.application.dto;

import co.edu.uniquindio.application.model.Role;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Past;
import org.hibernate.validator.constraints.Length;
import java.time.LocalDate;

public record CreateUserDTO(
        @NotBlank @Length(max = 100) String name,
        @Length(max = 10) String phone,
        @NotBlank @Length(max = 50) @Email String email,
        @NotBlank @Length(min = 7, max = 20) String password,
        @Length(max = 300) String photoUrl,
        @NotNull @Past LocalDate dateBirth,
        @NotNull Role role
) {
}
```

El DTO debe tener las validaciones pertinentes para garantizar una buena integridad de los datos. Todos los DTO que represente un objeto que ser√° guardado en la base de datos debe tener las validaciones.

Para m√°s informaci√≥n sobre las anotaciones de validaciones:
  - [Documentaci√≥n de la API de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/apidocs/jakarta/validation/constraints/package-summary)  
  - [Introducci√≥n a la Validaci√≥n de Beans en Jakarta EE](https://jakarta.ee/learn/docs/jakartaee-tutorial/current/beanvalidation/bean-validation/bean-validation.html)
  - [Especificaci√≥n de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0) 

### 10. Crear EditUserDTO y UserDTO

Cree el DTO `EditUserDTO` con las validaciones pertinentes. Adicionalmente, cree el DTO `UserDTO`, el cual ser√° utilizado para devolver informaci√≥n al cliente. Dado que este √∫ltimo DTO es una respuesta generada por el backend, no requiere validaciones, ya que los datos ya fueron previamente procesados y verificados.

El record `EditUserDTO`, puede estructurarse de la siguiente manera (se asume que el usuario no puede modificar su correo electr√≥nico ni su contrase√±a; para cambiar la contrase√±a, deber√° utilizar otro mecanismo):

```java
package co.edu.uniquindio.application.dto;

import co.edu.uniquindio.application.model.Role;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Past;
import org.hibernate.validator.constraints.Length;
import java.time.LocalDate;

public record EditUserDTO(
        @NotBlank @Length(max = 100) String name,
        @Length(max = 10) String phone,
        @Length(max = 300) String photoUrl,
        @NotNull @Past LocalDate dateBirth,
        @NotNull Role role
) {
}
```
El record `UserDTO` puede quedar as√≠:

```java
package co.edu.uniquindio.application.dto;

import co.edu.uniquindio.application.model.Role;

public record UserDTO(
        String id,
        String name,
        String email,
        String photoUrl,
        Role role
) {
}
```

> ‚ö†Ô∏è **IMPORTANTE:** Recuerde que los DTOs son objetos simples que no contienen l√≥gica de negocio. Y claramente cada DTO es diferente seg√∫n el contexto en el que se utilice.

### 11. Agregar anotaciones HTTP a m√©todos

Como se explic√≥ previamente, a cada m√©todo de `UserController` se le debe a√±adir una anotaci√≥n de acuerdo al m√©todo HTTP que deba dar respuesta. Para obtener se usa GET, para guardar o registrar se usa POST, para borrar DELETE y para modificar PUT.

```java
@PostMapping
public void create(CreateUserDTO userDTO) throws Exception{
}

@PutMapping
public void edit(EditUserDTO userDTO) throws Exception{
}

@DeleteMapping("/{id}")
public void delete(String id) throws Exception{
}

@GetMapping("/{id}")
public UserDTO get(String id) throws Exception{
    return null;
}

@GetMapping
public List<UserDTO> listAll(){
    return null;
}
```

### 12. Configurar par√°metros de entrada

Algunos m√©todos necesitan informaci√≥n que puede venir por la url o en el cuerpo de la petici√≥n. Para esos casos se debe indicar expl√≠citamente como va a llegar dicha informaci√≥n. Si es por la url se debe usar la anotaci√≥n `@PathVariable` y si es dentro del cuerpo de la petici√≥n se usa `@RequestBody`, para este √∫ltimo caso se recomienda que vaya acompa√±ado de la anotaci√≥n `@Valid` (para que tenga en cuenta las anotaciones de validaci√≥n de los atributos de los DTO).

Por ejemplo, si deseo obtener la informaci√≥n de todo un objeto, lo m√°s obvio ser√≠a enviar el c√≥digo (`id`) de dicho objeto y con base en ese valor retornar toda la informaci√≥n restante. Por lo tanto en la url se puede enviar el c√≥digo. Pero, para el registro de un usuario se debe enviar todo el objeto que se quiera guardar, por lo tanto lo ideal es escribir esta informaci√≥n en el cuerpo de la petici√≥n.

> **NOTA:** Para el caso de `@PathVariable`, el nombre del atributo debe coincidir con el nombre que est√° entre llaves en la url del mapping. Por ejemplo, si tenemos `@PathVariable int id`, entonces la url ser√≠a `"/{id}"`, como se observa en el c√≥digo anterior.

Se puede implementar cada uno de los m√©todos del controlador REST haciendo uso de las anotaciones correspondientes y del servicio de negocio de los usuarios, as√≠:

```java
@PostMapping
public void create(@Valid @RequestBody CreateUserDTO userDTO) throws Exception{
    
}

@PutMapping("/{id}")
public void edit(@PathVariable String id, @Valid @RequestBody EditUserDTO userDTO) throws Exception{

}

@DeleteMapping("/{id}")
public void delete(@PathVariable String id) throws Exception{
    
}

@GetMapping("/{id}")
public UserDTO get(@PathVariable String id) throws Exception{
    return null;
}

@GetMapping
public List<UserDTO> listAll(){
    return null;
}
```

F√≠jese que los m√©todos del controlador no tienen l√≥gica de negocio, simplemente se hace el llamado correspondiente a cada m√©todo que est√° programado en los servicios y se le pasan los mismos par√°metros.

### 13. Implementar `ResponseEntity`

Como vimos en los m√©todos anteriores, algunos m√©todos son `void`, otros lanzan excepciones que puedan aparecer al momento de realizar alguna operaci√≥n de consulta, registro, etc. Lo ideal es retroalimentar al usuario siempre, cuando todo funcione bien informarle y cuando algo falla tambi√©n. Para esto, se puede utilizar el objeto `ResponseEntity`.

Por ejemplo, para la creaci√≥n de una nueva cuenta de usuario podemos modificarlo de la siguiente manera para que siempre haya una respuesta:

```java
@PostMapping
public ResponseEntity<ResponseDTO<String>> create(@Valid @RequestBody CreateUserDTO userDTO) throws Exception{
    //L√≥gica para crear el usuario
    return ResponseEntity.status(HttpStatus.CREATED).body(new ResponseDTO<>(false, "El registro ha sido exitoso"));
}
```

El objeto `ResponseEntity` nos permite asignar un c√≥digo de respuesta (`status`) y un contenido (`body`), para este caso estamos devolviendo un mensaje en formato JSON. El objetivo del DTO `ResponseDTO` es que todas las respuestas del servidor tengan **la misma estructura**.

### 14. Crear ResponseDTO

Cree `ResponseDTO` en el paquete `co.edu.uniquindio.application.dto` as√≠:

```java
package co.edu.uniquindio.application.dto;

public record ResponseDTO<T>(
    boolean error,
    T content
) {
}
```

Este record tiene un atributo de tipo `boolean` que indica si hay error o no, y otro atributo de tipo `T` (gen√©rico) que representar√° la respuesta como tal. Eso implica que el contenido de la respuesta puede tomar el valor que se requiera: un `String`, un objeto, una lista, etc.

### 15. Completar m√©todos con ResponseEntity

En este otro ejemplo, si existe el codigo de la cuenta de usuario retornamos el detalle de la misma, este detalle est√° en el objeto `UserDTO`:

```java
@GetMapping("/{id}")
public ResponseEntity<ResponseDTO<UserDTO>> get(@PathVariable String id) throws Exception{
    //L√≥gica para consular el usuario
    return ResponseEntity.ok(new ResponseDTO<>(false, null));
}
```

Este ser√≠a el c√≥digo para eliminar la cuenta de un usuario con el ajuste indicado anteriormente:

```java
@DeleteMapping("/{id}")
public ResponseEntity<ResponseDTO<String>> delete(@PathVariable String id) throws Exception{
    //L√≥gica para eliminar el usuario
    return ResponseEntity.ok(new ResponseDTO<>(false, "El usuario ha sido eliminado"));
}
```

Este ser√≠a el c√≥digo para listar todas las cuentas de los usuarios:

```java
@GetMapping
public ResponseEntity<ResponseDTO<List<UserDTO>>> listAll(){
    //L√≥gica para consultar todos los usuarios
    List<UserDTO> list = new ArrayList<>();
    return ResponseEntity.ok(new ResponseDTO<>(false, list));
}
```

Y finalmente, este ser√≠a el m√©todo de editar la informaci√≥n de la cuenta de un usuario:

```java
@PutMapping("/{id}")
public ResponseEntity<ResponseDTO<String>> edit(@PathVariable String id, @Valid @RequestBody EditUserDTO userDTO) throws Exception{
    //L√≥gica para editar el usuario
    return ResponseEntity.ok(new ResponseDTO<>(false, "El usuario ha sido actualizado"));
}
```

C√≥digos de estado HTTP: [HTTP Status Codes - MDN](https://developer.mozilla.org/es/docs/Web/HTTP/Status)

### 16. Manejo de excepciones

El manejo de las excepciones se debe programar en una nueva clase a la que llamaremos `RestExceptionHandler`. B√°sicamente esta clase mostrar√° un mensaje de error personalizado al usuario seg√∫n el tipo de excepci√≥n que arroje el servicio (cualquier servicio).

Dentro del paquete `co.edu.uniquindio.application.exceptions` cree la clase `RestExceptionHandler` con la anotaci√≥n `@RestControllerAdvice` as√≠:

```java
package co.edu.uniquindio.application.exceptions;

import co.edu.uniquindio.application.dto.ResponseDTO;
import co.edu.uniquindio.application.dto.ValidationDTO;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.servlet.resource.NoResourceFoundException;

import java.util.ArrayList;
import java.util.List;

@RestControllerAdvice
public class RestExceptionHandler {

    @ExceptionHandler(NoResourceFoundException.class)
    public ResponseEntity<ResponseDTO<String>> noResourceFoundExceptionHandler(NoResourceFoundException ex){
        return ResponseEntity.status(404).body( new ResponseDTO<>(true, "El recurso solicitado no existe") );
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ResponseDTO<String>> generalExceptionHandler (Exception e){
        return ResponseEntity.internalServerError().body( new ResponseDTO<>(true, e.getMessage()) );
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ResponseDTO<List<ValidationDTO>>> validationExceptionHandler ( MethodArgumentNotValidException ex ) {
        List<ValidationDTO> errors = new ArrayList<>();
        BindingResult results = ex.getBindingResult();
        for (FieldError e: results.getFieldErrors()) {
            errors.add( new ValidationDTO(e.getField(), e.getDefaultMessage()) );
        }
        return ResponseEntity.badRequest().body( new ResponseDTO<>(true, errors) );
    }
}
```

Cada m√©todo de la clase `RestExceptionHandler` responde a una excepci√≥n que puede ser arrojada en cualquier momento por cualquier servicio de negocio. Para diferenciar cada m√©todo se hace uso de la anotaci√≥n `@ExceptionHandler`. Ac√° una breve descripci√≥n de cada una:

- **`NoResourceFoundException`:** Excepci√≥n que se lanza cuando se trata de acceder a un recurso que no existe.
- **`Exception`:** Excepci√≥n general de Java. Lo ideal es tener excepciones propias para cada tipo de error y no ponerle a todas las excepciones simplemente `Exception`.
- **`MethodArgumentNotValidException`:** Excepci√≥n que se lanza cuando no se cumple alguna validaci√≥n puesta en los DTO (`@NotNull`, `@Email`, `@Max`, etc..). Para este caso debe crear un nuevo DTO con el nombre: `ValidationDTO`, este record debe debe tener dos `String`: field y message.

### 17. Crear archivo de pruebas para usuarios

Pruebe cada ruta, para esto, cree un nuevo archivo en la carpeta `test/resources` que se llame `users.http` y que tenga lo siguiente:

```bash
### Obtener todos los usuarios
GET http://localhost:8080/api/users

### Obtener un usuario por id (cambie 1 por el id del usuario que desea obtener)
GET http://localhost:8080/api/users/1

### Crear un usuario
POST http://localhost:8080/api/users
Content-Type: application/json

{
  "name": "Carlos",
  "phone": "121212",
  "email": "carlos@email.com",
  "password": "12345678",
  "photoUrl": "",
  "dateBirth": "2000-08-22",
  "role": "USER"
}

### Actualizar un usuario (cambie 1 por el id del usuario que desea actualizar)
PUT http://localhost:8080/api/users/1
Content-Type: application/json

{
  "name": "Carlos",
  "phone": "333333",
  "photoUrl": "mi foto",
  "dateBirth": "2000-08-22",
  "role": "USER"
}

### Eliminar un usuario (cambie 1 por el id del usuario que desea eliminar)
DELETE http://localhost:8080/api/users/1
```

> **‚ö†Ô∏è Importante:** Al probar cada ruta, aseg√∫rese de que el servidor est√© en ejecuci√≥n y de que los datos de prueba est√©n configurados correctamente. A√∫n no hay una funcionalidad implementada para manejar los datos.

### 18. Implementar filtros con @RequestParam

Modifique el m√©todo `listAll` de la clase `UserController` para que permita obtener usuarios filtrados por su nombre y por su tel√©fono (ambos opcionales). En este caso, se aconseja hacer algo as√≠:

```java
@GetMapping
public ResponseEntity<ResponseDTO<List<UserDTO>>> listAll(
        @RequestParam(required = false) String name,
        @RequestParam(required = false) String phone
) {
    //L√≥gica para consultar todos los usuarios con filtros
    List<UserDTO> list = new ArrayList<>();
    return ResponseEntity.ok(new ResponseDTO<>(false, list));
}
```

`@RequestParam` se usa para enviar par√°metros por la url a la petici√≥n. En este caso, estas peticiones son v√°lidas:

```bash
### Obtener todos los usuarios que tienen un nombre dado
GET http://localhost:8080/api/users?name=Carlos

### Obtener todos los usuarios cuyo tel√©fono es 1234567
GET http://localhost:8080/api/users?phone=1234567

### Obtener todos los usuarios cuyo tel√©fono es 1234567 y su nombre es Carlos
GET http://localhost:8080/api/users?phone=1234567&name=Carlos
```

> **NOTA:** Se recomienda crear un DTO cuando se requieren m√∫ltiples filtros y utilizar `@ModelAttribute` en lugar de `@RequestParam` individuales, esto para mantener un c√≥digo m√°s limpio y organizado.

### 19. Crear controlador de alojamientos

Cree una nueva clase y programe un nuevo `@RestController` para manejar la parte de los alojamientos del proyecto final (puede empezar con el CRUD). Consulte las buenas pr√°cticas para crear las rutas y los c√≥digos de respuesta. Y haga el respectivo archivo de pruebas (.http).

### 20. Programar todos los RestControllers

Programe los dem√°s `@RestController` para todos requerimientos del proyecto final. Consulte las buenas pr√°cticas para crear las rutas y los c√≥digos de respuesta.

### 21. M√©todos de prueba

Para probar los diferentes m√©todos de los controladores podemos hacerlo de muchas maneras, en esta gu√≠a creamos archivos de prueba (`.http`) para cada uno de los m√©todos, pero tambi√©n se pueden utilizar herramientas como Postman, Insomnia o Swagger.

---

## Para la pr√≥xima clase

- ¬øQu√© otras herramientas sirven para probar APIs? Investigue c√≥mo utilizar Postman o Insomnia para probar las APIs que ha creado.
- Profundice en el concepto de DTO (Data Transfer Object) y su importancia en la comunicaci√≥n entre capas de la aplicaci√≥n.
- Investigue sobre GraphQL, ¬øpara qu√© sirve? ¬øQu√© ventajas y desventajas tiene frente a REST?

---

## Referencias Bibliogr√°ficas 

1. Fielding, R. T. (2000). *Architectural Styles and the Design of Network-based Software Architectures*. University of California, Irvine.  
2. RFC 7231 - *Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content*. [IETF RFC 7231](https://tools.ietf.org/html/rfc7231).  
3. OpenAPI Initiative. (2023). *OpenAPI Specification*. [OpenAPI Docs](https://www.openapis.org/).  
4. Richardson, L., & Amundsen, M. (2016). *RESTful Web APIs*. O'Reilly Media.  
5. OWASP. (2021). *OWASP Top Ten*. [OWASP Docs](https://owasp.org/www-project-top-ten/).
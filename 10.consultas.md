```
Programa de Ingenier칤a de Sistemas y Computaci칩n
Universidad del Quind칤o

T칤tulo: Consultas en Spring Data JPA
Duraci칩n estimada: 120
Docentes: Carlos Andr칠s Florez, Christian Andr칠s Candela
Gu칤a: 10
```

# Consultas en Spring Data JPA

## 游꿢 Objetivo
Aprender a crear consultas b치sicas a una base de datos relacional por medio de Spring Data JPA.

---

## Conceptos b치sicos

- **Bases de Datos SQL**: MariaDB como ejemplo principal.
- **Java**: Lenguaje de programaci칩n orientado a objetos.
- **Spring Data JPA**: M칩dulo de Spring para interactuar con bases de datos SQL.

---

## Contextualizaci칩n Te칩rica

Spring Data JPA es un proyecto del ecosistema Spring que proporciona una abstracci칩n de alto nivel para la interacci칩n con la base de datos relacionales en aplicaciones Java basadas en Spring. Su objetivo principal es simplificar el acceso a datos y reducir la cantidad de c칩digo necesario para realizar operaciones comunes de base de datos.

### Caracter칤sticas clave de Spring Data JPA

- **Abstracci칩n de Repositorios:** Proporciona un conjunto de interfaces de repositorio que permiten realizar operaciones comunes de CRUD (Crear, Leer, Actualizar, Borrar) sin tener que escribir consultas espec칤ficas de SQL. Esto se logra mediante la inferencia de consultas basada en convenciones de nombres de m칠todos.

- **Mapeo de Objetos a Tablas Relacionales:** Simplifica el mapeo de objetos Java a tablas en bases de datos relacionales. Se pueden anotar las clases de entidad con anotaciones de Spring Data y JPA, y el mapeo entre las propiedades de los objetos y las columnas de las tablas se realiza autom치ticamente.

- **Soporte para Consultas Derivadas:** La inferencia de consultas permite construir consultas de SQL a partir de los nombres de los m칠todos en las interfaces de repositorio. Por ejemplo, al definir un m칠todo llamado `findByNombre(String nombre)`, Spring Data JPA generar치 autom치ticamente una consulta para buscar registros donde el campo "nombre" coincida.

- **Soporte para Transacciones:** Spring Data JPA se integra con el soporte de transacciones de Spring, lo que facilita la gesti칩n de transacciones en las operaciones de base de datos.

Cuando se utiliza Spring Boot en combinaci칩n con Spring Data JPA y una base de datos relacional como MariaDB, se puede aprovechar la configuraci칩n autom치tica y las convenciones de Spring Boot para simplificar a칰n m치s el desarrollo de aplicaciones que interact칰an con bases de datos.

### 1. Consultas por medio de la inferencias

La inferencia de queries en Spring Data JPA se refiere a la capacidad que tiene para generar consultas autom치ticamente a partir de los nombres de los m칠todos en los repositorios. Utiliza convenciones de nomenclatura para analizar los nombres de los m칠todos y construir consultas SQL correspondientes.

**Por ejemplo**, si tenemos un m칠todo en un repositorio llamado `findByEmail(String email)`, Spring Data JPA inferir치 la consulta para buscar registros que tengan el campo "email" coincidente.

Esto proporciona una forma m치s concisa de definir consultas sin tener que escribir consultas SQL completas manualmente. La inferencia de queries simplifica el desarrollo al generar din치micamente las consultas seg칰n la firma del m칠todo en el repositorio.

#### Algunos ejemplos:

A continuaci칩n, se presentan algunos ejemplos de c칩mo se pueden definir m칠todos en un repositorio para que Spring Data JPA infiera las consultas correspondientes:

**Consulta por igualdad**
```java
List<User> findByName(String name);
```
Spring Data generar치 una consulta tipo: `SELECT * FROM user WHERE name = ?`

**Consulta con operadores**

```java
List<User> findByAgeGreaterThan(int age);
```

Generar치 una consulta para encontrar usuarios cuya edad sea mayor que el valor proporcionado. Tambi칠n est치n disponibles:
- `findByAgeGreaterThanEqual` para mayor o igual
- `findByAgeLessThan` para menor que

**Consulta con m칰ltiples condiciones**

```java
List<User> findByNameAndAge(String name, int age);
```
Crear치 una consulta para encontrar usuarios con un nombre espec칤fico y una edad dada. Tambi칠n est치n disponibles los operadores `Or` y `Not`.

**Consulta por palabras clave (contenencia)**

```java
List<User> findByNameIsLike(String partOfName);
```

Generar치 una consulta para encontrar usuarios cuyos nombres contengan la parte especificada.

**Ordenamiento**

```java
List<User> findByAgeGreaterThanOrderByNameAsc(int age);
```
Encontrar치 usuarios mayores que la edad proporcionada y los ordenar치 alfab칠ticamente por nombre ascendente.

**Agrupaci칩n y Conteo**

```java
long countByAge(int age);
```
Contar치 el n칰mero de usuarios con la edad dada.

**Paginaci칩n de resultados**

Para paginar resultados, se pueden utilizar los m칠todos `findBy` junto con `Pageable` en los repositorios. Por ejemplo:

```java
Page<User> findByAge(int age, Pageable pageable);
```

Esto permitir치 obtener una p치gina de resultados que cumplan con la condici칩n de edad, facilitando la implementaci칩n de paginaci칩n en la aplicaci칩n. Cuando se utiliza `Pageable`, el resultado se envuelve en un objeto `Page`, que proporciona informaci칩n adicional sobre la paginaci칩n, como el n칰mero total de p치ginas y el n칰mero total de elementos. Por ejemplo:

```java
Pageable pageable = PageRequest.of(0, 10); // P치gina 0 con 10 elementos por p치gina
Page<User> usersPage = userRepository.findByAge(25, pageable);
List<User> users = usersPage.getContent(); // Obtener la lista de usuarios en la p치gina
int totalPages = usersPage.getTotalPages(); // Obtener el n칰mero total de p치ginas
long totalElements = usersPage.getTotalElements(); // Obtener el n칰mero total de elementos
```

**Ordenamiento de resultados**

Para ordenar los resultados, se puede utilizar el par치metro `Sort` en los m칠todos de consulta. Por ejemplo:

```java
List<User> findByAge(int age, Sort sort);
```

Esto permitir치 ordenar los resultados seg칰n los criterios especificados en el objeto `Sort`. Cuando se utiliza `Sort`, se puede definir el ordenamiento por uno o m치s campos, ya sea en orden ascendente o descendente, por ejemplo:

```java
Sort sort = Sort.by(Sort.Direction.ASC, "name"); // Ordenar por nombre en orden ascendente
List<User> users = userRepository.findByAge(25, sort);
```

**Combinando paginaci칩n y ordenamiento**

Si se necesita usar tanto paginaci칩n como ordenamiento, se puede combinar `Pageable` y `Sort` de la siguiente manera:

```java
Pageable pageable = PageRequest.of(0, 10, Sort.by(Sort.Direction.DESC, "name")); // P치gina 0 con 10 elementos por p치gina, ordenados por nombre
Page<User> usersPage = userRepository.findByAge(25, pageable);
List<User> users = usersPage.getContent(); // Obtener la lista de usuarios en la p치gina
```

#### Palabras clave comunes

Hay varias palabras clave disponibles: `findBy`, `count`, `GreaterThan`, `LessThan`, `OrderBy`, `And`, `Or`. Para conocer todas las palabras claves 칰tiles se recomienda consultar la [documentaci칩n oficial](https://docs.spring.io/spring-data/jpa/reference/repositories/query-keywords-reference.html).

#### Puntos importantes para la inferencia de queries

Para que la inferencia funcione correctamente, se debe tener en cuenta:

- **Convenciones de nomenclatura:** Seguir las convenciones al definir los m칠todos en los repositorios. Utilizar nombres significativos que reflejen la operaci칩n.

- **Tipos de retorno:** Utilizar tipos de retorno apropiados en los m칠todos de repositorio. Se puede devolver Listas, Streams, DTO, u otros tipos seg칰n las necesidades.

- **Campos de entidad:** Asegurar que los nombres de los campos en las entidades coincidan con los utilizados en los m칠todos de repositorio.

- **Manejo de excepciones:** Implementar manejo de excepciones adecuado para casos donde las consultas no puedan ser inferidas correctamente.

### 2. Consultas personalizadas con `@Query`

En Spring Data JPA, la anotaci칩n `@Query` se utiliza para definir consultas personalizadas en m칠todos de repositorio. A diferencia de la inferencia de consultas basada en convenciones de nombres, `@Query` permite escribir consultas JPQL o SQL nativas seg칰n las necesidades.

#### Algunos ejemplos

A continuaci칩n, se presentan algunos ejemplos de c칩mo utilizar la anotaci칩n `@Query` para definir consultas personalizadas en un repositorio:

**Consulta b치sica**

Supongamos que tenemos una entidad llamada `User` con un campo `name`:

```java
@Query("SELECT u FROM User u WHERE u.name = :name")
List<User> getListUsers(String name);
```

Este es un ejemplo de una consulta JPQL que selecciona usuarios por nombre. Aunque aparece similar a SQL, JPQL opera sobre entidades y sus propiedades en lugar de tablas y columnas, por lo tanto es independiente del motor de base de datos. 

Dado que `User` es una entidad, `u` es un alias para la entidad y `u.name` se refiere a la propiedad `name` de la entidad.


**Consulta con m칰ltiples condiciones**

```java
@Query("SELECT u FROM User u WHERE u.name = :name AND u.age = :age")
List<User> findByNameAndAge(String name, int age);
```

**Consulta con join**

En ciertas situaciones, es posible que necesitemos realizar consultas que involucren m칰ltiples entidades relacionadas. Por ejemplo, si tenemos una entidad `Order` relacionada con `User`, podemos hacer un join:

```java
@Query("SELECT o FROM Order o JOIN o.user u WHERE u.id = :userId")
List<Order> findOrdersByUserId(Long userId);
```

En este caso, la entidad `Order` tiene una relaci칩n con la entidad `User`, y estamos buscando 칩rdenes asociadas a un usuario espec칤fico. Incluso, si la relaci칩n es bidireccional, se puede hacer el join desde cualquiera de las dos entidades, por ejemplo:

```java
@Query("SELECT o FROM User u JOIN u.orders o WHERE u.id = :userId")
List<Order> findOrdersByUserId(Long userId);
```

Las consultas personalizadas con `@Query` brindan flexibilidad, pero se debe ser consciente de que el lenguaje utilizado es JPQL, que es diferente de SQL. JPQL se basa en las entidades y sus relaciones, lo que permite escribir consultas de manera m치s orientada a objetos (independiente del motor de base de datos). Pese a ello, JPQL cuenta con similitudes con SQL, tiene cl치usulas como `SELECT`, `FROM`, `WHERE`, `JOIN`, `GROUP BY`, `ORDER BY`, entre otras.

Para m치s detalles sobre JPQL, se recomienda consultar la [documentaci칩n oficial de JPA](https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html).

### 3. Consultas personalizadas con `@Query` nativas

En Spring Data JPA, la anotaci칩n `@Query` tambi칠n permite definir consultas SQL nativas utilizando el atributo `nativeQuery = true`. Esto es 칰til cuando se necesita aprovechar caracter칤sticas espec칤ficas del motor de base de datos o cuando la consulta es demasiado compleja para ser expresada en JPQL.

#### Ejemplo de consulta nativa

```java
@Query(value = "SELECT * FROM users u WHERE u.age > :age", nativeQuery = true)
List<User> findUsersAboveAge(@Param("age") int age);
```
En este ejemplo, se est치 utilizando una consulta SQL nativa para seleccionar usuarios cuya edad sea mayor que un valor espec칤fico. El atributo `nativeQuery = true` indica que la consulta es SQL nativa.


### Comparativa entre ambos enfoques

| Inferencia de Queries | @Query Personalizado |
|----------------------|---------------------|
| **Facilidad de Uso:** La inferencia a trav칠s de convenciones de nombres es f치cil de usar y reduce la cantidad de c칩digo necesario. | **Flexibilidad:** Permite consultas m치s complejas y personalizadas que no pueden ser inferidas f치cilmente. |
| **Menos C칩digo:** No es necesario escribir consultas SQL completas, lo que puede reducir el c칩digo y hacerlo m치s legible. | **Optimizaci칩n:** Se pueden optimizar las consultas seg칰n los requisitos espec칤ficos de rendimiento de la aplicaci칩n. |
| **Consistencia:** Sigue las convenciones establecidas por Spring Data, haciendo el c칩digo m치s consistente. | **Control Total:** Proporciona un control total sobre la consulta, 칰til cuando se necesita un nivel m치s granular de control. |

> 丘멆잺 **Importante:** En el proyecto final puede usar el enfoque que m치s le guste o puede usar ambos. Hay total libertad.

---

## Precauciones y Recomendaciones

- Verificar que tiene instalado el JDK de Java (preferiblemente la versi칩n 21)
- Asegurar que el servidor de base de datos (MariaDB) est칠 corriendo.

---

## Evaluaci칩n o Resultado

Se espera que el estudiante entienda c칩mo programar consultas b치sicas en el proyecto de Spring Boot usando Spring Data JPA.

---

## Procedimiento

Realice los siguientes ejercicios en sus repositorios correspondientes. Adem치s, programe el servicio y el controlador para que pueda probar la consulta desde Postman, Insomnia o archivos `.http`.

### 1. Consulta por ciudad con paginaci칩n
Escriba una consulta que devuelva una lista de alojamientos dada una ciudad. Use `Pageable`. 

### 2. Autenticaci칩n de usuario
Construya una consulta que le permita obtener el usuario al que le correspondan unos datos de autenticaci칩n (como por ejemplo email y contrase침a). 

### 3. Reportes de usuario con ordenamiento
Escriba una consulta que permita obtener las reservas de un usuario dado su id. Haga que la lista se pueda ordenar seg칰n la fecha (ascendente o descendentemente).

### 4. B칰squeda por texto con paginaci칩n
Escriba una consulta que permita obtener los alojamientos cuyo nombre contenga un texto dado ignorando may칰sculas o min칰sculas (use un paginador).

### 5. Consultas personalizadas
Cree al menos 5 consultas relacionadas a su proyecto y los respectivos m칠todos de prueba.

---

## Para la pr칩xima clase

- Investigue sobre `Criteria`, identificando las ventajas que ofrece en comparaci칩n con lo explicado en esta gu칤a, as칤 como las desventajas que presenta.
- Investigue sobre las pruebas unitarias y su importancia. Puede buscar informaci칩n sobre **JUnit** y **Mockito**.
<!-- Aqu√≠ cargamos Mermaid.js --> 
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> 
<script> document.addEventListener("DOMContentLoaded", function() { mermaid.initialize({ startOnLoad: true }); }); </script>

```
Programa de Ingenier√≠a de Sistemas y Computaci√≥n
Universidad del Quind√≠o

T√≠tulo: Pruebas unitarias y de integraci√≥n en Spring Boot
Duraci√≥n estimada: 240
Docentes: Carlos Andr√©s Florez, Christian Andr√©s Candela
Gu√≠a: 13
```

# Pruebas unitarias y de integraci√≥n en Spring Boot

## üéØ Objetivo  
Comprender qu√© son las pruebas unitarias y de integraci√≥n, su importancia en el desarrollo de software y c√≥mo implementarlas eficientemente en un proyecto Spring Boot.

---

## Conceptos b√°sicos

- **Pruebas Unitarias**: Verificaci√≥n del comportamiento de unidades individuales de c√≥digo (m√©todos o funciones).  
- **JUnit**: Framework de pruebas para Java.  
- **Mockito**: Biblioteca para simular dependencias externas.  
- **Spring Boot Test**: Herramientas integradas de Spring para pruebas unitarias e integraci√≥n.  
- **Spring Boot:** Framework para desarrollar aplicaciones en Java con una configuraci√≥n m√≠nima.
- **Inyecci√≥n de dependencias:** Mecanismo para gestionar la creaci√≥n y administraci√≥n de componentes.
- **HTTP (Hypertext Transfer Protocol)**  Protocolo de comunicaci√≥n para la transferencia de datos en la web. 
- **CRUD (Create, Read, Update, Delete)**  Conjunto de operaciones b√°sicas para manipular datos (crear, leer, actualizar y eliminar).

---

## Contextualizaci√≥n Te√≥rica 

Las pruebas son una parte fundamental del desarrollo de software moderno. Permiten verificar que el c√≥digo funciona como se espera, facilitando la detecci√≥n temprana de errores y mejorando la calidad del producto final. 

> "Las pruebas no son solo para encontrar errores, son para prevenir que ocurran" - Martin Fowler


### Glosario T√©cnico

Todo Software requiere pruebas para garantizar su calidad y funcionamiento correcto. A continuaci√≥n, se presentan algunos t√©rminos clave relacionados con las pruebas:

| T√©rmino | Definici√≥n | Ejemplo |
|---------|------------|---------|
| **Prueba Unitaria** | Verificaci√≥n de unidades individuales de c√≥digo | Probar un m√©todo de c√°lculo |
| **Mock** | Objeto simulado que reemplaza dependencias | Simular una base de datos |
| **AAA Pattern** | Arrange-Act-Assert (Organizar-Actuar-Afirmar) | Estructura b√°sica de pruebas |
| **Cobertura** | Porcentaje de c√≥digo ejecutado por pruebas | 80% de cobertura |

### ¬øQu√© son las Pruebas Unitarias?

Las pruebas unitarias son peque√±os tests que validan si una unidad espec√≠fica de c√≥digo funciona correctamente de manera aislada. Estas pruebas son esenciales porque:
1. **Detecci√≥n temprana de errores:** Ayudan a identificar fallos en la l√≥gica de negocio antes de que el c√≥digo se integre con otros sistemas.
2. **Mejor mantenimiento del c√≥digo:** Facilitan la refactorizaci√≥n sin riesgo de introducir errores.
3. **Mejoran la calidad del software**: Garantizan que cada componente funcione como se espera.

#### Importancia de las Pruebas Unitarias

Las pruebas unitarias son un componente esencial en el desarrollo de software, ya que permiten validar de manera aislada el comportamiento de los servicios y la l√≥gica de negocio. En Spring Boot, el uso de herramientas como JUnit y Mockito facilita la verificaci√≥n del correcto funcionamiento de los m√©todos sin depender de una base de datos o de otros componentes de la aplicaci√≥n.

Al implementar pruebas unitarias, se logran beneficios como:

- Reducen costos al identificar errores durante el desarrollo.
- Facilitan la colaboraci√≥n en equipos grandes al garantizar consistencia.
- Mejoran la documentaci√≥n impl√≠cita del c√≥digo.

En el contexto de Spring Boot, las pruebas unitarias se enfocan en la validaci√≥n de los m√©todos de los servicios, asegurando que las reglas de negocio se ejecuten correctamente y que las excepciones sean manejadas de manera adecuada.

### Pruebas de Integraci√≥n: El Puente entre Componentes

Las pruebas de integraci√≥n validan la interacci√≥n correcta entre m√∫ltiples componentes o sistemas que funcionan conjuntamente. A diferencia de las unitarias, involucran:  

- **Comunicaci√≥n con bases de datos reales** (MySQL, MongoDB)  
- **Llamadas a servicios externos** (APIs REST, SOAP)  
- **Interacci√≥n entre capas** (Controlador ‚Üí Servicio ‚Üí Repositorio)  

En la siguiente tabla se resumen las **caracter√≠sticas principales** de las pruebas de integraci√≥n:

| Aspecto          | Descripci√≥n                                                                  |
|------------------|------------------------------------------------------------------------------|
| **Objetivo**     | Detectar fallos en interfaces e interacciones entre componentes integrados   |
| **Velocidad**    | Moderada (segundos por prueba)                                               |
| **Alcance**      | Subconjunto del sistema (2+ componentes acoplados)                           |
| **Herramientas** | `@SpringBootTest`, TestContainers, bases de datos en memoria (H2)            |

### Pruebas End-to-End (E2E): Validando el Flujo Completo 

Simulan el comportamiento real de un usuario final ejecutando escenarios completos desde la interfaz hasta el backend y sistemas externos. Hay herramientas populares como Selenium, Cypress y Puppeteer para automatizar estas pruebas.

**Elementos involucrados:**  

- **Interfaz de usuario** (Browser, Mobile App)  
- **Backend services**  (APIs REST, GraphQL)
- **Bases de datos**  (SQL, NoSQL)
- **Redes y middleware** (APIs externas, servicios en la nube)

### Comparativa clave:

En la siguiente tabla se resumen las diferencias principales entre los tres tipos de pruebas:

| Criterio          | Pruebas Unitarias | Pruebas de Integraci√≥n | Pruebas E2E         |
|-------------------|-------------------|------------------------|---------------------|
| **Enfoque**       | M√©todos aislados  | M√≥dulos interactuando  | Sistema completo    |
| **Dependencias**  | Mockeadas         | Parcialmente reales    | Todas reales        |
| **Ejecuci√≥n**     | Milisegundos      | Segundos               | Minutos/horas       |
| **Herramientas**  | JUnit, Mockito    | SpringBootTest         | Selenium, Cypress   |

### Pir√°mide de Pruebas 

A nivel estrat√©gico, la pir√°mide de pruebas sugiere una distribuci√≥n ideal de tipos de pruebas para maximizar la eficiencia y cobertura:

<div class="mermaid" style="text-align: center;">
graph TD
    A[70% Unitarias] -->|Validar l√≥gica| B[20% Integraci√≥n]
    B -->|Verificar interfaces| C[10% E2E]
    style A fill:#4CAF50,stroke:#388E3C
    style B fill:#2196F3,stroke:#1976D2
    style C fill:#FF9800,stroke:#F57C00
</div>

Esta estructura asegura que la mayor√≠a de los errores se detecten r√°pidamente en las pruebas unitarias, mientras que las pruebas de integraci√≥n y E2E validan la correcta interacci√≥n y funcionalidad del sistema completo.

**Raz√≥n de la pir√°mide:**  
- **Unitarias:** Cimientos s√≥lidos (r√°pidas, baratas).
- **Integraci√≥n:** Garantizan ensamblaje correcto aunque m√°s lentas ya que involucran m√°s componentes.
- **E2E:** Confirmaci√≥n final (costosas, fr√°giles).

**Error com√∫n:** Pir√°mide invertida (m√°s E2E que unitarias ‚Üí lentitud, dif√≠cil mantenimiento).  

### **Cu√°ndo Usar Cada Tipo**  

A continuaci√≥n, se presentan escenarios comunes y el tipo de prueba recomendado para cada uno:

| Escenario                          | Tipo Recomendado       | Raz√≥n                                                                 |
|------------------------------------|------------------------|-----------------------------------------------------------------------|
| Validar algoritmo de descuento     | **Unitaria**           | L√≥gica pura sin dependencias                                          |
| Probar conexi√≥n a base de datos    | **Integraci√≥n**        | Requiere DB real pero no toda la app                                  |
| Flujo completo de compra          | **E2E**                | Necesita UI + backend + pasarela de pago                             |
| Verificar respuesta HTTP de un API | **Integraci√≥n**        | Prueba servicio y controlador sin interfaz gr√°fica                   |

> "Las pruebas unitarias te dicen *si el c√≥digo funciona*, las de integraci√≥n *si los componentes colaboran*, y las E2E *si el sistema cumple su prop√≥sito*" ‚Äî Adaptado de Martin Fowler

### Herramientas y Frameworks

Las herramientas m√°s comunes para realizar pruebas unitarias en Spring Boot incluyen:

#### 1. JUnit 5
- Framework principal para escribir pruebas unitarias en Java.
- Anotaciones clave: `@Test`, `@BeforeEach`, `@AfterEach`, `@DisplayName`.
- Assertions: `assertEquals()`, `assertTrue()`, `assertThrows()`, `assertDoesNotThrow()`, etc.

#### 2. Mockito
- Simula dependencias externas (ej: repositorios, servicios, contexto de autenticaci√≥n) para aislar el c√≥digo bajo prueba.
- M√©todos √∫tiles: `mock()`, `when()`, `verify()`, etc.
- Permite crear pruebas unitarias r√°pidas y confiables sin necesidad de un contexto completo de Spring.

#### 3. Spring Boot Test
- Proporciona herramientas espec√≠ficas para probar aplicaciones Spring Boot.
- Anotaciones clave: `@SpringBootTest`, `@ExtendWith(MockitoExtension.class)`.
- `@Sql` para cargar datos de prueba desde archivos SQL.
- `@DataJpaTest` para pruebas de repositorios con base de datos en memoria (H2).

---

## Buenas Pr√°cticas y Recomendaciones

1. **Principio FIRST**:
   - **F**ast (R√°pidas): Las pruebas deben ejecutarse en milisegundos. Un conjunto completo de pruebas unitarias no deber√≠a tardar m√°s de unos segundos.
   - **I**solated (Aisladas): Cada prueba debe ser independiente y no depender de elementos tales como estados globales, orden de ejecuci√≥n, recursos externos, etc.
   - **R**epeatable (Repetibles): Las pruebas deben producir el mismo resultado en cualquier entorno y momento. Use m√©todos como `@BeforeEach` y `@AfterEach` para configurar y limpiar el estado antes y despu√©s de cada prueba, o use bases de datos con rollback autom√°tico.
   - **S**elf-validating (Auto-validables): La prueba debe entre otras cosas: determinar autom√°ticamente si pas√≥ o fall√≥, no requerir interpretaci√≥n humana, proporcionar mensajes de error claros.
   - **T**imely (Oportunas): Las pruebas deben escribirse preferiblemente antes del c√≥digo (TDD), m√°ximo inmediatamente despu√©s y nunca como actividad posterior.
    
2. **Usar Datos de Prueba Claros**:
   - Cree objetos de prueba con valores significativos.

3. **Nombrar Pruebas Correctamente**:
   - Use nombres descriptivos (ej: `testCreateUserWhenEmailExistsThrowsException`).


4. **Organizar las Pruebas con AAA (Arrange, Act, Assert)**:
   - **Arrange**: Configure los datos iniciales y mocks necesarios.
   - **Act**: Ejecute la acci√≥n o m√©todo bajo prueba.
   - **Assert**: Verifique que el resultado sea el esperado.
   - Ejemplo:
     ```java
     @Test
     void testSum() {
         // Arrange
         Calculator calculator = new Calculator();
         
         // Act
         int result = calculator.sum(2, 3);
         
         // Assert
         assertEquals(5, result);
     }
     ```
5. **Probar Escenarios Positivos y Negativos**:
   - Incluya tanto casos v√°lidos como inv√°lidos para garantizar que el c√≥digo maneje correctamente todas las situaciones.
 

6.  **Usar Herramientas de Cobertura de C√≥digo**:
    - Utilize herramientas como **JaCoCo** para medir la cobertura de tus pruebas y asegurarte de que est√°s probando suficientemente tu c√≥digo.  

7.  **Evitar Uso Excesivo de Mocks**:
    - Los mocks son √∫tiles, pero un exceso puede llevar a pruebas fr√°giles que no reflejan el comportamiento real del sistema.
    - Equilibra el uso de mocks con pruebas de integraci√≥n cuando sea necesario.

8.  **Documentar las Pruebas**:
    - A√±ada comentarios claros para explicar el prop√≥sito de cada prueba, especialmente si el escenario es complejo.

9.  **Mantenga las Pruebas Simples**:
    - Evite escribir pruebas demasiado complejas. Si una prueba es dif√≠cil de entender, probablemente tambi√©n lo ser√° mantenerla.
  
10. **Mantener las Pruebas Actualizadas**:
    - A medida que evoluciona el c√≥digo, aseg√∫rese de actualizar las pruebas para reflejar los cambios y evitar falsos positivos.    

---

## Procedimiento 

A continuaci√≥n, se presentan un conjunto de pasos y requerimientos generales para la construcci√≥n de un conjunto de pruebas unitarias y de integraci√≥n para su API REST y sus servicios de negocio.

Se har√°n **las pruebas con el CRUD de usuarios**, por lo tanto ser√°n √∫tiles los siguientes componentes del proyecto de Spring Boot: `UserController`, `UserService`, y `UserRepository`.

### 1. Estructura de Paquetes para Pruebas

En la carpeta `test/java` cree los siguientes paquetes para organizar las pruebas:

- `co.edu.uniquindio.application.services.unit`: Contendr√° las clases encargadas de crear las pruebas unitarias para los servicios de negocio.
- `co.edu.uniquindio.application.services.integration`: Contendr√° las clases encargadas de crear las pruebas de integraci√≥n para los servicios de negocio.
- `co.edu.uniquindio.application.controllers`: Contendr√° las clases encargadas de crear las pruebas de integraci√≥n para los controladores REST.
- `co.edu.uniquindio.application.repositories`: Contendr√° las clases encargadas de crear las pruebas unitarias para los repositorios, en especial para las consultas (**`@Query`**). No es necesario crear pruebas unitarias para los m√©todos CRUD b√°sicos, ya que estos son proporcionados por Spring Data JPA.

### 2. Pruebas unitarias de Servicios de Negocio

En el paquete `co.edu.uniquindio.application.services.unit` cree la clase `UserServiceTest` como se muestra a continuaci√≥n.

```java
package co.edu.uniquindio.application.services.unit;

import co.edu.uniquindio.application.dto.user.CreateUserDTO;
import co.edu.uniquindio.application.exceptions.ValueConflictException;
import co.edu.uniquindio.application.mappers.UserMapper;
import co.edu.uniquindio.application.model.entity.User;
import co.edu.uniquindio.application.repositories.UserRepository;
import co.edu.uniquindio.application.services.impl.UserServiceImpl;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.time.LocalDate;
import java.util.Optional;

@ExtendWith(MockitoExtension.class)
public class UserServiceTest {

    @Mock private UserMapper userMapper;
    @Mock private UserRepository userRepository;
    @Mock private PasswordEncoder passwordEncoder;

    @InjectMocks
    private UserServiceImpl userService;

}
```

Dado que las pruebas unitarias deben ser r√°pidas y aisladas, se usan las anotaciones `@Mock` para simular las dependencias del servicio e `@InjectMocks` para inyectar estas simulaciones en la instancia del servicio bajo prueba.

Esto permite probar el servicio sin necesidad de un contexto de Spring Boot, ni de los componentes reales como la base de datos, repositorios o mappers.

**Probar el m√©todo createUser**

Se probar√° el m√©todo `create` del servicio de negocio `UserService` para dos escenarios: uno exitoso y otro que lanza una excepci√≥n cuando se intenta crear un usuario con un email que ya existe.

```java

@Test
@DisplayName("Crear usuario exitosamente cuando el email no existe")
void testCreateUser_Success() throws Exception {
    // Arrange
    var userDTO = new CreateUserDTO(
            "Carlos",
            "123456789",
            "carlos@email.com",
            "Password123",
            "http://photo.url",
            LocalDate.of(1990, 1, 1)
    );

    // Simular que el correo no existe
    when(userRepository.findByEmail(userDTO.email())).thenReturn(Optional.empty());

    // Simular el mapeo del DTO a entidad
    User userEntity = new User();
    userEntity.setEmail(userDTO.email());
    userEntity.setName(userDTO.name());

    when(userMapper.toEntity(userDTO)).thenReturn(userEntity);
    when(passwordEncoder.encode("Password123")).thenReturn("encodedPassword");

    // Simular el guardado del usuario
    when(userRepository.save(any(User.class))).thenReturn(userEntity);

    // Act & Assert
    assertDoesNotThrow(() -> userService.create(userDTO));
}

@Test
@DisplayName("Crear usuario lanza excepci√≥n cuando el email ya est√° en uso")
void testCreateUser_EmailAlreadyExists() {
    // Arrange
    var userDTO = new CreateUserDTO(
            "Carlos",
            "123456789",
            "carlos@email.com",
            "Password123",
            "http://photo.url",
            LocalDate.of(1990, 1, 1)
    );

    User existingUser = new User();
    existingUser.setEmail("carlos@email.com");

    // Simular que el correo ya existe
    when(userRepository.findByEmail(userDTO.email())).thenReturn(Optional.of(existingUser));

    // Act & Assert
    assertThrows(ValueConflictException.class, () -> userService.create(userDTO));

}
```
Cada m√©todo usa `when` para definir el comportamiento esperado de los mocks, por ejemplo, se simula buscar un usuario por email y el resultado esperado. Luego, se usa `assertDoesNotThrow` y `assertThrows` para verificar que el m√©todo bajo prueba se comporte como se espera en cada escenario.

Cuando se requiera probar servicios que dependan de otros componentes, se pueden simular estos servicios usando `@Mock` y definir su comportamiento esperado con Mockito.

### 3. Configuraci√≥n de base de datos para pruebas de integraci√≥n

Para las pruebas de integraci√≥n es necesario configurar una base de datos que se usar√° exclusivamente para las pruebas. En este caso se usar√° MariaDB.

En la carpeta `test/resources` cree un archivo `application.properties`, en el tendremos la configuraci√≥n que usar√° la aplicaci√≥n para la realizaci√≥n de las pruebas.

```properties
# Configuraci√≥n datasource
spring.datasource.url=jdbc:mariadb://localhost:3306/booking-test
spring.datasource.username=USERNAME
spring.datasource.password=PASSWORD
spring.datasource.driver-class-name=org.mariadb.jdbc.Driver

# Configuraci√≥n JPA/Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
```

> ‚ö†Ô∏è Observe que `mariadb://localhost:3306/booking-test` configura una **base de datos para pruebas** diferente a la usada en desarrollo. Esto debido a que las pruebas borrar√°n los datos de las colecciones cada vez que se ejecuten para garantizar un resultado predecible.

### 4. Preparaci√≥n de Datos de Prueba

En la carpeta `test/resources` cree un archivo `dataset.sql`, en el cual se deben definir los datos iniciales que se cargar√°n en la base de datos para la realizaci√≥n de las pruebas.

En el archivo `dataset.sql` creado, incluya los siguientes datos de prueba:

```sql
INSERT INTO `user` (
  `id`, `created_at`, `date_birth`, `email`, `is_host`, 
  `name`, `password`, `phone`, `photo_url`, `role`, `status`
) VALUES
('u001', '2025-10-05 14:30:00', '1990-06-15', 'maria.gomez@example.com', b'0', 
 'Mar√≠a G√≥mez', '$2b$10$A1bCdEfGhIjKlMnOpQrStUvWxYz1234567890abcdEfGhIj', 
 '+573001112233', 'https://example.com/photos/maria.jpg', 0, 'ACTIVE'),

('u002', '2025-09-28 09:45:00', '1985-12-02', 'juan.perez@example.com', b'1', 
 'Juan P√©rez', '$2b$10$ZyXwVuTsRqPoNmLkJiHgFeDcBa9876543210ZYXWVUTSRQPON', 
 '+573224445566', 'https://example.com/photos/juan.jpg', 1, 'ACTIVE'),

('u003', '2025-10-01 17:20:00', '1998-03-22', 'laura.mendoza@example.com', b'0', 
 'Laura Mendoza', '$2b$10$MnOpQrStUvWxYz1234567890abcdefGhIjKlMnOpQrStUvWxY', 
 NULL, NULL, 2, 'INACTIVE');


INSERT INTO `place` (
  `id`, `address`, `city`, `latitude`, `longitude`, `avg_rating`, 
  `created_at`, `description`, `max_guests`, `num_ratings`, 
  `price_per_night`, `status`, `title`, `host_id`
) VALUES
(
  1, 'Carrera 45 #23-10', 'Medell√≠n', 6.2518, -75.5636, 4.8,
  '2025-09-15 10:20:00', 
  'Apartamento moderno en El Poblado con vista a la ciudad y acceso a piscina y gimnasio.', 
  4, 56, 320000, 'ACTIVE', 'Apartamento moderno con vista panor√°mica', 'u002'
),
(
  2, 'Calle 10 #5-22', 'Cartagena', 10.3910, -75.4794, 4.6,
  '2025-08-30 18:45:00', 
  'Casa colonial en el centro hist√≥rico, ideal para grupos grandes, con terraza y jacuzzi.', 
  8, 89, 580000, 'ACTIVE', 'Casa colonial en el centro hist√≥rico', 'u002'
),
(
  3, 'Carrera 7 #72-50', 'Bogot√°', 4.6486, -74.0990, 4.2,
  '2025-10-02 09:10:00', 
  'Estudio acogedor en Chapinero, cerca de restaurantes, transporte y zonas comerciales.', 
  2, 34, 190000, 'INACTIVE', 'Estudio c√©ntrico en Chapinero', 'u002'
);
```

Se recomienda incluir al menos 3 registros por cada tabla que se vaya a usar en las pruebas. En este caso para generar los datos de prueba se han usado las tablas `user` y `place`. **Debe ajustar los datos seg√∫n las columnas definidas en sus entidades.**

Para **generar el resto de datos de prueba** necesarios para las dem√°s tablas, puede usar la herramienta [Mockaroo](https://mockaroo.com/) o directamente pedirle a ChatGPT que le genere los datos en formato SQL. Para este √∫ltimo caso, le puede pasar el esquema de la tabla y la cantidad de registros que desea generar.

Para mostrar el esquema de una tabla en MariaDB puede usar el siguiente comando SQL:

```sql
DESCRIBE nombre_de_la_tabla;
```

> ‚ö†Ô∏è **Nota:** Observe que los valores de las columnas `id` en la tabla `user` y `host_id` en la tabla `place` deben coincidir con los definidos en las entidades del proyecto. Adem√°s, las contrase√±as est√°n hasheadas usando BCrypt. Recuerde **ajustar los datos seg√∫n las columnas definidas** en sus entidades.

### 5. Pruebas de Integraci√≥n de Servicios de Negocio

En el paquete `co.edu.uniquindio.application.services.integration` cree la clase `UserServiceTest` como se muestra a continuaci√≥n.

```java
package co.edu.uniquindio.application.services.integration;

import co.edu.uniquindio.application.dto.user.CreateUserDTO;
import co.edu.uniquindio.application.exceptions.ValueConflictException;
import co.edu.uniquindio.application.repositories.UserRepository;
import co.edu.uniquindio.application.services.UserService;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import java.time.LocalDate;
import java.util.UUID;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.when;

import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.transaction.annotation.Transactional;

@SpringBootTest
@Transactional
public class UserServiceTest {

    @Autowired
    private UserService userService;
    @Autowired
    private UserRepository userRepository;

    // . . .
}
```

Se ha agregado la anotaci√≥n `@Transactional` para que cada prueba se ejecute dentro de una transacci√≥n que **se revertir√° al finalizar**, garantizando que los datos de prueba no afecten otras pruebas.

**Probar el m√©todo createUser**

Se probar√° el m√©todo `create` del servicio de negocio `UserService`. Esta es una prueba satisfactoria para el caso en que se crea un usuario exitosamente. Se usa la anotaci√≥n `@Sql` para **cargar los datos iniciales** definidos en el archivo `dataset.sql` antes de ejecutar la prueba.

```java
@Test
@Sql("classpath:dataset.sql" )
@DisplayName("Crear usuario exitosamente cuando el email no existe")
void testCreateUser_Success() {
    // Secci√≥n de Arrange: Se crean los datos del usuario a ser registrado
    var user = new CreateUserDTO(
            "Carlos",
            "123456789",
            "carlos@email.com",
            "Password123",
            "http://photo.url",
            LocalDate.of(1990, 1, 1)
    );
    // Secci√≥n de Act y Assert: Ejecute la acci√≥n de crear usuario y se espera que no lance excepciones
    assertDoesNotThrow( () -> userService.create(user));
}
```

Ahora, se probar√° el m√©todo `create` del servicio de negocio `UserService`. Esta es una prueba que verifica que se lance una excepci√≥n cuando se intenta crear un usuario con un email que ya existe.

```java
@Test
@Sql("classpath:dataset.sql" )
@DisplayName("Debe lanzar excepci√≥n cuando el email ya est√° en uso")
void testCreateUser_EmailAlreadyExists() throws Exception {
    // Secci√≥n de Arrange: Se crean los datos del usuario a ser
    // registrado (Con el email de un usuario ya existente).
    var userStore = userRepository.findById("u001").orElseThrow(() -> new Exception("No se encontro el usuario"));
    var user = new CreateUserDTO(
            "Carlos",
            "123456789",
            userStore.getEmail(),
            "Password123",
            "http://photo.url",
            LocalDate.of(1990, 1, 1)
    );
    // Secci√≥n de Act y Secci√≥n de Assert: Ejecute la acci√≥n de crear usuario,
    //  se verifica que genere una excepci√≥n debido al email repetido.
    assertThrows(ValueConflictException.class,() -> userService.create(user) );
}
```

**Probar el m√©todo getUser**

Igualmente, se probar√° el m√©todo `get` del servicio de negocio `UserService`. Esta es una prueba satisfactoria para el caso en que se obtiene un usuario exitosamente.

```java
@Test
@Sql("classpath:dataset.sql" )
@DisplayName("Obtener usuario exitosamente cuando el id existe")
void testGetUser_Success() {
    // Secci√≥n de Arrange: Se obtiene aleatoriamente
    // uno de los usuarios registrado para pruebas.
    var userStore = userRepository.findAll().stream().findAny().orElseThrow();
    // Secci√≥n de Act: Ejecute la acci√≥n de obtener usuario basado en su Id.
    var foundUser = assertDoesNotThrow( () -> userService.get(userStore.getId()) );
    // Secci√≥n de Assert: Se verifica que los datos obtenidos
    // correspondan a los del usuario almacenado.
    assertEquals(userStore.getName(),foundUser.name());
    assertEquals(userStore.getEmail(),foundUser.email());
    assertEquals(userStore.getRole(),foundUser.role());
}
```

Ahora, se probar√° el m√©todo `get` del servicio de negocio `UserService`. Esta es una prueba que verifica que se lance una excepci√≥n cuando se intenta obtener un usuario que no existe.

```java
@Test
@Sql("classpath:dataset.sql" )
@DisplayName("Obtener usuario lanza excepci√≥n cuando el id no existe")
void testGetUser_NotFound() {
    // Secci√≥n de Arrange: Se crean los datos del usuario a ser registrado
    // (Con el email de un usuario ya existente).
    var id = UUID.randomUUID().toString();
    // Secci√≥n de Act: Ejecute la acci√≥n de obtener usuario basado en su Id.
    assertThrows(Exception.class, () -> userService.get(id) );
}
```

**M√°s casos de prueba**

Cree otras pruebas de integraci√≥n para los servicios de negocio de su proyecto. Estas pruebas son de integraci√≥n porque usan realmente el repositorio y se interact√∫a con la base de datos probando la integraci√≥n de ambos componentes.

### 6. Pruebas de Integraci√≥n de Controladores REST

En el paquete ``co.edu.uniquindio.application.controllers`` cree la clase `UserControllerTest` como se muestra a continuaci√≥n.

```java
package co.edu.uniquindio.application.controllers;

import co.edu.uniquindio.application.dto.user.CreateUserDTO;
import co.edu.uniquindio.application.dto.user.EditUserDTO;
import co.edu.uniquindio.application.repositories.UserRepository;
import co.edu.uniquindio.application.security.JWTUtils;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDate;
import java.util.Map;
import java.util.UUID;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
@Transactional
public class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;
    @Autowired
    private ObjectMapper objectMapper;
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private JWTUtils jwtUtils;
    // . . .
}
```

En las pruebas de integraci√≥n se usa realmente el servicio de negocio, el repositorio y se interact√∫a con la base de datos probando la integraci√≥n de todos los componentes del sistema. Tambi√©n se usa la anotaci√≥n `@Transactional` para que cada prueba se ejecute dentro de una transacci√≥n que **se revertir√° al finalizar**, garantizando que los datos de prueba no afecten otras pruebas.

**Probar el m√©todo createUser**

Se probar√° el m√©todo `create` del controlador `UserController`. Esta es una prueba satisfactoria para el caso en que se crea un usuario exitosamente. De nuevo, se usa la anotaci√≥n `@Sql` para cargar los datos iniciales definidos en el archivo `dataset.sql` antes de ejecutar la prueba.

Las pruebas de integraci√≥n de controladores REST usan `MockMvc` para simular solicitudes HTTP y verificar las respuestas. Cada prueba se crea con `perform`, que permite definir el tipo de solicitud (GET, POST, etc.), la URL, los encabezados y el cuerpo de la solicitud. Luego, se usan m√©todos como `andExpect` para verificar el estado de la respuesta y su contenido.

```java
@Test
@Sql("classpath:dataset.sql" )
@DisplayName("Crear usuario exitosamente cuando el email no existe")
void testCreateUser_Success() throws Exception {
    // Secci√≥n de Arrange:
    var user = new CreateUserDTO(
            "Carlos",
            "123456789",
            "carlos@email.com",
            "Password123",
            "http://photo.url",
            LocalDate.of(1990, 1, 1)
    );

    // Secci√≥n de Act: Ejecute la acci√≥n de invocaci√≥n del servicio
    // de registro de usuarios
    mockMvc.perform(post("/api/auth/register")
                    .contentType("application/json")
                    .content(objectMapper.writeValueAsString(user)))
            // Secci√≥n de Assert: Se verifica que los datos
            // obtenidos correspondan a los del usuario registrado.
            .andExpect(status().isCreated());
}
```
Ahora, se probar√° el m√©todo `create` del controlador `UserController`. Esta es una prueba que verifica que se lance una excepci√≥n cuando se intenta crear un usuario con un email que ya existe.

```java
@Test
@Sql("classpath:dataset.sql" )
@DisplayName("Crear usuario lanza excepci√≥n cuando el email ya est√° en uso")
void testCreateUser_EmailAlreadyExists() throws Exception {
    // Secci√≥n de Arrange: Se seleccionan datos de un usuario ya
    // creado para que cuando se env√≠e la solicitud de creaci√≥n
    // genere una excepci√≥n de tipo ValueConflictException.
    var repeatedEmail = "juan.perez@example.com";
    var user = new CreateUserDTO(
            "Carlos",
            "123456789",
            repeatedEmail,
            "Password123",
            "http://photo.url",
            LocalDate.of(1990, 1, 1)
    );

    // Secci√≥n de Act: Ejecute la acci√≥n de invocaci√≥n del servicio
    // de registro de usuarios
    mockMvc.perform(post("/api/auth/register")
                    .contentType("application/json")
                    .content(objectMapper.writeValueAsString(user)))
            // Secci√≥n de Assert: Se verifica que el resultado
            // obtenido corresponda a lo esperado un status code de conflicto.
            .andExpect(status().isConflict());
}
```

**Probar el m√©todo getUser**

Igualmente, se probar√° el m√©todo `get` del controlador `UserController`. Esta es una prueba satisfactoria para el caso en que se obtiene un usuario exitosamente.

```java
@Test
@Sql("classpath:dataset.sql" )
@DisplayName("Obtener usuario exitosamente cuando el id existe")
void testGetUser_Success() throws Exception {
    // Secci√≥n de Arrange: Se preparan los datos para enviar una
    // solicitud de un usuario registrado
    var userStore = userRepository.findAll().stream().findAny().orElseThrow();
    // Secci√≥n de Act: Ejecute la acci√≥n de invocaci√≥n del servicio
    // de consulta de usuarios
    mockMvc.perform(get("/api/users/"+userStore.getId())
            // Secci√≥n de Assert: Se verifica que los datos
            // obtenidos correspondan a los del usuario esperado.
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.name").value(userStore.getName()))
            .andExpect(jsonPath("$.email").value(userStore.getEmail()))
            .andExpect(jsonPath("$.role").value(userStore.getRole().toString()));
}
```
Ahora, se probar√° el m√©todo `get` del controlador `UserController`. Esta es una prueba que verifica que se lance una excepci√≥n cuando se intenta obtener un usuario que no existe.

```java
@Test
@Sql("classpath:dataset.sql" )
@DisplayName("Obtener usuario lanza excepci√≥n cuando el id no existe")
void testGetUser_NotFound() throws Exception {
    // Secci√≥n de Arrange: Se crean los datos del usuario a ser
    // registrado (Con el email de un usuario ya existente).
    var id = UUID.randomUUID().toString();
    // Secci√≥n de Act: Ejecute la acci√≥n de invocaci√≥n del servicio
    // de consulta de usuarios
    mockMvc.perform(get("/api/users/"+id)
            // Secci√≥n de Assert: Se verifica que la respuesta
            // obtenida sea la esperada (404).
            .andExpect(status().isNotFound());
}
```

**M√°s casos de prueba**

Cree otros m√©todos que permitan probar los dem√°s endpoints del controlador `UserController`. Igualmente, cree clases que permitan probar los controladores REST de su proyecto.

### 7. Seguridad en Pruebas de Servicios

Si alg√∫n servicio de negocio requiere del contexto de seguridad (por ejemplo, obtener el usuario autenticado), puede simular este contexto en las pruebas usando `@MockitoBean` para simular el servicio de seguridad o el componente que obtiene el usuario autenticado.

Por ejemplo, si su servicio de negocio depende de un componente `AuthService` para obtener el usuario autenticado, puede hacer algo como esto:

```java
@MockitoBean
private AuthService authService;

@Test
void testSomeServiceMethod() {
    // Simular que el usuario autenticado tiene el ID "u001"
    when(authService.getAuthenticatedUserId()).thenReturn("u001"); 
    // Ahora puede llamar al m√©todo del servicio que depende del usuario autenticado
    var result = userService.someMethodThatNeedsAuthUser();
    // Verificar el resultado esperado
    assertNotNull(result);
}
```

La anotaci√≥n `@MockitoBean` crea un mock del componente `AuthService` por lo tanto, si `userService` depende de este servicio, se inyectar√° el mock en lugar del componente real. Luego, se usa `when` para definir el comportamiento esperado del mock.

### 8. Seguridad en Pruebas de Controladores

Para las pruebas de controladores que requieren autenticaci√≥n, puede simular un usuario autenticado utilizando anotaciones como `@WithMockUser` o configurando manualmente el contexto de seguridad en sus pruebas. Esto permite probar rutas protegidas sin necesidad de realizar un proceso de login real.

**Opci√≥n 1: Usar `@WithMockUser`**

Por ejemplo, si desea probar un endpoint que requiere que el usuario tenga el rol `ADMIN`, puede hacer algo como esto:

```java
@Test
@WithMockUser(username = "admin", roles = {"ADMIN"})
void testGetUserWithAdminRole() throws Exception {
    mockMvc.perform(get("/api/users/1"))
            .andExpect(status().isOk());
}
```

Tenga en cuenta que `@WithMockUser` crea un usuario simulado con el nombre de usuario y roles especificados. Si su aplicaci√≥n utiliza roles espec√≠ficos para acceder a ciertas rutas, aseg√∫rese de asignar los roles correctos en la anotaci√≥n. Para que esta anotaci√≥n funcione, **debe tener la dependencia** `spring-security-test` en su archivo `build.gradle`.

**Opci√≥n 2: Configurar el token JWT manualmente**

Otra opci√≥n es generar un token JWT v√°lido durante la prueba y agregarlo en el encabezado de autorizaci√≥n de las solicitudes HTTP simuladas. 

Por ejemplo, si su aplicaci√≥n utiliza JWT para la autenticaci√≥n, puede hacer algo como esto:

```java
@Test
void testGetUserWithJwt() throws Exception {
    var id = "u001"; // ID de un usuario existente en los datos de prueba
    var token = jwtUtils.generateToken(id, Map.of("role", "ROLE_GUEST")); // Genera un token JWT v√°lido con el id y los claims necesarios
    mockMvc.perform(get("/api/users/"+id)
            .header("Authorization", "Bearer " + token))
            .andExpect(status().isOk());
}
```

### 9. Usar Jacoco para medir la cobertura de c√≥digo

Una buena pr√°ctica es medir la cobertura de c√≥digo de las pruebas unitarias e integraci√≥n. Para ello, puede usar la herramienta [JaCoCo](https://www.jacoco.org/jacoco/).

Si est√° usando Gradle, debe agregar las siguientes l√≠neas a su archivo `build.gradle` (sin eliminar lo que ya tenga):

```groovy
plugins {
    id 'jacoco'
}

jacoco {
    toolVersion = "0.8.11"
}

tasks.named('test') {
    useJUnitPlatform()
    finalizedBy jacocoTestReport
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
    }
}
```

> ‚ö†Ô∏è  **Importante:** Recuerde sincronizar su proyecto despu√©s de modificar el archivo `build.gradle` para que Gradle descargue las dependencias necesarias.

Luego, puede **ejecutar las pruebas y generar el reporte** de cobertura con el siguiente comando (aseg√∫rese de estar en la ra√≠z del proyecto):

```bash
./gradlew test jacocoTestReport
```

El reporte se generar√° en la carpeta `build/reports/jacoco/test/html/index.html`. Abra este archivo en su navegador para ver el **reporte de cobertura de c√≥digo**. El reporte usa colores para indicar qu√© partes del c√≥digo est√°n cubiertas por las pruebas (verde) y cu√°les no (rojo).

Tambi√©n se generar√° un archivo en `build/reports/tests/test/index.html` que contiene los **resultados de las pruebas** unitarias e integraci√≥n en formato HTML.

### 10. Control de versiones

Recuerde hacer commit de sus avances en el repositorio de git y subirlos a GitHub.

---

## Evaluaci√≥n o Resultado

Se espera que el estudiante:
- Comprenda los conceptos b√°sicos de pruebas unitarias.
- Implemente pruebas unitarias para servicios y controladores.
- Use herramientas como JUnit y Mockito de manera efectiva.
- Comprenda los conceptos b√°sicos de pruebas de integraci√≥n.
- Implemente pruebas de integraci√≥n para servicios y controladores.
---

## Referencias Bibliogr√°ficas

- Spring Boot Documentation: [https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot)
- Postman API Testing: [https://www.postman.com/](https://www.postman.com/)
- cURL Command Reference: [https://curl.se/docs/](https://curl.se/docs/)
- [JUnit 5](https://junit.org/junit5/docs/current/user-guide/)
- [Mockito](https://site.mockito.org/)
- [Spring Boot Testing](https://spring.io/guides/gs/testing-web/)
- [Testing Best Practices](https://martinfowler.com/articles/practical-test-pyramid.html)




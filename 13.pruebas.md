<!-- Aqu√≠ cargamos Mermaid.js --> 
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> 
<script> document.addEventListener("DOMContentLoaded", function() { mermaid.initialize({ startOnLoad: true }); }); </script>

```
Programa de Ingenier√≠a de Sistemas y Computaci√≥n
Universidad del Quind√≠o

T√≠tulo: Pruebas unitarias y de integraci√≥n en Spring Boot
Duraci√≥n estimada: 240
Docentes: Carlos Andr√©s Florez, Christian Andr√©s Candela
Gu√≠a: 13
```

# Pruebas unitarias y de integraci√≥n en Spring Boot

## üéØ Objetivo  
Comprender qu√© son las pruebas unitarias y de integraci√≥n, su importancia en el desarrollo de software y c√≥mo implementarlas eficientemente en un proyecto Spring Boot.

---

## Conceptos b√°sicos

- **Pruebas Unitarias**: Verificaci√≥n del comportamiento de unidades individuales de c√≥digo (m√©todos o funciones).  
- **JUnit**: Framework de pruebas para Java.  
- **Mockito**: Biblioteca para simular dependencias externas.  
- **Spring Boot Test**: Herramientas integradas de Spring para pruebas unitarias e integraci√≥n.  
- **Spring Boot:** Framework para desarrollar aplicaciones en Java con una configuraci√≥n m√≠nima.
- **Inyecci√≥n de dependencias:** Mecanismo para gestionar la creaci√≥n y administraci√≥n de componentes.
- **HTTP (Hypertext Transfer Protocol)**  Protocolo de comunicaci√≥n para la transferencia de datos en la web. 
- **CRUD (Create, Read, Update, Delete)**  Conjunto de operaciones b√°sicas para manipular datos (crear, leer, actualizar y eliminar).

---

## Contextualizaci√≥n Te√≥rica 

Las pruebas son una parte fundamental del desarrollo de software moderno. Permiten verificar que el c√≥digo funciona como se espera, facilitando la detecci√≥n temprana de errores y mejorando la calidad del producto final. 

> "Las pruebas no son solo para encontrar errores, son para prevenir que ocurran" - Martin Fowler


### Glosario T√©cnico

Todo Software requiere pruebas para garantizar su calidad y funcionamiento correcto. A continuaci√≥n, se presentan algunos t√©rminos clave relacionados con las pruebas:

| T√©rmino | Definici√≥n | Ejemplo |
|---------|------------|---------|
| **Prueba Unitaria** | Verificaci√≥n de unidades individuales de c√≥digo | Probar un m√©todo de c√°lculo |
| **Mock** | Objeto simulado que reemplaza dependencias | Simular una base de datos |
| **AAA Pattern** | Arrange-Act-Assert (Organizar-Actuar-Afirmar) | Estructura b√°sica de pruebas |
| **Cobertura** | Porcentaje de c√≥digo ejecutado por pruebas | 80% de cobertura |

### ¬øQu√© son las Pruebas Unitarias?

Las pruebas unitarias son peque√±os tests que validan si una unidad espec√≠fica de c√≥digo funciona correctamente de manera aislada. Estas pruebas son esenciales porque:
1. **Detecci√≥n temprana de errores:** Ayudan a identificar fallos en la l√≥gica de negocio antes de que el c√≥digo se integre con otros sistemas.
2. **Mejor mantenimiento del c√≥digo:** Facilitan la refactorizaci√≥n sin riesgo de introducir errores.
3. **Mejoran la calidad del software**: Garantizan que cada componente funcione como se espera.

#### Importancia de las Pruebas Unitarias

Las pruebas unitarias son un componente esencial en el desarrollo de software, ya que permiten validar de manera aislada el comportamiento de los servicios y la l√≥gica de negocio. En Spring Boot, el uso de herramientas como JUnit y Mockito facilita la verificaci√≥n del correcto funcionamiento de los m√©todos sin depender de una base de datos o de otros componentes de la aplicaci√≥n.

Al implementar pruebas unitarias, se logran beneficios como:

- Reducen costos al identificar errores durante el desarrollo.
- Facilitan la colaboraci√≥n en equipos grandes al garantizar consistencia.
- Mejoran la documentaci√≥n impl√≠cita del c√≥digo.

En el contexto de Spring Boot, las pruebas unitarias se enfocan en la validaci√≥n de los m√©todos de los servicios, asegurando que las reglas de negocio se ejecuten correctamente y que las excepciones sean manejadas de manera adecuada.

### Pruebas de Integraci√≥n: El Puente entre Componentes

Las pruebas de integraci√≥n validan la interacci√≥n correcta entre m√∫ltiples componentes o sistemas que funcionan conjuntamente. A diferencia de las unitarias, involucran:  

- **Comunicaci√≥n con bases de datos reales** (MySQL, MongoDB)  
- **Llamadas a servicios externos** (APIs REST, SOAP)  
- **Interacci√≥n entre capas** (Controlador ‚Üí Servicio ‚Üí Repositorio)  

En la siguiente tabla se resumen las **caracter√≠sticas principales** de las pruebas de integraci√≥n:

| Aspecto          | Descripci√≥n                                                                  |
|------------------|------------------------------------------------------------------------------|
| **Objetivo**     | Detectar fallos en interfaces e interacciones entre componentes integrados   |
| **Velocidad**    | Moderada (segundos por prueba)                                               |
| **Alcance**      | Subconjunto del sistema (2+ componentes acoplados)                           |
| **Herramientas** | `@SpringBootTest`, TestContainers, bases de datos en memoria (H2)            |

### Pruebas End-to-End (E2E): Validando el Flujo Completo 

Simulan el comportamiento real de un usuario final ejecutando escenarios completos desde la interfaz hasta el backend y sistemas externos. Hay herramientas populares como Selenium, Cypress y Puppeteer para automatizar estas pruebas.

**Elementos involucrados:**  

- **Interfaz de usuario** (Browser, Mobile App)  
- **Backend services**  (APIs REST, GraphQL)
- **Bases de datos**  (SQL, NoSQL)
- **Redes y middleware** (APIs externas, servicios en la nube)

### Comparativa clave:

En la siguiente tabla se resumen las diferencias principales entre los tres tipos de pruebas:

| Criterio          | Pruebas Unitarias | Pruebas de Integraci√≥n | Pruebas E2E         |
|-------------------|-------------------|------------------------|---------------------|
| **Enfoque**       | M√©todos aislados  | M√≥dulos interactuando  | Sistema completo    |
| **Dependencias**  | Mockeadas         | Parcialmente reales    | Todas reales        |
| **Ejecuci√≥n**     | Milisegundos      | Segundos               | Minutos/horas       |
| **Herramientas**  | JUnit, Mockito    | SpringBootTest         | Selenium, Cypress   |

### Pir√°mide de Pruebas 

A nivel estrat√©gico, la pir√°mide de pruebas sugiere una distribuci√≥n ideal de tipos de pruebas para maximizar la eficiencia y cobertura:

<div class="mermaid" style="text-align: center;">
graph TD
    A[70% Unitarias] -->|Validar l√≥gica| B[20% Integraci√≥n]
    B -->|Verificar interfaces| C[10% E2E]
    style A fill:#4CAF50,stroke:#388E3C
    style B fill:#2196F3,stroke:#1976D2
    style C fill:#FF9800,stroke:#F57C00
</div>

Esta estructura asegura que la mayor√≠a de los errores se detecten r√°pidamente en las pruebas unitarias, mientras que las pruebas de integraci√≥n y E2E validan la correcta interacci√≥n y funcionalidad del sistema completo.

**Raz√≥n de la pir√°mide:**  
- **Unitarias:** Cimientos s√≥lidos (r√°pidas, baratas).
- **Integraci√≥n:** Garantizan ensamblaje correcto aunque m√°s lentas ya que involucran m√°s componentes.
- **E2E:** Confirmaci√≥n final (costosas, fr√°giles).

**Error com√∫n:** Pir√°mide invertida (m√°s E2E que unitarias ‚Üí lentitud, dif√≠cil mantenimiento).  

### **Cu√°ndo Usar Cada Tipo**  

A continuaci√≥n, se presentan escenarios comunes y el tipo de prueba recomendado para cada uno:

| Escenario                          | Tipo Recomendado       | Raz√≥n                                                                 |
|------------------------------------|------------------------|-----------------------------------------------------------------------|
| Validar algoritmo de descuento     | **Unitaria**           | L√≥gica pura sin dependencias                                          |
| Probar conexi√≥n a base de datos    | **Integraci√≥n**        | Requiere DB real pero no toda la app                                  |
| Flujo completo de compra          | **E2E**                | Necesita UI + backend + pasarela de pago                             |
| Verificar respuesta HTTP de un API | **Integraci√≥n**        | Prueba cliente-servidor sin interfaz gr√°fica                         |

> "Las pruebas unitarias te dicen *si el c√≥digo funciona*, las de integraci√≥n *si los componentes colaboran*, y las E2E *si el sistema cumple su prop√≥sito*" ‚Äî Adaptado de Martin Fowler

### Herramientas y Frameworks

Las herramientas m√°s comunes para realizar pruebas unitarias en Spring Boot incluyen:

#### 1. JUnit 5
- Framework principal para escribir pruebas unitarias en Java.
- Anotaciones clave: `@Test`, `@BeforeEach`, `@AfterEach`, `@DisplayName`.
- Assertions: `assertEquals()`, `assertTrue()`, `assertThrows()`, `assertDoesNotThrow()`, etc.

#### 2. Mockito
- Simula dependencias externas (ej: repositorios, servicios) para aislar el c√≥digo bajo prueba.
- M√©todos √∫tiles: `mock()`, `when()`, `verify()`, etc.

#### 3. Spring Boot Test
- Proporciona herramientas espec√≠ficas para probar aplicaciones Spring Boot.
- Anotaciones clave: `@SpringBootTest`, `@ExtendWith(MockitoExtension.class)`.
- `@Sql` para cargar datos de prueba desde archivos SQL.
- `@DataJpaTest` para pruebas de repositorios con base de datos en memoria (H2).

---

## Buenas Pr√°cticas y Recomendaciones

1. **Principio FIRST**:
   - **F**ast (R√°pidas): Las pruebas deben ejecutarse en milisegundos. Un conjunto completo de pruebas unitarias no deber√≠a tardar m√°s de unos segundos.
   - **I**solated (Aisladas): Cada prueba debe ser independiente y no depender de elementos tales como estados globales, orden de ejecuci√≥n, recursos externos, etc.
   - **R**epeatable (Repetibles): Las pruebas deben producir el mismo resultado en cualquier entorno y momento. Use m√©todos como `@BeforeEach` y `@AfterEach` para configurar y limpiar el estado antes y despu√©s de cada prueba, o use bases de datos con rollback autom√°tico.
   - **S**elf-validating (Auto-validables): La prueba debe entre otras cosas: determinar autom√°ticamente si pas√≥ o fall√≥, no requerir interpretaci√≥n humana, proporcionar mensajes de error claros.
   - **T**imely (Oportunas): Las pruebas deben escribirse preferiblemente antes del c√≥digo (TDD), m√°ximo inmediatamente despu√©s y nunca como actividad posterior.
    
2. **Usar Datos de Prueba Claros**:
   - Cree objetos de prueba con valores significativos.

3. **Nombrar Pruebas Correctamente**:
   - Use nombres descriptivos (ej: `testCreateUserWhenEmailExistsThrowsException`).


4. **Organizar las Pruebas con AAA (Arrange, Act, Assert)**:
   - **Arrange**: Configure los datos iniciales y mocks necesarios.
   - **Act**: Ejecute la acci√≥n o m√©todo bajo prueba.
   - **Assert**: Verifique que el resultado sea el esperado.
   - Ejemplo:
     ```java
     @Test
     void testSum() {
         // Arrange
         Calculator calculator = new Calculator();
         
         // Act
         int result = calculator.sum(2, 3);
         
         // Assert
         assertEquals(5, result);
     }
     ```
5. **Probar Escenarios Positivos y Negativos**:
   - Incluya tanto casos v√°lidos como inv√°lidos para garantizar que el c√≥digo maneje correctamente todas las situaciones.
 

6.  **Usar Herramientas de Cobertura de C√≥digo**:
    - Utilize herramientas como **JaCoCo** para medir la cobertura de tus pruebas y asegurarte de que est√°s probando suficientemente tu c√≥digo.  

7.  **Evitar Uso Excesivo de Mocks**:
    - Los mocks son √∫tiles, pero un exceso puede llevar a pruebas fr√°giles que no reflejan el comportamiento real del sistema.
    - Equilibra el uso de mocks con pruebas de integraci√≥n cuando sea necesario.

8.  **Documentar las Pruebas**:
    - A√±ada comentarios claros para explicar el prop√≥sito de cada prueba, especialmente si el escenario es complejo.

9.  **Mantenga las Pruebas Simples**:
    - Evite escribir pruebas demasiado complejas. Si una prueba es dif√≠cil de entender, probablemente tambi√©n lo ser√° mantenerla.
  
10. **Mantener las Pruebas Actualizadas**:
    - A medida que evoluciona el c√≥digo, aseg√∫rese de actualizar las pruebas para reflejar los cambios y evitar falsos positivos.    

---

## Procedimiento 

A continuaci√≥n, se presentan un conjunto de pasos y requerimientos generales para la construcci√≥n de un conjunto de pruebas unitarias y de integraci√≥n para su API REST y sus servicios de negocio. Los estudiantes deben usar el proyecto previamente elaborado como elemento base para la construcci√≥n de sus servicios de negocio en Spring Boot.

Se har√°n **las pruebas con el CRUD de usuarios**, por lo tanto ser√°n √∫tiles los siguientes componentes del proyecto de Spring Boot: `UserController`, `UserService`, y `UserRepository`.

### 1. Estructura de Paquetes para Pruebas

En la carpeta `test/java` cree los siguientes paquetes para organizar las pruebas:

- `co.edu.uniquindio.application.services`: Contendr√° las clases encargadas de crear las pruebas unitarias para los servicios de negocio.
- `co.edu.uniquindio.application.controllers`: Contendr√° las clases encargadas de crear las pruebas de integraci√≥n para los servicios REST.
- `co.edu.uniquindio.application.repositories`: Contendr√° las clases encargadas de crear las pruebas unitarias para los repositorios, en especial para las consultas (**`@Query`**). No es necesario crear pruebas unitarias para los m√©todos CRUD b√°sicos, ya que estos son proporcionados por Spring Data JPA.

### 2. Configuraci√≥n de base de datos para pruebas

En la carpeta `test/resources` cree un archivo `application.properties`, en el tendremos la configuraci√≥n que usar√° la aplicaci√≥n para la realizaci√≥n de las pruebas.

```properties
# Configuraci√≥n datasource
spring.datasource.url=jdbc:mariadb://localhost:3306/booking-test
spring.datasource.username=USERNAME
spring.datasource.password=PASSWORD
spring.datasource.driver-class-name=org.mariadb.jdbc.Driver

# Configuraci√≥n JPA/Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
```

> ‚ö†Ô∏è Observe que `mariadb://localhost:3306/booking-test` configura una **base de datos para pruebas** diferente a la usada en desarrollo. Esto debido a que las pruebas borrar√°n los datos de las colecciones cada vez que se ejecuten para garantizar un resultado predecible.

### 3. Preparaci√≥n de Datos de Prueba

En la carpeta `test/resources` cree un archivo `dataset.sql`, en el cual se deben definir los datos iniciales que se cargar√°n en la base de datos para la realizaci√≥n de las pruebas.

En el archivo `dataset.sql` creado, incluya los siguientes datos de prueba:

```sql
INSERT INTO `user` (
  `id`, `created_at`, `date_birth`, `email`, `is_host`, 
  `name`, `password`, `phone`, `photo_url`, `role`, `status`
) VALUES
('u001', '2025-10-05 14:30:00', '1990-06-15', 'maria.gomez@example.com', b'0', 
 'Mar√≠a G√≥mez', '$2b$10$A1bCdEfGhIjKlMnOpQrStUvWxYz1234567890abcdEfGhIj', 
 '+573001112233', 'https://example.com/photos/maria.jpg', 0, 'ACTIVE'),

('u002', '2025-09-28 09:45:00', '1985-12-02', 'juan.perez@example.com', b'1', 
 'Juan P√©rez', '$2b$10$ZyXwVuTsRqPoNmLkJiHgFeDcBa9876543210ZYXWVUTSRQPON', 
 '+573224445566', 'https://example.com/photos/juan.jpg', 1, 'ACTIVE'),

('u003', '2025-10-01 17:20:00', '1998-03-22', 'laura.mendoza@example.com', b'0', 
 'Laura Mendoza', '$2b$10$MnOpQrStUvWxYz1234567890abcdefGhIjKlMnOpQrStUvWxY', 
 NULL, NULL, 2, 'INACTIVE');


INSERT INTO `place` (
  `id`, `address`, `city`, `latitude`, `longitude`, `avg_rating`, 
  `created_at`, `description`, `max_guests`, `num_ratings`, 
  `price_per_night`, `status`, `title`, `host_id`
) VALUES
(
  1, 'Carrera 45 #23-10', 'Medell√≠n', 6.2518, -75.5636, 4.8,
  '2025-09-15 10:20:00', 
  'Apartamento moderno en El Poblado con vista a la ciudad y acceso a piscina y gimnasio.', 
  4, 56, 320000, 'ACTIVE', 'Apartamento moderno con vista panor√°mica', 'u002'
),
(
  2, 'Calle 10 #5-22', 'Cartagena', 10.3910, -75.4794, 4.6,
  '2025-08-30 18:45:00', 
  'Casa colonial en el centro hist√≥rico, ideal para grupos grandes, con terraza y jacuzzi.', 
  8, 89, 580000, 'ACTIVE', 'Casa colonial en el centro hist√≥rico', 'u002'
),
(
  3, 'Carrera 7 #72-50', 'Bogot√°', 4.6486, -74.0990, 4.2,
  '2025-10-02 09:10:00', 
  'Estudio acogedor en Chapinero, cerca de restaurantes, transporte y zonas comerciales.', 
  2, 34, 190000, 'INACTIVE', 'Estudio c√©ntrico en Chapinero', 'u002'
);
```

Se recomienda incluir al menos 3 registros por cada tabla que se vaya a usar en las pruebas. En este caso para generar los datos de prueba se han usado las tablas `user` y `place`. **Debe ajustar los datos seg√∫n las columnas definidas en sus entidades.**

Para generar el resto de datos de prueba necesarios para las dem√°s tablas, puede usar la herramienta [Mockaroo](https://mockaroo.com/) o directamente pedirle a ChatGPT que le genere los datos en formato SQL. Para este √∫ltimo caso, le puede pasar el esquema de la tabla y la cantidad de registros que desea generar.

Para mostrar el esquema de una tabla en MariaDB puede usar el siguiente comando SQL:

```sql
DESCRIBE nombre_de_la_tabla;
```

> ‚ö†Ô∏è **Nota:** Observe que los valores de las columnas `id` en la tabla `user` y `host_id` en la tabla `place` deben coincidir con los definidos en las entidades del proyecto. Adem√°s, las contrase√±as est√°n hasheadas usando BCrypt. Recuerde **ajustar los datos seg√∫n las columnas definidas** en sus entidades.

### 4. Pruebas de Integraci√≥n de Servicios de Negocio

En el paquete `co.edu.uniquindio.application.services` cree la clase `UserServiceTest` como se muestra a continuaci√≥n.

```java
package co.edu.uniquindio.application.services;

import co.edu.uniquindio.application.dto.user.CreateUserDTO;
import co.edu.uniquindio.application.exceptions.ValueConflictException;
import co.edu.uniquindio.application.repositories.UserRepository;
import co.edu.uniquindio.application.services.UserService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import java.time.LocalDate;
import java.util.UUID;
import static org.junit.jupiter.api.Assertions.*;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.transaction.annotation.Transactional;

@SpringBootTest
@Transactional
public class UserServiceTest {

    @Autowired
    private UserService userService;
    @Autowired
    private UserRepository userRepository;

    // . . .
}
```

Se ha agregado la anotaci√≥n `@Transactional` para que cada prueba se ejecute dentro de una transacci√≥n que **se revertir√° al finalizar**, garantizando que los datos de prueba no afecten otras pruebas.

**Probar el m√©todo createUser**

Se probar√° el m√©todo `create` del servicio de negocio `UserService`. Esta es una prueba satisfactoria para el caso en que se crea un usuario exitosamente. Se usa la anotaci√≥n `@Sql` para **cargar los datos iniciales** definidos en el archivo `dataset.sql` antes de ejecutar la prueba.

```java
@Test
@Sql("classpath:dataset.sql" )
void testCreateUser() {
    // Secci√≥n de Arrange: Se crean los datos del usuario a ser registrado
    var user = new CreateUserDTO(
            "Carlos",
            "123456789",
            "carlos@email.com",
            "Password123",
            "http://photo.url",
            LocalDate.of(1990, 1, 1)
    );
    // Secci√≥n de Act: Ejecute la acci√≥n de crear usuario y se espera que no lance excepciones
    assertDoesNotThrow( () -> userService.create(user));
}
```

Ahora, se probar√° el m√©todo `create` del servicio de negocio `UserService`. Esta es una prueba que verifica que se lance una excepci√≥n cuando se intenta crear un usuario con un email que ya existe.

```java
@Test
@Sql("classpath:dataset.sql" )
void testCreateUserThrowsValueConflictExceptionWhenEmailExists() throws Exception {
    // Secci√≥n de Arrange: Se crean los datos del usuario a ser
    // registrado (Con el email de un usuario ya existente).
    var userStore = userRepository.findById("u001").orElseThrow(() -> new Exception("No se encontro el usuario"));
    var user = new CreateUserDTO(
            "Carlos",
            "123456789",
            userStore.getEmail(),
            "Password123",
            "http://photo.url",
            LocalDate.of(1990, 1, 1)
    );
    // Secci√≥n de Act y Secci√≥n de Assert: Ejecute la acci√≥n de crear usuario,
    //  se verifica que genere una excepci√≥n debido al email repetido.
    assertThrows(ValueConflictException.class,() -> userService.create(user) );
}
```

**Probar el m√©todo getUser**

Igualmente, se probar√° el m√©todo `get` del servicio de negocio `UserService`. Esta es una prueba satisfactoria para el caso en que se obtiene un usuario exitosamente.

```java
@Test
@Sql("classpath:dataset.sql" )
void testGetUserSuccess() {
    // Secci√≥n de Arrange: Se obtiene aleatoriamente
    // uno de los usuarios registrado para pruebas.
    var userStore = userRepository.findAll().stream().findAny().orElseThrow();
    // Secci√≥n de Act: Ejecute la acci√≥n de obtener usuario basado en su Id.
    var foundUser = assertDoesNotThrow( () -> userService.get(userStore.getId()) );
    // Secci√≥n de Assert: Se verifica que los datos obtenidos
    // correspondan a los del usuario almacenado.
    assertEquals(userStore.getName(),foundUser.name());
    assertEquals(userStore.getEmail(),foundUser.email());
    assertEquals(userStore.getRole(),foundUser.role());
}
```

Ahora, se probar√° el m√©todo `get` del servicio de negocio `UserService`. Esta es una prueba que verifica que se lance una excepci√≥n cuando se intenta obtener un usuario que no existe.

```java
@Test
@Sql("classpath:dataset.sql" )
void testGetUserNotFound() {
    // Secci√≥n de Arrange: Se crean los datos del usuario a ser registrado
    // (Con el email de un usuario ya existente).
    var id = UUID.randomUUID().toString();
    // Secci√≥n de Act: Ejecute la acci√≥n de obtener usuario basado en su Id.
    assertThrows(Exception.class, () -> userService.get(id) );
}
```

**M√°s casos de prueba**

Cree clases que permitan probar (pruebas de integraci√≥n) los servicios de negocio de su proyecto. Estas pruebas son de integraci√≥n porque usan realmente el repositorio y se interact√∫a con la base de datos probando la integraci√≥n de ambos componentes.

### 5. Pruebas de Integraci√≥n de Controladores REST

En el paquete ``co.edu.uniquindio.application.controllers`` cree la clase `UserControllerTest` como se muestra a continuaci√≥n.

```java
package co.edu.uniquindio.application.controllers;

import co.edu.uniquindio.application.dto.user.CreateUserDTO;
import co.edu.uniquindio.application.repositories.UserRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.jdbc.Sql;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDate;
import java.util.UUID;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
@Transactional
public class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;
    @Autowired
    private ObjectMapper objectMapper;
    @Autowired
    private UserRepository userRepository;

    // . . .
}
```

En las pruebas de integraci√≥n se usa realmente el servicio de negocio, el repositorio y se interact√∫a con la base de datos probando la integraci√≥n de todos los componentes del sistema. Tambi√©n se usa la anotaci√≥n `@Transactional` para que cada prueba se ejecute dentro de una transacci√≥n que **se revertir√° al finalizar**, garantizando que los datos de prueba no afecten otras pruebas.

**Probar el m√©todo createUser**

Se probar√° el m√©todo `create` del controlador `UserController`. Esta es una prueba satisfactoria para el caso en que se crea un usuario exitosamente. De nuevo, se usa la anotaci√≥n `@Sql` para cargar los datos iniciales definidos en el archivo `dataset.sql` antes de ejecutar la prueba.

Las pruebas de integraci√≥n de controladores REST usan `MockMvc` para simular solicitudes HTTP y verificar las respuestas. Cada prueba se crea con `perform`, que permite definir el tipo de solicitud (GET, POST, etc.), la URL, los encabezados y el cuerpo de la solicitud. Luego, se usan m√©todos como `andExpect` para verificar el estado de la respuesta y su contenido.


```java
@Test
@Sql("classpath:dataset.sql" )
void testCreateUserSuccess() throws Exception {
    // Secci√≥n de Arrange:
    var user = new CreateUserDTO(
            "Carlos",
            "123456789",
            "carlos@email.com",
            "Password123",
            "http://photo.url",
            LocalDate.of(1990, 1, 1)
    );

    // Secci√≥n de Act: Ejecute la acci√≥n de invocaci√≥n del servicio
    // de registro de usuarios
    mockMvc.perform(post("/api/auth/register")
                    .contentType("application/json")
                    .content(objectMapper.writeValueAsString(user)))
            // Secci√≥n de Assert: Se verifica que los datos
            // obtenidos correspondan a los del usuario registrado.
            .andExpect(status().isCreated());
}
```
Ahora, se probar√° el m√©todo `create` del controlador `UserController`. Esta es una prueba que verifica que se lance una excepci√≥n cuando se intenta crear un usuario con un email que ya existe.

```java
@Test
@Sql("classpath:dataset.sql" )
void testCreateUserValueConflictExceptionWhenEmailExists() throws Exception {
    // Secci√≥n de Arrange: Se seleccionan datos de un usuario ya
    // creado para que cuando se env√≠e la solicitud de creaci√≥n
    // genere una excepci√≥n de tipo ValueConflictException.
    var repeatedEmail = "juan.perez@example.com";
    var user = new CreateUserDTO(
            "Carlos",
            "123456789",
            repeatedEmail,
            "Password123",
            "http://photo.url",
            LocalDate.of(1990, 1, 1)
    );

    // Secci√≥n de Act: Ejecute la acci√≥n de invocaci√≥n del servicio
    // de registro de usuarios
    mockMvc.perform(post("/api/auth/register")
                    .contentType("application/json")
                    .content(objectMapper.writeValueAsString(user)))
            // Secci√≥n de Assert: Se verifica que el resultado
            // obtenido corresponda a lo esperado un status code de conflicto.
            .andExpect(status().isConflict());
}
```

**Probar el m√©todo getUser**

Igualmente, se probar√° el m√©todo `get` del controlador `UserController`. Esta es una prueba satisfactoria para el caso en que se obtiene un usuario exitosamente.

```java
@Test
@Sql("classpath:dataset.sql" )
void testGetUserSuccess() throws Exception {
    // Secci√≥n de Arrange: Se preparan los datos para enviar una solicitud de un usuario registrado
    var userStore = userRepository.findAll().stream().findAny().orElseThrow();

    // Secci√≥n de Act: Ejecute la acci√≥n de invocaci√≥n del servicio de consulta de usuarios
    mockMvc.perform(get("/api/users/"+userStore.getId()))
            // Secci√≥n de Assert: Se verifica que los datos
            // obtenidos correspondan a los del usuario esperado.
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.content.name").value(userStore.getName()))
            .andExpect(jsonPath("$.content.email").value(userStore.getEmail()))
            .andExpect(jsonPath("$.content.role").value(userStore.getRole().toString()));
}
```
Ahora, se probar√° el m√©todo `get` del controlador `UserController`. Esta es una prueba que verifica que se lance una excepci√≥n cuando se intenta obtener un usuario que no existe.

```java
@Test
@Sql("classpath:dataset.sql" )
void testGetUserNotFound() throws Exception {
    // Secci√≥n de Arrange: Se crean los datos del usuario a ser
    // registrado (Con el email de un usuario ya existente).
    var id = UUID.randomUUID().toString();
    // Secci√≥n de Act: Ejecute la acci√≥n de invocaci√≥n del servicio
    // de consulta de usuarios
    mockMvc.perform(get("/api/users/"+id))
            // Secci√≥n de Assert: Se verifica que la respuesta
            // obtenida sea la esperada (404).
            .andExpect(status().isNotFound());
}
```

**M√°s casos de prueba**

Cree clases que permitan probar (pruebas de integraci√≥n) las dem√°s rutas de sus controladores REST.

### 6. Seguridad en Pruebas

Para las pruebas de controladores que requieren autenticaci√≥n, puede simular un usuario autenticado utilizando anotaciones como `@WithMockUser` o configurando manualmente el contexto de seguridad en sus pruebas. Esto permite probar rutas protegidas sin necesidad de realizar un proceso de login real.

Por ejemplo:

```java
@Test
@WithMockUser(username = "admin", roles = {"ADMIN"})
void testGetUserWithAdminRole() throws Exception {
    mockMvc.perform(get("/api/users/1"))
            .andExpect(status().isOk());
}
```

Tenga en cuenta que `@WithMockUser` crea un usuario simulado con el nombre de usuario y roles especificados. Si su aplicaci√≥n utiliza roles espec√≠ficos para acceder a ciertas rutas, aseg√∫rese de asignar los roles correctos en la anotaci√≥n. Para que esta anotaci√≥n funcione, **debe tener la dependencia** `spring-security-test` en su archivo `build.gradle`.

Otra opci√≥n es generar un token JWT v√°lido durante la prueba y agregarlo en el encabezado de autorizaci√≥n de las solicitudes HTTP simuladas. 

Por ejemplo, si su aplicaci√≥n utiliza JWT para la autenticaci√≥n, puede hacer algo como esto:

```java
@Test
void testGetUserWithJwt() throws Exception {
    var token = jwtUtils.generateToken(id, Map.of("role", "ROLE_GUEST")); // Genera un token JWT v√°lido con el id y los claims necesarios
    mockMvc.perform(get("/api/users/1")
            .header("Authorization", "Bearer " + token))
            .andExpect(status().isOk());
}
```

### 7. Control de versiones

Recuerde hacer commit de sus avances en el repositorio de git y subirlos a GitHub.

---

## Evaluaci√≥n o Resultado

Se espera que el estudiante:
- Comprenda los conceptos b√°sicos de pruebas unitarias.
- Implemente pruebas unitarias para servicios y controladores.
- Use herramientas como JUnit y Mockito de manera efectiva.
- Comprenda los conceptos b√°sicos de pruebas de integraci√≥n.
- Implemente pruebas de integraci√≥n para servicios y controladores.
---

## Referencias Bibliogr√°ficas

- Spring Boot Documentation: [https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot)
- Postman API Testing: [https://www.postman.com/](https://www.postman.com/)
- cURL Command Reference: [https://curl.se/docs/](https://curl.se/docs/)
- [JUnit 5](https://junit.org/junit5/docs/current/user-guide/)
- [Mockito](https://site.mockito.org/)
- [Spring Boot Testing](https://spring.io/guides/gs/testing-web/)
- [Testing Best Practices](https://martinfowler.com/articles/practical-test-pyramid.html)




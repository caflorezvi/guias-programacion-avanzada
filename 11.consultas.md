```
Programa de Ingenier√≠a de Sistemas y Computaci√≥n
Universidad del Quind√≠o

T√≠tulo: Consultas en Spring Data JPA
Duraci√≥n estimada: 120
Docentes: Carlos Andr√©s Florez, Christian Andr√©s Candela
Gu√≠a: 11
```

# Consultas en Spring Data JPA

## üéØ Objetivo
Aprender a crear consultas b√°sicas a una base de datos relacional por medio de Spring Data JPA.

---

## Conceptos b√°sicos

- **Bases de Datos SQL**: MariaDB como ejemplo principal.
- **Java**: Lenguaje de programaci√≥n orientado a objetos.
- **Spring Data JPA**: M√≥dulo de Spring para interactuar con bases de datos SQL.

---

## Contextualizaci√≥n Te√≥rica

Spring Data JPA es un proyecto del ecosistema Spring que proporciona una abstracci√≥n de alto nivel para la interacci√≥n con la base de datos relacionales en aplicaciones Java basadas en Spring. Su objetivo principal es simplificar el acceso a datos y reducir la cantidad de c√≥digo necesario para realizar operaciones comunes de base de datos.

### Caracter√≠sticas clave de Spring Data JPA

- **Abstracci√≥n de Repositorios:** Proporciona un conjunto de interfaces de repositorio que permiten realizar operaciones comunes de CRUD (Crear, Leer, Actualizar, Borrar) sin tener que escribir consultas espec√≠ficas de SQL. Esto se logra mediante la inferencia de consultas basada en convenciones de nombres de m√©todos.

- **Mapeo de Objetos a Tablas Relacionales:** Simplifica el mapeo de objetos Java a tablas en bases de datos relacionales. Se pueden anotar las clases de entidad con anotaciones de Spring Data y JPA, y el mapeo entre las propiedades de los objetos y las columnas de las tablas se realiza autom√°ticamente.

- **Soporte para Consultas Derivadas:** La inferencia de consultas permite construir consultas de SQL a partir de los nombres de los m√©todos en las interfaces de repositorio. Por ejemplo, al definir un m√©todo llamado `findByNombre(String nombre)`, Spring Data JPA generar√° autom√°ticamente una consulta para buscar registros donde el campo "nombre" coincida.

- **Soporte para Transacciones:** Spring Data JPA se integra con el soporte de transacciones de Spring, lo que facilita la gesti√≥n de transacciones en las operaciones de base de datos.

Cuando se utiliza Spring Boot en combinaci√≥n con Spring Data JPA y una base de datos relacional como MariaDB, se puede aprovechar la configuraci√≥n autom√°tica y las convenciones de Spring Boot para simplificar a√∫n m√°s el desarrollo de aplicaciones que interact√∫an con bases de datos.

### 1. Consultas por medio de la inferencias

La inferencia de queries en Spring Data JPA se refiere a la capacidad que tiene para generar consultas autom√°ticamente a partir de los nombres de los m√©todos en los repositorios. Utiliza convenciones de nomenclatura para analizar los nombres de los m√©todos y construir consultas SQL correspondientes.

**Por ejemplo**, si tenemos un m√©todo en un repositorio llamado `findByEmail(String email)`, Spring Data JPA inferir√° la consulta para buscar registros que tengan el campo "email" coincidente.

Esto proporciona una forma m√°s concisa de definir consultas sin tener que escribir consultas SQL completas manualmente. La inferencia de queries simplifica el desarrollo al generar din√°micamente las consultas seg√∫n la firma del m√©todo en el repositorio.

#### Algunos ejemplos:

A continuaci√≥n, se presentan algunos ejemplos de c√≥mo se pueden definir m√©todos en un repositorio para que Spring Data JPA infiera las consultas correspondientes:

**Consulta por igualdad**
```java
List<User> findByName(String name);
```
Spring Data generar√° una consulta tipo: `SELECT * FROM user WHERE name = ?`

**Consulta con operadores**

```java
List<User> findByAgeGreaterThan(int age);
```

Generar√° una consulta para encontrar usuarios cuya edad sea mayor que el valor proporcionado. Tambi√©n est√°n disponibles:
- `findByAgeGreaterThanEqual` para mayor o igual
- `findByAgeLessThan` para menor que

**Consulta con m√∫ltiples condiciones**

```java
List<User> findByNameAndAge(String name, int age);
```
Crear√° una consulta para encontrar usuarios con un nombre espec√≠fico y una edad dada. Tambi√©n est√°n disponibles los operadores `Or` y `Not`.

**Consulta por palabras clave (contenencia)**

```java
List<User> findByNameIsLike(String partOfName);
```

Generar√° una consulta para encontrar usuarios cuyos nombres contengan la parte especificada.

**Ordenamiento**

```java
List<User> findByAgeGreaterThanOrderByNameAsc(int age);
```
Encontrar√° usuarios mayores que la edad proporcionada y los ordenar√° alfab√©ticamente por nombre ascendente.

**Conteo**

```java
long countByAge(int age);
```
Contar√° el n√∫mero de usuarios con la edad dada.



**Paginaci√≥n de resultados**

Para paginar resultados, se pueden utilizar los m√©todos `findBy` junto con `Pageable` en los repositorios. Por ejemplo:

```java
Page<User> findByAge(int age, Pageable pageable);
```

Esto permitir√° obtener una p√°gina de resultados que cumplan con la condici√≥n de edad, facilitando la implementaci√≥n de paginaci√≥n en la aplicaci√≥n. Cuando se utiliza `Pageable`, el resultado se envuelve en un objeto `Page`, que proporciona informaci√≥n adicional sobre la paginaci√≥n, como el n√∫mero total de p√°ginas y el n√∫mero total de elementos. Por ejemplo:

```java
Pageable pageable = PageRequest.of(0, 10); // P√°gina 0 con 10 elementos por p√°gina
Page<User> usersPage = userRepository.findByAge(25, pageable);
List<User> users = usersPage.getContent(); // Obtener la lista de usuarios en la p√°gina
int totalPages = usersPage.getTotalPages(); // Obtener el n√∫mero total de p√°ginas
long totalElements = usersPage.getTotalElements(); // Obtener el n√∫mero total de elementos
```

**Ordenamiento de resultados**

Para ordenar los resultados, se puede utilizar el par√°metro `Sort` en los m√©todos de consulta. Por ejemplo:

```java
List<User> findByAge(int age, Sort sort);
```

Esto permitir√° ordenar los resultados seg√∫n los criterios especificados en el objeto `Sort`. Cuando se utiliza `Sort`, se puede definir el ordenamiento por uno o m√°s campos, ya sea en orden ascendente o descendente, por ejemplo:

```java
Sort sort = Sort.by(Sort.Direction.ASC, "name"); // Ordenar por nombre en orden ascendente
List<User> users = userRepository.findByAge(25, sort);
```

**Combinando paginaci√≥n y ordenamiento**

Si se necesita usar tanto paginaci√≥n como ordenamiento, se puede combinar `Pageable` y `Sort` de la siguiente manera:

```java
Pageable pageable = PageRequest.of(0, 10, Sort.by(Sort.Direction.DESC, "name")); // P√°gina 0 con 10 elementos por p√°gina, ordenados por nombre
Page<User> usersPage = userRepository.findByAge(25, pageable);
List<User> users = usersPage.getContent(); // Obtener la lista de usuarios en la p√°gina
```

#### Palabras clave comunes

Hay varias palabras clave disponibles: `findBy`, `count`, `GreaterThan`, `LessThan`, `OrderBy`, `And`, `Or`. Para conocer todas las palabras claves √∫tiles se recomienda consultar la [documentaci√≥n oficial](https://docs.spring.io/spring-data/jpa/reference/repositories/query-keywords-reference.html).

#### Puntos importantes para la inferencia de queries

Para que la inferencia funcione correctamente, se debe tener en cuenta:

- **Convenciones de nomenclatura:** Seguir las convenciones al definir los m√©todos en los repositorios. Utilizar nombres significativos que reflejen la operaci√≥n.

- **Tipos de retorno:** Utilizar tipos de retorno apropiados en los m√©todos de repositorio. Se puede devolver Listas, Streams, DTO, u otros tipos seg√∫n las necesidades.

- **Campos de entidad:** Asegurar que los nombres de los campos en las entidades coincidan con los utilizados en los m√©todos de repositorio.

- **Manejo de excepciones:** Implementar manejo de excepciones adecuado para casos donde las consultas no puedan ser inferidas correctamente.

### 2. Consultas personalizadas con `@Query`

En Spring Data JPA, la anotaci√≥n `@Query` se utiliza para definir consultas personalizadas en m√©todos de repositorio. A diferencia de la inferencia de consultas basada en convenciones de nombres, `@Query` permite escribir consultas JPQL o SQL nativas seg√∫n las necesidades.

#### Algunos ejemplos

A continuaci√≥n, se presentan algunos ejemplos de c√≥mo utilizar la anotaci√≥n `@Query` para definir consultas personalizadas en un repositorio:

**Consulta b√°sica**

Supongamos que tenemos una entidad llamada `User` con un campo `name`:

```java
@Query("SELECT u FROM User u WHERE u.name = :name")
List<User> getListUsers(String name);
```

Este es un ejemplo de una consulta JPQL que selecciona usuarios por nombre. Aunque aparece similar a SQL, JPQL opera sobre entidades y sus propiedades en lugar de tablas y columnas, por lo tanto es independiente del motor de base de datos. 

Dado que `User` es una entidad, `u` es un alias para la entidad y `u.name` se refiere a la propiedad `name` de la entidad.

Adem√°s, los par√°metros en la consulta se indican con `:` seguido del nombre del par√°metro.

**Consulta con m√∫ltiples condiciones**

```java
@Query("SELECT u FROM User u WHERE u.name = :name AND u.age = :age")
List<User> findByNameAndAge(String name, int age);
```

Retorna usuarios que coincidan con el nombre y la edad especificados.

**Consulta con conteo y agrupamiento**

```java
@Query("SELECT u.age, COUNT(u) FROM User u GROUP BY u.age")
List<Object[]> countUsersByAge();
```

Cada elemento del resultado es un arreglo donde el primer elemento es la edad y el segundo es el conteo de usuarios con esa edad.

**Consulta con join**

En ciertas situaciones, es posible que necesitemos realizar consultas que involucren m√∫ltiples entidades relacionadas. Por ejemplo, si tenemos una entidad `Order` relacionada con `User`, podemos hacer un join:

```java
@Query("SELECT o FROM Order o JOIN o.user u WHERE u.id = :userId")
List<Order> findOrdersByUserId(Long userId);
```

En este caso, la entidad `Order` tiene una relaci√≥n con la entidad `User`, y estamos buscando √≥rdenes asociadas a un usuario espec√≠fico. Incluso, si la relaci√≥n es bidireccional, se puede hacer el join desde cualquiera de las dos entidades, por ejemplo:

```java
@Query("SELECT o FROM User u JOIN u.orders o WHERE u.id = :userId")
List<Order> findOrdersByUserId(Long userId);
```

Las consultas personalizadas con `@Query` brindan flexibilidad, pero se debe ser consciente de que el lenguaje utilizado es JPQL, que es diferente de SQL. JPQL se basa en las entidades y sus relaciones, lo que permite escribir consultas de manera m√°s orientada a objetos (independiente del motor de base de datos). Pese a ello, JPQL cuenta con similitudes con SQL, tiene cl√°usulas como `SELECT`, `FROM`, `WHERE`, `JOIN`, `GROUP BY`, `ORDER BY`, entre otras.

Para m√°s detalles sobre JPQL, se recomienda consultar la [documentaci√≥n oficial de JPA](https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html).

### 3. Consultas personalizadas con `@Query` nativas

En Spring Data JPA, la anotaci√≥n `@Query` tambi√©n permite definir consultas SQL nativas utilizando el atributo `nativeQuery = true`. Esto es √∫til cuando se necesita aprovechar caracter√≠sticas espec√≠ficas del motor de base de datos o cuando la consulta es demasiado compleja para ser expresada en JPQL.

#### Ejemplo de consulta nativa

```java
@Query(value = "SELECT * FROM users u WHERE u.age > :age", nativeQuery = true)
List<User> findUsersAboveAge(@Param("age") int age);
```
En este ejemplo, se est√° utilizando una consulta SQL nativa para seleccionar usuarios cuya edad sea mayor que un valor espec√≠fico. El atributo `nativeQuery = true` indica que la consulta es SQL nativa.


#### Comparativa entre inferencia de queries y `@Query`

En la siguiente tabla se resumen las diferencias entre ambos enfoques:

| Inferencia de Queries | @Query Personalizado |
|----------------------|---------------------|
| **Facilidad de Uso:** La inferencia a trav√©s de convenciones de nombres es f√°cil de usar y reduce la cantidad de c√≥digo necesario. | **Flexibilidad:** Permite consultas m√°s complejas y personalizadas que no pueden ser inferidas f√°cilmente. |
| **Menos C√≥digo:** No es necesario escribir consultas SQL completas, lo que puede reducir el c√≥digo y hacerlo m√°s legible. | **Optimizaci√≥n:** Se pueden optimizar las consultas seg√∫n los requisitos espec√≠ficos de rendimiento de la aplicaci√≥n. |
| **Consistencia:** Sigue las convenciones establecidas por Spring Data, haciendo el c√≥digo m√°s consistente. | **Control Total:** Proporciona un control total sobre la consulta, √∫til cuando se necesita un nivel m√°s granular de control. |

### 4. Consultas usando Criteria API 

La Criteria API es una caracter√≠stica de JPA que permite construir consultas de manera program√°tica utilizando una API fluida y orientada a objetos. A diferencia de JPQL o SQL, donde las consultas se escriben como cadenas de texto, la Criteria API permite construir consultas din√°micamente mediante la creaci√≥n de objetos y m√©todos.

Es especialmente √∫til cuando se necesita construir consultas de manera din√°mica en funci√≥n de ciertos criterios (como filtros de b√∫squeda) que pueden variar en tiempo de ejecuci√≥n.

Para usar la Criteria API, se suelen seguir estos pasos:

1. **Obtener una instancia de `CriteriaBuilder`:** Se obtiene a trav√©s del `EntityManager`. Es el punto de entrada para construir consultas.

2. **Crear una instancia de `CriteriaQuery`:** Se especifica el tipo de resultado que se espera (por ejemplo, una entidad espec√≠fica).

3. **Definir la ra√≠z de la consulta:** Se especifica la entidad desde la cual se realizar√° la consulta utilizando `Root<T>`

4. **Agregar condiciones y filtros:** Se utilizan m√©todos del `CriteriaBuilder` para agregar condiciones a la consulta, como `where`, `and`, `or`, etc.

5. **Ejecutar la consulta:** Finalmente, se ejecuta la consulta utilizando el `EntityManager` para obtener los resultados.

**Ejemplo:**

```java
CriteriaBuilder cb = entityManager.getCriteriaBuilder();
CriteriaQuery<User> query = cb.createQuery(User.class);
Root<User> user = query.from(User.class);
query.select(user).where(cb.equal(user.get("name"), "John"));
List<User> result = entityManager.createQuery(query).getResultList();
```

Tenga en cuenta que la Criteria API puede ser m√°s verbosa y compleja en comparaci√≥n con JPQL o SQL, pero ofrece una mayor flexibilidad para construir consultas din√°micas y adaptarse a diferentes escenarios.

> ‚ö†Ô∏è **Importante:** En el proyecto final puede usar el enfoque que m√°s le guste o que considere m√°s adecuado. Hay total libertad.

---

## Precauciones y Recomendaciones

- Verificar que tiene instalado el JDK de Java (preferiblemente la versi√≥n 21)
- Asegurar que el servidor de base de datos (MariaDB) est√© corriendo.
- Cuando use `@Query`, aseg√∫rese de que las consultas est√©n correctamente formateadas y que los nombres de las entidades y campos coincidan con los definidos en su modelo.
- Cuando use inferencia de queries, siga las convenciones de nomenclatura para que Spring Data JPA pueda interpretar correctamente los nombres de los m√©todos.

---

## Evaluaci√≥n o Resultado

Se espera que el estudiante entienda c√≥mo programar consultas b√°sicas en el proyecto de Spring Boot usando Spring Data JPA.

---

## Procedimiento

Realice los siguientes ejercicios en sus repositorios correspondientes. Adem√°s, programe el servicio y el controlador para que pueda probar la consulta desde Postman, Insomnia o archivos `.http`.

### 1. Consulta por ciudad con paginaci√≥n
Escriba una consulta que devuelva una lista de alojamientos dada una ciudad. Use `Pageable`. 

### 2. Autenticaci√≥n de usuario
Construya una consulta que le permita obtener el usuario al que le correspondan unos datos de autenticaci√≥n (como por ejemplo email y contrase√±a). 

### 3. Reportes de usuario con ordenamiento
Escriba una consulta que permita obtener las reservas de un usuario dado su id. Haga que la lista se pueda ordenar seg√∫n la fecha (ascendente o descendentemente).

### 4. B√∫squeda por texto con paginaci√≥n
Escriba una consulta que permita obtener los alojamientos cuyo nombre contenga un texto dado ignorando may√∫sculas o min√∫sculas (use un paginador).

### 5. Consultas personalizadas
Cree al menos 5 consultas relacionadas a su proyecto y los respectivos m√©todos de prueba.

---

## Para la pr√≥xima clase

- Investigue sobre `JpaSpecificationExecutor`, identificando las ventajas que ofrece en comparaci√≥n con lo explicado en esta gu√≠a, as√≠ como las desventajas que presenta.
- Ampl√≠e la informaci√≥n sobre Criteria API, buscando ejemplos m√°s complejos y detallados.
- Investigue sobre las pruebas unitarias y su importancia. Puede buscar informaci√≥n sobre **JUnit** y **Mockito**.
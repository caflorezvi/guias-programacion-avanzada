```
Programa de Ingeniería de Sistemas y Computación
Universidad del Quindío

Título: Implementación de Servicios REST en Spring Boot
Duración estimada: 120
Docentes: Carlos Andrés Florez, Christian Andrés Candela
Guía: 05
```
# **Controladores REST en Spring Boot**

## **🎯 Objetivo**  
Implementar una API REST utilizando **Spring Boot**, basada en un diseño previo realizado con **OpenAPI**. Los estudiantes aprenderán a traducir un diseño de API en una implementación funcional en Java, aplicando principios de programación empresarial y buenas prácticas de desarrollo.

---

## **Conceptos Básicos**  
Antes de iniciar con el diseño, es importante comprender algunos conceptos fundamentales:

#### **1. REST (Representational State Transfer)**  
Estilo arquitectónico basado en principios como:
- Separación cliente-servidor.
- Uso de recursos identificados por URIs.
- Uso de métodos HTTP estándar (GET, POST, PUT, DELETE, PATCH, etc.).
- Implementación de respuestas sin estado (**stateless**).
- Cacheabilidad y escalabilidad.

**Referencia:** Fielding, R. T. (2000). *Architectural Styles and the Design of Network-based Software Architectures*. University of California, Irvine.

#### **2. HTTP (Hypertext Transfer Protocol)**  
Protocolo de comunicación para la transferencia de datos en la web. Define métodos estándar como:
- **GET**: Obtener información.
- **POST**: Crear un nuevo recurso.
- **PUT**: Actualizar un recurso existente.
- **DELETE**: Eliminar un recurso.

**Referencia:** RFC 7231 - *Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content*. [IETF RFC 7231](https://tools.ietf.org/html/rfc7231).

#### **3. OpenAPI**  
Especificación abierta para describir APIs RESTful, permitiendo generar documentación interactiva, facilitar la integración con herramientas de prueba y mejorar la interoperabilidad.

**Referencia:** OpenAPI Initiative. (2023). *OpenAPI Specification*. [OpenAPI Docs](https://www.openapis.org/).

---

## **Contextualización Teórica**  

### **Diseño de APIs y Documentación con OpenAPI**  
La documentación de APIs es crucial para garantizar que los desarrolladores puedan entender y utilizar los servicios web de manera efectiva. **OpenAPI** permite:  
- Generar documentación interactiva (Swagger UI).  
- Facilitar la integración con herramientas de prueba como Postman.  
- Mejorar la interoperabilidad entre sistemas heterogéneos.  

#### **Herramientas para Documentación y Pruebas de APIs**  
- **Swagger UI:** Interfaz interactiva para explorar y probar APIs.  
- **Postman:** Herramienta para realizar pruebas y validar respuestas.  
- **Insomnia:** Alternativa ligera para pruebas de APIs.  

**Referencia:** Richardson, L., & Amundsen, M. (2016). *RESTful Web APIs*. O'Reilly Media.  

---

### Validación de Datos con Bean Validation
La validación de datos es una parte fundamental en el desarrollo de APIs RESTful, ya que garantiza que los datos proporcionados por los usuarios cumplan con ciertos criterios antes de ser procesados. **Bean Validation** es un estándar de Java (Jakarta EE) que permite validar objetos de manera declarativa mediante anotaciones. Esto simplifica el proceso de validación y reduce la cantidad de código necesario.

#### **Validaciones Comunes**
A continuación, se presenta un listado de las anotaciones más comunes para validar datos en Java, junto con ejemplos simples:

1. **`@NotNull`**: Asegura que el campo no sea nulo.
   ```java
   @NotNull(message = "El nombre no puede ser nulo")
   private String nombre;
   ```

2. **`@NotBlank`**: Asegura que el campo no sea nulo ni esté vacío (ignora espacios en blanco).
   ```java
   @NotBlank(message = "El email no puede estar vacío")
   private String email;
   ```

3. **`@Size`**: Verifica que el tamaño del campo esté dentro de un rango específico.
   ```java
   @Size(min = 5, max = 50, message = "El nombre debe tener entre 5 y 50 caracteres")
   private String nombre;
   ```

4. **`@Min` y `@Max`**: Valida que un número esté dentro de un rango mínimo o máximo.
   ```java
   @Min(value = 18, message = "La edad mínima es 18 años")
   @Max(value = 99, message = "La edad máxima es 99 años")
   private int edad;
   ```

5. **`@Email`**: Verifica que el campo sea un correo electrónico válido.
   ```java
   @Email(message = "Debe ser un email válido")
   private String email;
   ```

6. **`@Pattern`**: Valida que el campo coincida con una expresión regular.
   ```java
   @Pattern(regexp = "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).*$", message = "La contraseña debe contener al menos un número, una letra minúscula y una mayúscula")
   private String password;
   ```

7. **`@Past` y `@Future`**: Verifica que una fecha sea pasada o futura.
   ```java
   @Past(message = "La fecha de nacimiento debe ser en el pasado")
   private LocalDate fechaNacimiento;

   @Future(message = "La fecha de vencimiento debe ser en el futuro")
   private LocalDate fechaVencimiento;
   ```

8. **`@Positive` y `@Negative`**: Valida que un número sea positivo o negativo.
   ```java
   @Positive(message = "El saldo debe ser positivo")
   private double saldo;

   @Negative(message = "El descuento debe ser negativo")
   private double descuento;
   ```

9. **`@Digits`**: Valida que un número tenga una cantidad específica de dígitos enteros y decimales.
   ```java
   @Digits(integer = 5, fraction = 2, message = "El precio debe tener hasta 5 dígitos enteros y 2 decimales")
   private BigDecimal precio;
   ```

10. **`@AssertTrue` y `@AssertFalse`**: Valida que un valor booleano sea verdadero o falso.
    ```java
    @AssertTrue(message = "Debe aceptar los términos y condiciones")
    private boolean terminosYCondiciones;
    ```

#### **Uso de `@Valid`**
Para activar las validaciones en un controlador Spring Boot, se utiliza la anotación `@Valid` junto con `@RequestBody`:
```java
@PostMapping("/usuarios")
public ResponseEntity<?> crearUsuario(@Valid @RequestBody UsuarioRequest usuario) {
    // Lógica para crear el usuario
    return ResponseEntity.status(HttpStatus.CREATED).body(usuario);
}
```

**Referencia:**

  - [Documentación de la API de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/apidocs/jakarta/validation/constraints/package-summary)  
  - [Introducción a la Validación de Beans en Jakarta EE](https://jakarta.ee/learn/docs/jakartaee-tutorial/current/beanvalidation/bean-validation/bean-validation.html)
  - [Especificación de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0)  

---

### Representación de Métodos HTTP en Spring Boot
Spring Boot utiliza anotaciones específicas para mapear métodos a operaciones HTTP. Estas anotaciones permiten definir cómo se manejan las solicitudes entrantes.

#### **Anotaciones Principales**
1. **`@GetMapping`**: Maneja solicitudes HTTP GET.
   ```java
   @GetMapping("/usuarios/{id}")
   public ResponseEntity<Usuario> obtenerUsuarioPorId(@PathVariable Long id) {
       // Lógica para obtener el usuario por ID
       return ResponseEntity.ok(usuario);
   }
   ```

2. **`@PostMapping`**: Maneja solicitudes HTTP POST.
   ```java
   @PostMapping("/usuarios")
   public ResponseEntity<Usuario> crearUsuario(@RequestBody Usuario usuario) {
       // Lógica para crear el usuario
       return ResponseEntity.status(HttpStatus.CREATED).body(usuario);
   }
   ```

3. **`@PutMapping`**: Maneja solicitudes HTTP PUT.
   ```java
   @PutMapping("/usuarios/{id}")
   public ResponseEntity<Usuario> actualizarUsuario(@PathVariable Long id, @RequestBody Usuario usuarioActualizado) {
       // Lógica para actualizar el usuario
       return ResponseEntity.ok(usuarioActualizado);
   }
   ```

4. **`@DeleteMapping`**: Maneja solicitudes HTTP DELETE.
   ```java
   @DeleteMapping("/usuarios/{id}")
   public ResponseEntity<Void> eliminarUsuario(@PathVariable Long id) {
       // Lógica para eliminar el usuario
       return ResponseEntity.noContent().build();
   }
   ```

5. **`@PatchMapping`**: Maneja solicitudes HTTP PATCH (actualizaciones parciales).
   ```java
   @PatchMapping("/usuarios/{id}")
   public ResponseEntity<Usuario> actualizarParcialmenteUsuario(@PathVariable Long id, @RequestBody Map<String, Object> camposActualizados) {
       // Lógica para actualizar parcialmente el usuario
       return ResponseEntity.ok(usuarioActualizado);
   }
   ```

---

### Tipos de Entrada de Datos en un Método
En Spring Boot, existen varias formas de recibir datos de entrada en un método de un controlador. Cada forma tiene su propósito específico y se utiliza con anotaciones diferentes.

#### **1. Datos en el Cuerpo de la Solicitud (`@RequestBody`)**
Se utiliza para recibir datos en formato JSON o XML en el cuerpo de la solicitud.
```java
@PostMapping("/usuarios")
public ResponseEntity<Usuario> crearUsuario(@RequestBody Usuario usuario) {
    // Lógica para crear el usuario
    return ResponseEntity.status(HttpStatus.CREATED).body(usuario);
}
```

#### **2. Datos en la URL (`@PathVariable`)**
Se utiliza para extraer valores de la URL.
```java
@GetMapping("/usuarios/{id}")
public ResponseEntity<Usuario> obtenerUsuarioPorId(@PathVariable Long id) {
    // Lógica para obtener el usuario por ID
    return ResponseEntity.ok(usuario);
}
```

#### **3. Datos en los Parámetros de Consulta (`@RequestParam`)**
Se utiliza para recibir datos como parámetros de consulta en la URL.
```java
@GetMapping("/usuarios")
public ResponseEntity<List<Usuario>> buscarUsuariosPorNombre(@RequestParam String nombre) {
    // Lógica para buscar usuarios por nombre
    return ResponseEntity.ok(usuarios);
}
```

#### **4. Datos en Encabezados (`@RequestHeader`)**
Se utiliza para recibir datos de los encabezados HTTP.
```java
@GetMapping("/usuarios")
public ResponseEntity<List<Usuario>> obtenerUsuarios(@RequestHeader("Authorization") String token) {
    // Lógica para verificar el token y devolver usuarios
    return ResponseEntity.ok(usuarios);
}
```

#### **5. Datos en Cookies (`@CookieValue`)**
Se utiliza para recibir datos almacenados en cookies.
```java
@GetMapping("/usuarios")
public ResponseEntity<List<Usuario>> obtenerUsuarios(@CookieValue("sessionId") String sessionId) {
    // Lógica para verificar la sesión y devolver usuarios
    return ResponseEntity.ok(usuarios);
}
```

#### **6. Datos en Formularios (`@ModelAttribute`)**
Se utiliza para recibir datos enviados desde formularios HTML.
```java
@PostMapping("/usuarios/formulario")
public ResponseEntity<Usuario> crearUsuarioDesdeFormulario(@ModelAttribute Usuario usuario) {
    // Lógica para crear el usuario
    return ResponseEntity.status(HttpStatus.CREATED).body(usuario);
}
```
---

## **Buenas prácticas y recomendaciones**  

1. **Consistencia en las Rutas:**  
   - Utilizar nombres de recursos en plural (e.g., `/users` en lugar de `/user`).
   - Evitar verbos en las rutas (e.g., `/users/{id}` en lugar de `/getUserById/{id}`).
   
2. **Uso de Códigos de Estado HTTP:**  
   - `200 OK`: Solicitud exitosa.
   - `201 Created`: Recurso creado.
   - `400 Bad Request`: Error en la solicitud del cliente.
   - `404 Not Found`: Recurso no encontrado.
   - `500 Internal Server Error`: Error en el servidor.

3. **Seguridad en APIs:**  
   - Implementar autenticación y autorización con **OAuth2** o **JWT**.
   - Proteger los datos sensibles con HTTPS.
   - Validar y sanitizar entradas para prevenir ataques **SQL Injection** y **XSS**.

**Referencia:** OWASP. (2021). *OWASP Top Ten*. [OWASP Docs](https://owasp.org/www-project-top-ten/).

---

## **Procedimiento**  
A continuación, se presentan un conjunto de pasos y requerimientos generales para la construcción de su API REST. Los estudiantes deben usar el diseño OpenAPI previamente elaborado como elemento base para la construcción de su API en Spring Boot:


### **1. Configuración del Proyecto Spring Boot**  

#### **Creación del Proyecto:**  
   - Ingresa al siguiente enlace: [https://start.spring.io/](https://start.spring.io/).  
   - Selecciona las siguientes dependencias:
     - **Spring Web**: Para construir aplicaciones web, incluyendo RESTful.
     - **Spring Boot DevTools**: Para desarrollo rápido.
     - **Validation**: Para hacer uso de los bean validation.
   - Descarga el proyecto y ábrelo en tu IDE favorito.

#### **Modificación del Proyecto:**  
   - En su archivo build.gradle adicione las siguientes dependencias:
  
  ```grovy
  implementation 'org.springframework.boot:spring-boot-starter-validation'
  implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.5'
  ```

#### **Estructura del Proyecto:**  
   - El proyecto generado incluye:  
     - `src/main/java`: Código fuente.  
     - `src/main/resources`: Archivos de configuración (`application.properties`, OpenAPI).  
     - `build.gradle`: Archivo Gradle para gestión de dependencias.  

---

### **2. Implementación de Operaciones REST**

#### **Creación de Estructuras para Representación de Datos**  
- Basado en su archivo de especificación OpenAPI, cree estructuras de código que representen los esquemas de información usados en cada una de sus operaciones.
- Adicione a cada uno de los campos de sus clases las validaciones que correspondan. 

**Ejemplo**  

```java

import co.edu.uniquindio.ingesis.domain.Rol;
import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.validation.constraints.*;

import java.time.LocalDate;
import java.util.Objects;

public record UserRegistrationRequest(
   @NotBlank(message = "El campo es requerido")
   @Email(message = "Debe ser un email válido")
   String email,
   @NotBlank(message = "El campo es requerido")
   @Pattern(regexp = "^(?=.*\\\\d)(?=.*[a-z])(?=.*[A-Z]).*$",message = "Debe contener al menos: un número, una letra minúscula y una mayúscula ")
   @Size(min = 8,message = "La longitud mínima es 8")
   String password,
   @NotBlank(message = "El campo es requerido")
   @Size(max = 100,message = "No debe exceder los 100 caracteres")
   String fullName,
   @NotNull(message = "La fecha no puede ser nula")
   @PastOrPresent(message = "La fecha no puede ser futura")
   @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
   LocalDate dateBirth,
   Rol rol) {

   public UserRegistrationRequest {
      rol = Objects.requireNonNullElse(rol,Rol.USER);
   }
}
```

#### **Implementación de la Clase Controlador**  
- Cree una clase controlador para su API, por ejemplo, `UserController`. Esta clase debe estar en un paquete específico, como `co.edu.uniquindio.ingesis.api.controllers`.

**Ejemplo:**  

```java
package co.edu.uniquindio.ingesis.api.controllers;

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/users")
public class UserController {

   
}
```

#### **Implementación de Operaciones**  
- Implemente uno a uno los métodos que componen su API.

**Ejemplo:**  

```java
@PostMapping
public ResponseEntity<UserResponse> createUser(@Valid @RequestBody UserRegistrationRequest request) {
   // Lógica para crear un usuario

   // Construir la URL del nuevo recurso
   URI location = ServletUriComponentsBuilder
            .fromCurrentRequest()
            .path("/{id}")
            .buildAndExpand(usuarioCreado.getId())
            .toUri();

   // Devolver la respuesta con el código 201 y la URL en la cabecera Location
   return ResponseEntity
            .created(location) // Establece el código 201 y la cabecera Location
            .body(usuarioCreado); // Devuelve el usuario en el cuerpo de la respuesta
}
```

o

```java
@PostMapping
public UserResponse createUser(@Valid @RequestBody UserRegistrationRequest request) {
   // Lógica para crear un usuario

   // Devolver la respuesta 
   return usuarioCreado;
}
```


Nota:
   - `@PostMapping` identifica el método HTTP a ser usado
   - `@Valid` le indica al sistema que debe validar los datos de entrada usando las anotaciones.
   - `@RequestBody` le indica al sistema que los datos de entrada para el registro del usuario están en el cuerpo de la solicitud.
   - La diferencia entre usar el DTO `UserResponse` y el `ResponseEntity`, es que al usar el Response podemos controlar el status code retornado, al retornar un DTO, la implementación es más simple, pero se retorna por defecto un status code 200.

---

### **3. Prueba de Operaciones**  

- Usa Postman o Swagger UI para enviar solicitudes a tu API.
- Inicia el servidor Spring Boot:  
```bash
./gradlew bootRun
```  
o Acceda al Main de su aplicación y ejecútelo.

- Accede a Swagger UI en: [http://localhost:8080/swagger-ui.html](http://localhost:8080/swagger-ui.html). 

---

### **4. Avance de proyecto**

Del proyecto final identifique al menos un recurso más diseñe el conjunto de operaciones para dicho recurso y posteriormente implemente las estructuras de representación de datos y la clase controladora para dichos recursos.

---

## **Referencias Bibliográficas**  

1. Fielding, R. T. (2000). *Architectural Styles and the Design of Network-based Software Architectures*. University of California, Irvine.  
2. RFC 7231 - *Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content*. [IETF RFC 7231](https://tools.ietf.org/html/rfc7231).  
3. OpenAPI Initiative. (2023). *OpenAPI Specification*. [OpenAPI Docs](https://www.openapis.org/).  
4. Richardson, L., & Amundsen, M. (2016). *RESTful Web APIs*. O'Reilly Media.  
5. OWASP. (2021). *OWASP Top Ten*. [OWASP Docs](https://owasp.org/www-project-top-ten/).
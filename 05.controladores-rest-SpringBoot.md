```
Programa de Ingenier√≠a de Sistemas y Computaci√≥n
Universidad del Quind√≠o

T√≠tulo: Implementaci√≥n de Controladores REST en Spring Boot
Duraci√≥n estimada: 120
Docentes: Carlos Andr√©s Florez, Christian Andr√©s Candela
Gu√≠a: 05
```
# Controladores REST en Spring Boot

## üéØ Objetivo
Implementar una API REST utilizando **Spring Boot**, basada en un dise√±o previo realizado con **OpenAPI**. Los estudiantes aprender√°n a traducir un dise√±o de API en una implementaci√≥n funcional en Java, aplicando principios de programaci√≥n empresarial y buenas pr√°cticas de desarrollo.

---

## Conceptos B√°sicos
Antes de iniciar con el dise√±o, es importante comprender algunos conceptos fundamentales:

#### 1. REST (Representational State Transfer)
Estilo arquitect√≥nico basado en principios como:
- Separaci√≥n cliente-servidor.
- Uso de recursos identificados por URIs.
- Uso de m√©todos HTTP est√°ndar (GET, POST, PUT, DELETE, PATCH, etc.).
- Implementaci√≥n de respuestas sin estado (**stateless**).
- Cacheabilidad y escalabilidad.

**Referencia:** Fielding, R. T. (2000). *Architectural Styles and the Design of Network-based Software Architectures*. University of California, Irvine.

#### 2. HTTP (Hypertext Transfer Protocol) 
Protocolo de comunicaci√≥n para la transferencia de datos en la web. Define m√©todos est√°ndar como:
- **GET**: Obtener informaci√≥n.
- **POST**: Crear un nuevo recurso.
- **PUT**: Actualizar un recurso existente.
- **PATCH**: Actualizar parcialmente un recurso.
- **DELETE**: Eliminar un recurso.

**Referencia:** RFC 7231 - *Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content*. [IETF RFC 7231](https://tools.ietf.org/html/rfc7231).

#### 3. OpenAPI
Especificaci√≥n abierta para describir APIs RESTful, permitiendo generar documentaci√≥n interactiva, facilitar la integraci√≥n con herramientas de prueba y mejorar la interoperabilidad.

**Referencia:** OpenAPI Initiative. (2023). *OpenAPI Specification*. [OpenAPI Docs](https://www.openapis.org/).

---

## Contextualizaci√≥n Te√≥rica  

### Dise√±o de APIs y Documentaci√≥n con OpenAPI
La documentaci√≥n de APIs es crucial para garantizar que los desarrolladores puedan entender y utilizar los servicios web de manera efectiva. **OpenAPI** permite:  
- Generar documentaci√≥n interactiva (Swagger UI).  
- Facilitar la integraci√≥n con herramientas de prueba como Postman.  
- Mejorar la interoperabilidad entre sistemas heterog√©neos.  

#### Herramientas para Documentaci√≥n y Pruebas de APIs 
- **Swagger UI:** Interfaz interactiva para explorar y probar APIs.  
- **Postman:** Herramienta para realizar pruebas y validar respuestas.  
- **Insomnia:** Alternativa ligera para pruebas de APIs.  

### API REST en Spring Boot
Spring Boot facilita la creaci√≥n de APIs REST mediante la utilizaci√≥n de anotaciones y convenciones que simplifican el desarrollo. Algunas caracter√≠sticas clave incluyen:
- **Controladores REST:** Clases anotadas con `@RestController` que manejan las solicitudes HTTP.
- **Serializaci√≥n/Deserializaci√≥n:** Conversi√≥n autom√°tica entre objetos Java y JSON/XML.
- **Manejo de Errores:** Respuestas de error estandarizadas mediante `@RestControllerAdvice`.
- **Validaci√≥n de Datos:** Uso de anotaciones como `@Valid` para validar los datos de entrada.

### Arquitectura de una Aplicaci√≥n REST

La arquitectura t√≠pica de una aplicaci√≥n REST en Spring Boot puede dividirse en varias capas, cada una con responsabilidades espec√≠ficas. A continuaci√≥n se presenta un diagrama que ilustra estas capas y sus interacciones:

```mermaid
graph TB
    subgraph "Presentation Layer"
        CA[üì± Client Application<br/>Web/Mobile Interface]
    end

    subgraph "API Layer"
        C[üéØ Controller<br/>Request Mapping<br/>Response Handling]
    end

    subgraph "Business Layer"
        S[‚öôÔ∏è Service<br/>Business Logic<br/>Data Processing]
    end

    subgraph "Data Access Layer"
        R[üóÉÔ∏è Repository<br/>Database Interactions<br/>Query Management]
        M[üìã Model/Entity<br/>Data Access Objects<br/>Domain Objects]
    end

    subgraph "Storage Layer"
        DB[(üóÑÔ∏è Database<br/>Persistent Storage)]
    end

    %% Connections with labeled arrows
    CA <==> |HTTP/REST APIs<br/>JSON Requests| C
    C <==> |Method Calls<br/>DTOs| S
    S <==> |Repository Pattern<br/>Business Entities| R
    R <==> |ORM/SQL<br/>Entity Mapping| M
    M <==> |Database Queries<br/>CRUD Operations| DB

    %% Styling
    classDef clientLayer fill:#FF6B6B,stroke:#E55555,stroke-width:2px,color:#fff
    classDef apiLayer fill:#4ECDC4,stroke:#45B7B8,stroke-width:2px,color:#fff
    classDef businessLayer fill:#45B7D1,stroke:#3498DB,stroke-width:2px,color:#fff
    classDef dataLayer fill:#96CEB4,stroke:#74B9FF,stroke-width:2px,color:#fff
    classDef storageLayer fill:#FFEAA7,stroke:#FDCB6E,stroke-width:2px,color:#2d3436

    class CA clientLayer
    class C apiLayer
    class S businessLayer
    class R,M dataLayer
    class DB storageLayer
```

El proceso de petici√≥n desde el cliente a los servicios del backend (Spring Boot) **sigue el modelo de arquitectura Cliente-Servidor** y se basa en el **protocolo HTTP** (o HTTPS). Aqu√≠ hay un resumen general del proceso:

- Un cliente (como un navegador web o una aplicaci√≥n m√≥vil) inicia una solicitud enviando una petici√≥n HTTP al servidor Spring Boot.

- En el servidor Spring Boot, las peticiones son manejadas por controladores. Los controladores est√°n anotados con `@Controller`, `@RestController` u otras anotaciones espec√≠ficas de Spring.

- El controlador realiza las operaciones necesarias en funci√≥n de la l√≥gica de negocio. Puede interactuar con servicios, acceder a bases de datos, realizar operaciones y preparar datos para enviar como respuesta.

- Generaci√≥n de la respuesta: Una vez que el controlador ha completado su l√≥gica, genera una respuesta. La respuesta generada por el controlador se env√≠a de vuelta al cliente a trav√©s del protocolo HTTP.

- El cliente (por ejemplo, un navegador web o una aplicaci√≥n m√≥vil) recibe la respuesta y realiza acciones seg√∫n la l√≥gica de la aplicaci√≥n.

En esta gu√≠a nos **enfocaremos en la implementaci√≥n de los controladores REST** y la configuraci√≥n de las rutas para manejar las solicitudes HTTP.

**Referencias:**

  - [Documentaci√≥n de Spring Boot sobre REST](https://spring.io/guides/gs/rest-service)
  - [Documentaci√≥n de la API de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/apidocs/jakarta/validation/constraints/package-summary)  
  - [Introducci√≥n a la Validaci√≥n de Beans en Jakarta EE](https://jakarta.ee/learn/docs/jakartaee-tutorial/current/beanvalidation/bean-validation/bean-validation.html)
  - [Especificaci√≥n de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0)  

---

## Buenas Pr√°cticas y Recomendaciones

1. **Especificaci√≥n OpenAPI:**  
   - Se recomienda crear primero la especificaci√≥n OpenAPI y luego implementar los controladores REST en Spring Boot bas√°ndose en dicha especificaci√≥n.
  
2. **Consistencia en las Rutas:**  
   - Utilizar nombres de recursos en plural (e.g., `/users` en lugar de `/user`).
   - Evitar verbos en las rutas (e.g., `/users/{id}` en lugar de `/getUserById/{id}`).
   
3. **Uso de C√≥digos de Estado HTTP:**  
   - `200 OK`: Solicitud exitosa.
   - `201 Created`: Recurso creado.
   - `400 Bad Request`: Error en la solicitud del cliente.
   - `409 Conflict`: Conflicto al crear un recurso (e.g., duplicado).
   - `404 Not Found`: Recurso no encontrado.
   - `500 Internal Server Error`: Error en el servidor.

4. **Seguridad en APIs:**  
   - Implementar autenticaci√≥n y autorizaci√≥n con **OAuth2** o **JWT**.
   - Validar y sanitizar entradas para prevenir ataques **SQL Injection** y **XSS**, para esto se recomienda usar las anotaciones de validaci√≥n de Jakarta Bean Validation.

**Referencia:** OWASP. (2021). *OWASP Top Ten*. [OWASP Docs](https://owasp.org/www-project-top-ten/).


---

## Procedimiento

Continuaremos trabajando en el proyecto final del espacio acad√©mico que iniciamos en las gu√≠as anteriores. Si no ha completado la gu√≠a anterior, por favor h√°galo antes de continuar con esta.

### 1. Configuraci√≥n inicial

Aseg√∫rese que tiene las siguientes dependencias a√±adidas en el archivo `build.gradle` del proyecto de Spring Boot:

```groovy
implementation 'org.springframework.boot:spring-boot-starter-web'
implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.9'
```

### 2. Crear un controlador simple

Cree una clase que se llame `GreetingController`. Para esto primero cree un paquete que se llame `co.edu.uniquindio.application.controllers`. A esta clase a√±√°dale la anotaci√≥n `@RestController`. Y haga que quede as√≠:

```java
package co.edu.uniquindio.application.controllers;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/greeting") // Prefijo com√∫n para todas las rutas del controlador
public class GreetingController {

    @GetMapping
    public String greet(){
        return "Hola, bienvenido a la aplicaci√≥n";
    }

    @GetMapping("/{name}")
    public String greetName(@PathVariable String name){
        return "Hola %s, bienvenido a la aplicaci√≥n".formatted(name);
    }
}
```

Con base en el c√≥digo anterior, podemos destacar lo siguiente:

- `@RestController`: Indica que esta clase es un controlador REST, lo que significa que manejar√° solicitudes HTTP y devolver√° respuestas en formato de texto o JSON.
- `@RequestMapping("/greeting")` para que todas las rutas comiencen con `/greeting`. Esto permite que las rutas queden m√°s organizadas y evitamos posibles conflictos con otras rutas en la aplicaci√≥n.
- `@GetMapping`: Especifica que los m√©todos dentro del controlador responder√°n a solicitudes **HTTP GET**.

El primer m√©todo se "activa" cuando un cliente hace una solicitud GET a la ra√≠z del controlador (`/greeting`). Por ejemplo: `http://localhost:8080/greeting` Devuelve el mensaje: "Hola, bienvenido a la aplicaci√≥n".

El segundo m√©todo se "activa" cuando un cliente hace una solicitud GET a la ra√≠z del controlador (`/greeting`), con un par√°metro en la URL. Por ejemplo: `http://localhost:8080/greeting/Carlos` Devuelve el mensaje "Hola Carlos, bienvenido a la aplicaci√≥n".

> **‚ö†Ô∏è NOTA:** El puerto por defecto es el 8080, pero puede variar seg√∫n la configuraci√≥n del proyecto en el archivo `application.properties`.

### 3. Crear archivo de pruebas HTTP

Para probar estas peticiones se recomienda crear un archivo en la carpeta `test/resources` que se llame por ejemplo `greeting.http` y puede quedar as√≠:

```bash
### Saludo
GET http://localhost:8080/greeting

### Saludo con un nombre dado como par√°metro
GET http://localhost:8080/greeting/Carlos
```

### 4. Probar las rutas

Pruebe cada ruta (para esto el servidor debe estar en ejecuci√≥n). Tambi√©n puede acceder a las rutas desde su navegador web.

### 5. Crear `UserController`

Cree una nueva clase que se llame `UserController`. En el paquete `co.edu.uniquindio.application.controllers`. A esta clase a√±√°dale la anotaci√≥n `@RestController`. As√≠:

```java
package co.edu.uniquindio.application.controllers;

import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {

}
```

### 6. Configurar endpoint

Adicione a dicha clase la url (endpoint) que reconocer√° el controlador para dar respuesta a las peticiones HTTP. Agregue lo siguiente debajo de `@RestController`:

```java
@RequestMapping("/api/users")
```

Esto significa que cuando se pida la url `http://localhost:8080/api/users` ser√° el controlador REST que estamos programando quien responda ante las peticiones realizadas.

### 7. Crear m√©todos CRUD

Cree un m√©todo para cada servicio de negocio de los usuarios que sea pertinente para la API. A manera de ejemplo se har√° el controlador implementando solamente los m√©todos para hacer un CRUD b√°sico en la entidad. Estos m√©todos se deben crear en la clase `UserController`:

```java
public void create(CreateUserDTO userDTO) throws Exception{
}

public void edit(EditUserDTO userDTO) throws Exception{
}

public void delete(String id) throws Exception{
}

public UserDTO get(String id) throws Exception{
}

public List<UserDTO> listAll(){
}
```

> **‚ö†Ô∏è NOTA:** Cada m√©todo del controlador debe corresponderse con un servicio de usuarios, manteniendo coherencia en el nombre, el tipo de retorno, las excepciones y los par√°metros. Para el intercambio de informaci√≥n en la API, es necesario utilizar DTOs que encapsulen los datos tanto de entrada como de salida. Estos DTOs deben ubicarse en el paquete `co.edu.uniquindio.application.dto`.

Un **DTO (Data Transfer Object)** es un objeto dise√±ado para transportar datos entre diferentes capas o componentes de una aplicaci√≥n. Su objetivo principal es encapsular la informaci√≥n que se intercambia, evitando exponer directamente la estructura interna de las entidades o modelos principales del sistema.

### 8. Crear DTOs con records

Cree los DTOs con los atributos correspondientes para cada m√©todo del CRUD. Un DTO es una clase que encapsula la informaci√≥n necesaria para cada requisito espec√≠fico de la aplicaci√≥n, separando la l√≥gica de negocio de la estructura de los datos que se intercambian entre el cliente y el servidor.

Dado que los DTO son objetos que no tienen l√≥gica y solo sirven para encapsular atributos, podemos hacer uso de los `record` de Java, entonces, por ejemplo el DTO `CreateUserDTO` se puede crear as√≠:

```java
package co.edu.uniquindio.application.dto;

public record CreateUserDTO(
    String name,
    String phone,
    String email,
    String password,
    String photoUrl,
    LocalDate dateBirth,
    Role role
) {
}
```

Para m√°s informaci√≥n sobre DTO y los `record` de Java:
- [Java Record Class y JDK 14](https://www.arquitecturajava.com/java-record-class-y-jdk-14/)
- [Data Transfer Object DTO](https://www.arquitecturajava.com/data-transfer-object-dto-un-concepto-clave/)
- [Patrones Arquitect√≥nicos - DTO](https://reactiveprogramming.io/blog/es/patrones-arquitectonicos/dto)

### 9. Agregar validaciones a DTOs

Es necesario realizar validaciones sobre cada uno de los atributos de los DTOs que se utilizan para registrar o actualizar informaci√≥n en el backend (por ejemplo, en una base de datos). Con estas validaciones aplicadas, el DTO `CreateUserDTO` quedar√≠a de la siguiente manera:

```java
package co.edu.uniquindio.application.dto;

import co.edu.uniquindio.application.model.Role;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Past;
import org.hibernate.validator.constraints.Length;
import java.time.LocalDate;

public record CreateUserDTO(
        @NotBlank @Length(max = 100) String name,
        @Length(max = 10) String phone,
        @NotBlank @Length(max = 50) @Email String email,
        @NotBlank @Length(min = 7, max = 20) String password,
        @Length(max = 300) String photoUrl,
        @NotNull @Past LocalDate dateBirth,
        @NotNull Role role
) {
}
```

El DTO debe tener las validaciones pertinentes para garantizar una buena integridad de los datos. Todos los DTO que represente un objeto que ser√° guardado en la base de datos debe tener las validaciones.

Para m√°s informaci√≥n sobre las anotaciones de validaciones:
  - [Documentaci√≥n de la API de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/apidocs/jakarta/validation/constraints/package-summary)  
  - [Introducci√≥n a la Validaci√≥n de Beans en Jakarta EE](https://jakarta.ee/learn/docs/jakartaee-tutorial/current/beanvalidation/bean-validation/bean-validation.html)
  - [Especificaci√≥n de Jakarta Bean Validation 3.0](https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0) 

### 10. Crear `EditUserDTO` y `UserDTO`

Cree el DTO `EditUserDTO` con las validaciones pertinentes. Adicionalmente, cree el DTO `UserDTO`, el cual ser√° utilizado para devolver informaci√≥n al cliente. Dado que este √∫ltimo DTO es una respuesta generada por el backend, no requiere validaciones, ya que los datos ya fueron previamente procesados y verificados.

El record `EditUserDTO`, puede estructurarse de la siguiente manera (se asume que el usuario no puede modificar su correo electr√≥nico ni su contrase√±a; para cambiar la contrase√±a, deber√° utilizar otro mecanismo):

```java
package co.edu.uniquindio.application.dto;

import co.edu.uniquindio.application.model.Role;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Past;
import org.hibernate.validator.constraints.Length;
import java.time.LocalDate;

public record EditUserDTO(
        @NotBlank @Length(max = 100) String name,
        @Length(max = 10) String phone,
        @Length(max = 300) String photoUrl,
        @NotNull @Past LocalDate dateBirth,
        @NotNull Role role
) {
}
```
El record `UserDTO` puede quedar as√≠:

```java
package co.edu.uniquindio.application.dto;

import co.edu.uniquindio.application.model.Role;

public record UserDTO(
        String id,
        String name,
        String email,
        String photoUrl,
        Role role
) {
}
```

> ‚ö†Ô∏è **IMPORTANTE:** Recuerde que los DTOs son objetos simples que no contienen l√≥gica de negocio. Y claramente cada DTO es diferente seg√∫n el contexto en el que se utilice.

### 11. Agregar anotaciones HTTP a m√©todos

Como se explic√≥ previamente, a cada m√©todo de `UserController` se le debe a√±adir una anotaci√≥n de acuerdo al m√©todo HTTP que deba dar respuesta. Para obtener se usa GET, para guardar o registrar se usa POST, para borrar DELETE y para modificar PUT.

```java
@PostMapping
public void create(CreateUserDTO userDTO) throws Exception{
}

@PutMapping
public void edit(EditUserDTO userDTO) throws Exception{
}

@DeleteMapping("/{id}")
public void delete(String id) throws Exception{
}

@GetMapping("/{id}")
public UserDTO get(String id) throws Exception{
    return null;
}

@GetMapping
public List<UserDTO> listAll(){
    return null;
}
```

### 12. Configurar par√°metros de entrada

Algunos m√©todos necesitan informaci√≥n que puede venir por la url o en el cuerpo de la petici√≥n. Para esos casos se debe indicar expl√≠citamente como va a llegar dicha informaci√≥n. Si es por la url se debe usar la anotaci√≥n `@PathVariable` y si es dentro del cuerpo de la petici√≥n se usa `@RequestBody`, para este √∫ltimo caso se recomienda que vaya acompa√±ado de la anotaci√≥n `@Valid` (para que tenga en cuenta las anotaciones de validaci√≥n de los atributos de los DTO).

Por ejemplo, si se desea obtener la informaci√≥n completa de un objeto, lo m√°s natural es enviar su identificador (`id`) y, con base en ese valor, retornar el resto de los datos. En este caso, el identificador puede enviarse en la URL. En cambio, para registrar un usuario es necesario proporcionar todos los datos que se quieren almacenar; por lo tanto, lo ideal es incluir esta informaci√≥n en el cuerpo de la petici√≥n.

Se puede implementar cada uno de los m√©todos del controlador REST haciendo uso de las anotaciones correspondientes, as√≠:

```java
@PostMapping
public void create(@Valid @RequestBody CreateUserDTO userDTO) throws Exception{
    
}

@PutMapping("/{id}") // Debe coincidir con el nombre del par√°metro (id)
public void edit(@PathVariable String id, @Valid @RequestBody EditUserDTO userDTO) throws Exception{

}

@DeleteMapping("/{id}") // Debe coincidir con el nombre del par√°metro (id)
public void delete(@PathVariable String id) throws Exception{
    
}

@GetMapping("/{id}") // Debe coincidir con el nombre del par√°metro (id)
public UserDTO get(@PathVariable String id) throws Exception{
    return null;
}

@GetMapping
public List<UserDTO> listAll(){
    return null;
}
```

> ‚ö†Ô∏è **Importante:** Los m√©todos del controlador no deben contener l√≥gica de negocio; su funci√≥n es √∫nicamente invocar los m√©todos definidos en la capa de servicios y transferirles los par√°metros correspondientes. En una pr√≥xima gu√≠a se implementar√° la l√≥gica de negocio en los servicios.

### 13. Implementar `ResponseEntity`

Como vimos en los m√©todos anteriores, algunos devuelven `void`, mientras que otros pueden lanzar excepciones al realizar operaciones de consulta, registro, u otras similares. Lo ideal es brindar siempre retroalimentaci√≥n al usuario: informar cuando todo funciona correctamente y tambi√©n cuando ocurre alg√∫n error. Para lograrlo, se puede utilizar el objeto `ResponseEntity`.

Por ejemplo, para la creaci√≥n de una nueva cuenta de usuario podemos modificarlo de la siguiente manera para que siempre haya una respuesta:

```java
@PostMapping
public ResponseEntity<ResponseDTO<String>> create(@Valid @RequestBody CreateUserDTO userDTO) throws Exception{
    //L√≥gica para crear el usuario
    return ResponseEntity.status(HttpStatus.CREATED).body(new ResponseDTO<>(false, "El registro ha sido exitoso"));
}
```

El objeto `ResponseEntity` nos permite asignar un c√≥digo de respuesta (`status`) y un contenido (`body`), para este caso estamos devolviendo un mensaje en formato JSON. El objetivo del DTO `ResponseDTO` es que todas las respuestas del servidor tengan **la misma estructura**.

### 14. Crear ResponseDTO

Cree `ResponseDTO` en el paquete `co.edu.uniquindio.application.dto` as√≠:

```java
package co.edu.uniquindio.application.dto;

public record ResponseDTO<T>(
    boolean error,
    T content
) {
}
```

Este `record` tiene un atributo de tipo `boolean` que indica si hay error o no, y otro atributo de tipo `T` (gen√©rico) que representar√° la respuesta como tal. Eso implica que el contenido de la respuesta puede tomar el valor que se requiera: un `String`, un objeto, una lista, etc.

### 15. Completar m√©todos con ResponseEntity

En este otro ejemplo, si existe el codigo de la cuenta de usuario retornamos el detalle de la misma, este detalle est√° en el objeto `UserDTO`:

```java
@GetMapping("/{id}")
public ResponseEntity<ResponseDTO<UserDTO>> get(@PathVariable String id) throws Exception{
    //L√≥gica para consular el usuario
    return ResponseEntity.ok(new ResponseDTO<>(false, null));
}
```

Este ser√≠a el c√≥digo para eliminar la cuenta de un usuario con el ajuste indicado anteriormente:

```java
@DeleteMapping("/{id}")
public ResponseEntity<ResponseDTO<String>> delete(@PathVariable String id) throws Exception{
    //L√≥gica para eliminar el usuario
    return ResponseEntity.ok(new ResponseDTO<>(false, "El usuario ha sido eliminado"));
}
```

Este ser√≠a el c√≥digo para listar todas las cuentas de los usuarios:

```java
@GetMapping
public ResponseEntity<ResponseDTO<List<UserDTO>>> listAll(){
    //L√≥gica para consultar todos los usuarios
    List<UserDTO> list = new ArrayList<>();
    return ResponseEntity.ok(new ResponseDTO<>(false, list));
}
```

Y finalmente, este ser√≠a el m√©todo de editar la informaci√≥n de la cuenta de un usuario:

```java
@PutMapping("/{id}")
public ResponseEntity<ResponseDTO<String>> edit(@PathVariable String id, @Valid @RequestBody EditUserDTO userDTO) throws Exception{
    //L√≥gica para editar el usuario
    return ResponseEntity.ok(new ResponseDTO<>(false, "El usuario ha sido actualizado"));
}
```

C√≥digos de estado HTTP: [HTTP Status Codes - MDN](https://developer.mozilla.org/es/docs/Web/HTTP/Status)

### 16. Manejo de excepciones

El manejo de las excepciones se debe programar en una nueva clase a la que llamaremos `RestExceptionHandler`. B√°sicamente esta clase mostrar√° un mensaje de error personalizado al usuario seg√∫n el tipo de excepci√≥n que arroje el servicio (cualquier servicio).

Dentro del paquete `co.edu.uniquindio.application.exceptions` cree la clase `RestExceptionHandler` con la anotaci√≥n `@RestControllerAdvice` as√≠:

```java
package co.edu.uniquindio.application.exceptions;

import co.edu.uniquindio.application.dto.ResponseDTO;
import co.edu.uniquindio.application.dto.ValidationDTO;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.servlet.resource.NoResourceFoundException;

import java.util.ArrayList;
import java.util.List;

@RestControllerAdvice
public class RestExceptionHandler {

    @ExceptionHandler(NoResourceFoundException.class)
    public ResponseEntity<ResponseDTO<String>> noResourceFoundExceptionHandler(NoResourceFoundException ex){
        return ResponseEntity.status(404).body( new ResponseDTO<>(true, "El recurso solicitado no existe") );
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ResponseDTO<String>> generalExceptionHandler (Exception e){
        return ResponseEntity.internalServerError().body( new ResponseDTO<>(true, e.getMessage()) );
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ResponseDTO<List<ValidationDTO>>> validationExceptionHandler ( MethodArgumentNotValidException ex ) {
        List<ValidationDTO> errors = new ArrayList<>();
        BindingResult results = ex.getBindingResult();
        for (FieldError e: results.getFieldErrors()) {
            errors.add( new ValidationDTO(e.getField(), e.getDefaultMessage()) );
        }
        return ResponseEntity.badRequest().body( new ResponseDTO<>(true, errors) );
    }
}
```

Cada m√©todo de la clase `RestExceptionHandler` responde a una excepci√≥n que puede ser arrojada en cualquier momento por cualquier servicio de negocio. Para diferenciar cada m√©todo se hace uso de la anotaci√≥n `@ExceptionHandler`. Ac√° una breve descripci√≥n de cada una:

- **`NoResourceFoundException`:** Excepci√≥n que se lanza cuando se trata de acceder a un recurso que no existe.
- **`Exception`:** Excepci√≥n general de Java. Lo ideal es tener excepciones propias para cada tipo de error y no ponerle a todas las excepciones simplemente `Exception`.
- **`MethodArgumentNotValidException`:** Excepci√≥n que se lanza cuando no se cumple alguna validaci√≥n puesta en los DTO (`@NotNull`, `@Email`, `@Max`, etc..). Para este caso debe crear un nuevo DTO con el nombre: `ValidationDTO`, este record debe debe tener dos `String`: field y message.

### 17. Crear archivo de pruebas para usuarios

Pruebe cada ruta, para esto, cree un nuevo archivo en la carpeta `test/resources` que se llame `users.http` y que tenga lo siguiente:

```bash
### Obtener todos los usuarios
GET http://localhost:8080/api/users

### Obtener un usuario por id (cambie 1 por el id del usuario que desea obtener)
GET http://localhost:8080/api/users/1

### Crear un usuario
POST http://localhost:8080/api/users
Content-Type: application/json

{
  "name": "Carlos",
  "phone": "121212",
  "email": "carlos@email.com",
  "password": "12345678",
  "photoUrl": "",
  "dateBirth": "2000-08-22",
  "role": "USER"
}

### Actualizar un usuario (cambie 1 por el id del usuario que desea actualizar)
PUT http://localhost:8080/api/users/1
Content-Type: application/json

{
  "name": "Carlos",
  "phone": "333333",
  "photoUrl": "mi foto",
  "dateBirth": "2000-08-22",
  "role": "USER"
}

### Eliminar un usuario (cambie 1 por el id del usuario que desea eliminar)
DELETE http://localhost:8080/api/users/1
```

> **‚ö†Ô∏è Importante:** Al probar cada ruta, aseg√∫rese de que el servidor est√© en ejecuci√≥n y de que los datos de prueba est√©n configurados correctamente. A√∫n no hay una funcionalidad implementada para manejar los datos pero puede observar las respuestas que genera el servidor.

### 18. Implementar filtros con `@RequestParam`

Modifique el m√©todo `listAll` de la clase `UserController` para que permita obtener usuarios filtrados por su nombre y por su tel√©fono (ambos opcionales). En este caso, se aconseja hacer algo as√≠:

```java
@GetMapping
public ResponseEntity<ResponseDTO<List<UserDTO>>> listAll(
        @RequestParam(required = false) String name,
        @RequestParam(required = false) String phone
) {
    //L√≥gica para consultar todos los usuarios con filtros
    List<UserDTO> list = new ArrayList<>();
    return ResponseEntity.ok(new ResponseDTO<>(false, list));
}
```

La anotaci√≥n `@RequestParam` se usa para enviar par√°metros por la url a la petici√≥n. En este caso, estas peticiones son v√°lidas:

```bash
### Obtener todos los usuarios que tienen un nombre dado
GET http://localhost:8080/api/users?name=Carlos

### Obtener todos los usuarios cuyo tel√©fono es 1234567
GET http://localhost:8080/api/users?phone=1234567

### Obtener todos los usuarios cuyo tel√©fono es 1234567 y su nombre es Carlos
GET http://localhost:8080/api/users?phone=1234567&name=Carlos
```

> **NOTA:** Se recomienda crear un DTO cuando se requieren m√∫ltiples filtros y utilizar `@ModelAttribute` en lugar de `@RequestParam` individuales, esto para mantener un c√≥digo m√°s limpio y organizado.

### 19. Crear controlador de alojamientos

Cree una nueva clase y programe un nuevo `@RestController` para manejar la parte de los alojamientos del proyecto final (puede empezar con el CRUD). Consulte las buenas pr√°cticas para crear las rutas y los c√≥digos de respuesta. Y haga el respectivo archivo de pruebas (`.http`).

### 20. Programar todos los RestControllers

Programe los dem√°s `@RestController` para todos requerimientos del proyecto final. Consulte las buenas pr√°cticas para crear las rutas y los c√≥digos de respuesta.

### 21. M√©todos de prueba

Para probar los diferentes m√©todos de los controladores podemos hacerlo de muchas maneras, en esta gu√≠a creamos archivos de prueba (`.http`) para cada uno de los m√©todos, pero tambi√©n se pueden utilizar herramientas como Postman, Insomnia o Swagger.

### 22. Guardar los cambios en Git

Aseg√∫rese de guardar todos los cambios realizados en el proyecto utilizando Git. Cree un commit con un mensaje descriptivo y luego haga push a su repositorio remoto.

---

## Para la pr√≥xima clase

- ¬øPara qu√© se usa `@CookieValue` y `@RequestHeader`  en los controladores REST?
- ¬øQu√© otras herramientas sirven para probar APIs? Investigue c√≥mo utilizar Postman o Insomnia para probar las APIs que ha creado.
- Profundice en el concepto de DTO (Data Transfer Object) y su importancia en la comunicaci√≥n entre capas de la aplicaci√≥n.
- Investigue sobre GraphQL, ¬øpara qu√© sirve? ¬øQu√© ventajas y desventajas tiene frente a REST?

---

## Referencias Bibliogr√°ficas 

1. Fielding, R. T. (2000). *Architectural Styles and the Design of Network-based Software Architectures*. University of California, Irvine.  
2. RFC 7231 - *Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content*. [IETF RFC 7231](https://tools.ietf.org/html/rfc7231).  
3. OpenAPI Initiative. (2023). *OpenAPI Specification*. [OpenAPI Docs](https://www.openapis.org/).  
4. Richardson, L., & Amundsen, M. (2016). *RESTful Web APIs*. O'Reilly Media.  
5. OWASP. (2021). *OWASP Top Ten*. [OWASP Docs](https://owasp.org/www-project-top-ten/).
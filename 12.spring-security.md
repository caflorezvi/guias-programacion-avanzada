```
Programa de Ingenier铆a de Sistemas y Computaci贸n
Universidad del Quind铆o

T铆tulo: Spring Security y JWT
Duraci贸n estimada: 240
Docentes: Carlos Andr茅s Florez, Christian Andr茅s Candela
Gu铆a: 12
```

# Spring Security y JWT

##  Objetivo

Implementar y configurar la seguridad de autenticaci贸n y autorizaci贸n de usuarios haciendo uso de Spring Security y JSON Web Token (JWT).

---

## Conceptos b谩sicos

- **Spring Boot:** Framework de desarrollo r谩pido para aplicaciones Java basadas en Spring.
- **Java:** Lenguaje de programaci贸n orientado a objetos.
- **Controladores REST:** Componentes que manejan las solicitudes HTTP en aplicaciones web.
- **Servicios de negocio:** L贸gica de negocio que maneja las operaciones y reglas de la aplicaci贸n.
- **JSON**: Formato de intercambio de datos ligero y f谩cil de leer.

---

## Contextualizaci贸n Te贸rica

Un aspecto fundamental en el desarrollo de aplicaciones web es la seguridad. En el backend es necesario implementar mecanismos que permitan identificar a los usuarios y validar que tengan los permisos adecuados para acceder a los recursos y servicios que ofrece la aplicaci贸n. En Spring se cuenta con un m贸dulo especializado para manejar la seguridad de las aplicaciones llamado **Spring Security**.

### Spring Security

Spring Security es el m贸dulo de seguridad de Spring Framework que permite construir aplicaciones en el backend que cumplan con los est谩ndares m铆nimos de seguridad. Spring Security aplica dos tipos de seguridad:

- **La autenticaci贸n** se refiere al proceso de verificaci贸n de la identidad de un usuario, en funci贸n de las credenciales proporcionadas. Un ejemplo com煤n es ingresar un nombre de usuario y una contrase帽a cuando inicia sesi贸n en un sitio web. Se refiere a la respuesta de la pregunta 驴Qui茅n eres?

- **La autorizaci贸n** se refiere al proceso de determinar si un usuario tiene el permiso adecuado para realizar una acci贸n en particular o leer datos en particular, suponiendo que el usuario se haya autenticado con 茅xito. Puede considerarse como una respuesta a la pregunta 驴Puede un usuario hacer/leer esto?

En Spring Security, cada petici贸n que se le hace al backend pasa por varios filtros, para evaluar su contenido y validar si el usuario tiene la autenticaci贸n correcta y la autorizaci贸n adecuada para acceder al servicio solicitado.

Internamente, los filtros que se eval煤an pasan (de forma muy resumida) por los siguientes:

![img](media/security1.png)

#### Proceso de Autenticaci贸n

Consideremos una aplicaci贸n web con Spring Security para autenticar usuarios. Cuando el usuario env铆a el formulario de inicio de sesi贸n:

1. `UsernamePasswordAuthenticationFilter` crea una instancia de `UsernamePasswordAuthenticationToken` con las credenciales
2. Esta instancia se pasa al `AuthenticationManager`, que delega la validaci贸n a un `AuthenticationProvider`
3. El `AuthenticationProvider` valida las credenciales, y si son correctas, crea una nueva instancia de `Authentication` con los datos del usuario
4. Si la autenticaci贸n es exitosa, el `AuthenticationManager` almacena la instancia en el contexto de seguridad y el usuario puede acceder a 谩reas protegidas
5. Si falla, se lanza una excepci贸n y el usuario es redirigido a la p谩gina de inicio de sesi贸n con un mensaje de error

El `AuthenticationProvider` es una interfaz que puede ser implementada por m煤ltiples proveedores, usando diferentes tipos de credenciales de usuario, como contrase帽as, tokens de seguridad o certificados digitales. Entre los proveedores m谩s importantes se encuentran:

- `OpenIDAuthenticationProvider`
- `JwtAuthenticationProvider`
- `OAuth2AuthenticationProvider`
- Y otros

### JWT

JSON Web Token (JWT) es un est谩ndar abierto (RFC-7519) basado en JSON para crear un token que sirva para enviar datos entre aplicaciones o servicios y garantizar que sean v谩lidos y seguros. Se considera a JWT como un m茅todo de autenticaci贸n sin estado.

El caso m谩s com煤n de uso de los JWT es para manejar la autenticaci贸n en aplicaciones m贸viles o web. Para esto:

1. El usuario se autentica enviando sus datos de inicio de sesi贸n al servidor.
2. El servidor genera el JWT y se lo env铆a a la aplicaci贸n cliente.
3. El token se almacena en el cliente (normalmente en el almacenamiento local o en una cookie).
4. En cada petici贸n posterior al servidor, que requiera autenticaci贸n, el cliente env铆a el token en el encabezado HTTP `Authorization` con el prefijo `Bearer`.
5. El servidor valida el token y, si es v谩lido, procesa la solicitud. Si no es v谩lido, devuelve un error.

#### Estructura de JWT

Los JWT tienen una estructura definida y est谩ndar basada en tres partes:

```
[Header].[Payload].[Signature]
```

- **Header (Encabezado):** contiene la lista de operaciones criptogr谩ficas que se aplican al JWT. Esta puede ser la t茅cnica de firma, informaci贸n de metadatos sobre el tipo de contenido, etc.

- **Payload (Carga 煤til):** contiene los datos reales que se transferir谩n mediante el token. Esta parte tambi茅n se conoce como la parte de "reclamaciones" del token JWT.

- **Signature (Firma):** se usa para verificar que el mensaje no se modific贸 en el camino. Esta firma se crea usando una clave secreta que solo el servidor conoce.

Las primeras dos partes (header y payload) son strings en **base64** creados a partir de dos JSON. La tercera parte (signature) toma las otras dos partes y las encripta usando un algoritmo de encriptaci贸n (como HMAC SHA-256) y una clave secreta.

#### Flujo de trabajo con JWT

En la siguiente imagen se muestra el flujo de trabajo t铆pico de autenticaci贸n y autorizaci贸n usando JWT:

![img](media/security2.png)

**Para m谩s informaci贸n:** [https://jwt.io/](https://jwt.io/) y [https://spring.io/projects/spring-security](https://spring.io/projects/spring-security)

---

## Precauciones y Recomendaciones

- Recuerde verificar que tiene instalado el JDK de Java (preferiblemente la versi贸n 21)
- Aseg煤rese de que tiene el servidor de base de datos en ejecuci贸n (MongoDB, MySQL, PostgreSQL, etc.)
- Use un cliente REST como Postman o Insomnia para probar los servicios del backend.

---

## Evaluaci贸n o Resultado

Se espera que el estudiante logre crear la configuraci贸n necesaria para a帽adir los m茅todos de autenticaci贸n y autorizaci贸n por medio de JWT.

---

## Procedimiento

Continuaremos trabajando en el proyecto final del espacio acad茅mico que iniciamos en las gu铆as anteriores. Si no ha completado la gu铆a anterior, por favor h谩galo antes de continuar con esta.

### 1. A帽adir dependencias

A帽adir las siguientes dependencias en el archivo `build.gradle`:

```groovy
implementation 'org.springframework.boot:spring-boot-starter-security'
implementation 'io.jsonwebtoken:jjwt-api:0.13.0'
runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.13.0'
runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.13.0'
```

La primera dependencia se encarga de a帽adir los aspectos b谩sicos de Spring Security, las tres siguientes est谩n relacionadas a JWT.

Elimine la dependencia de `spring-security-crypto` si ya la tiene, ya que `spring-boot-starter-security` la incluye.

> 锔 **Importante:** Recuerde sincronizar el proyecto con Gradle para que las nuevas dependencias se descarguen e instalen correctamente.

### 2. Verificar seguridad activada

Ejecute el proyecto e intente acceder a algunas de las rutas de la API. Deber铆a evidenciar un bloqueo total del acceso a la API, ya que se activa un mecanismo de seguridad que restringe cualquier solicitud no autorizada.

### 3. Crear paquete de seguridad

Crear un paquete con el nombre `co.edu.uniquindio.application.security` donde se alojar谩n las clases relacionadas con la seguridad de la aplicaci贸n y la configuraci贸n de Spring Security.

### 4. Crear clase `JWTUtils`

Dentro del paquete de seguridad, cree la clase `JWTUtils`:

```java
package co.edu.uniquindio.application.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.stereotype.Component;
import javax.crypto.SecretKey;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.Map;

@Component
public class JWTUtils {
    
    public String generateToken(String id, Map<String, String> claims) {
        Instant now = Instant.now();
        return Jwts.builder()
                .claims(claims)
                .subject(id)
                .issuedAt(Date.from(now))
                .expiration(Date.from(now.plus(1L, ChronoUnit.HOURS)))
                .signWith(getKey())
                .compact();
    }
    
    public Jws<Claims> parseJwt(String jwtString) throws ExpiredJwtException,
            UnsupportedJwtException, MalformedJwtException, IllegalArgumentException {
        JwtParser jwtParser = Jwts.parser().verifyWith(getKey()).build();
        return jwtParser.parseSignedClaims(jwtString);
    }
    
    private SecretKey getKey(){
        String secretKey = "secretsecretsecretsecretsecretsecretsecretsecret";
        byte[] secretKeyBytes = secretKey.getBytes();
        return Keys.hmacShaKeyFor(secretKeyBytes);
    }
}
```

Esta clase `JWTUtils` contiene m茅todos importantes como:
- Crear el token JWT con el m茅todo `generateToken()`.
- Firmar el token usando la clave secreta con el m茅todo `getKey()`.
- Validar y decodificar el token con el m茅todo `parseJwt()`.

Los m茅todos de esta clase son de utilidad para los mecanismos de autorizaci贸n as铆 como en los servicios de negocio de login y registro. En el m茅todo `generateToken()` podemos agregar m谩s informaci贸n al Token agregando m谩s `claim()` (clave-valor).

> 锔 **NOTA:** Haga que la clave secreta venga dada desde el archivo `application.properties` usando `@Value("${jwt.secret}")` para que no est茅 hardcodeada en el c贸digo. La clave debe tener al menos 32 caracteres.

### 5. Crear clase `JWTFilter`

En el mismo paquete agregue la clase `JWTFilter`:

```java
package co.edu.uniquindio.application.security;

import co.edu.uniquindio.application.services.impl.UserDetailsServiceImpl;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JWTFilter extends OncePerRequestFilter{
    
    private final JWTUtils jwtUtil;
    private final UserDetailsServiceImpl userDetailsService;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException {
        
        // Obtener el token del header de la solicitud
        String token = getToken(request);
        
        // Si no hay token, continuar con la cadena de filtros
        if (token == null) {
            chain.doFilter(request, response);
            return;
        }
        
        try {
            // Validar el token y obtener el payload
            Jws<Claims> payload = jwtUtil.parseJwt(token);
            String username = payload.getPayload().getSubject();
            
            // Si el usuario no est谩 autenticado, crear un nuevo objeto de autenticaci贸n
            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                
                // Crear un objeto UserDetails con el nombre de usuario y el rol
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                
                // Crear un objeto de autenticaci贸n y establecerlo en el contexto de seguridad
                UsernamePasswordAuthenticationToken authentication = new 
                        UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                        );
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            // Si el token no es v谩lido, enviar un error 401
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Unauthorized");
            return;
        }
        
        // Continuar con la cadena de filtros
        chain.doFilter(request, response);
    }
    
    private String getToken(HttpServletRequest req) {
        String header = req.getHeader("Authorization");
        return header != null && header.startsWith("Bearer ") ? header.replace("Bearer ", "") : null;
    }
}
```

Esta clase trabaja como un **middleware** que intercepta cada solicitud HTTP entrante para validar el token JWT. El m茅todo `doFilterInternal()` captura el token JWT que viene en el header de la solicitud HTTP. Si no hay token, se contin煤a con la cadena de filtros sin hacer nada. Si hay un token, se valida usando la clase `JWTUtils`. Si el token no es v谩lido, se env铆a un error 401 (no autorizado) en la respuesta.

Adem谩s, si el token es v谩lido, se crea un objeto de autenticaci贸n y se establece en el **contexto de seguridad de Spring** para que pueda ser utilizado en los servicios de negocio.

Para m谩s informaci贸n sobre [SecurityContextHolder](https://medium.com/@CodeWithTech/understanding-securitycontext-and-securitycontextholder-in-spring-security-e8ec9c030819) y [OncePerRequestFilter](https://www.baeldung.com/spring-onceperrequestfilter) puede visitar los enlaces.

### 6. Crear clase `JwtAuthenticationEntryPoint`

En el mismo paquete agregue la clase `JwtAuthenticationEntryPoint`:

```java
package co.edu.uniquindio.application.security;

import co.edu.uniquindio.application.dto.ResponseDTO;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;
import org.springframework.security.core.AuthenticationException;

import java.io.IOException;

@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException {

        ResponseDTO<String> dto = new ResponseDTO<>(true, "No tienes permisos para acceder a este recurso");
        response.setContentType("application/json");
        response.setStatus(403);
        response.getWriter().write(new ObjectMapper().writeValueAsString(dto));
        response.getWriter().flush();
        response.getWriter().close();
    }
}
```

En esta clase se lanza la excepci贸n asociada a la solicitud del usuario (en el m茅todo `commence`). Si la solicitud es v谩lida este m茅todo no se invoca, s贸lo se invoca si hay excepciones que se le debe notificar al usuario como cuando el token es incorrecto, est谩 vencido o es requerido.

> **锔 Importante:** Debe tener el DTO `ResponseDTO` creado en el paquete `co.edu.uniquindio.application.dto`, el cual se cre贸 en gu铆as anteriores.

### 7. Crear UserDetailsServiceImpl

En el paquete `co.edu.uniquindio.application.service.impl` cree la clase `UserDetailsServiceImpl`:

```java
package co.edu.uniquindio.application.services.impl;

import co.edu.uniquindio.application.model.User;
import co.edu.uniquindio.application.repositories.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String id) throws UsernameNotFoundException {

        User user = userRepository.findById(id)
                .orElseThrow(() -> new UsernameNotFoundException("Usuario no encontrado"));
        
        List<GrantedAuthority> authorities = new ArrayList<>();
        authorities.add(new SimpleGrantedAuthority(user.getRole().name()));

        return new org.springframework.security.core.userdetails.User(
                user.getId(),
                user.getPassword(),
                authorities
        );
    }
}
```

Esta clase valida que el usuario presente en el token JWT exista en el sistema y permite extraer su rol y dem谩s datos necesarios. Spring Security utiliza el objeto `UserDetails` para representar al usuario autenticado y mantener su informaci贸n en el contexto de seguridad durante las peticiones.

> **锔 Importante:** Dado que la clase `User` ya existe en el proyecto, y Spring Security tambi茅n tiene una clase llamada `User`, para evitar conflictos de nombres, se ha importado la clase `User` de Spring Security con su ruta completa en el retorno del m茅todo `loadUserByUsername`.


### 8. Crear SecurityConfig

Crear una nueva clase con el nombre `SecurityConfig` en el paquete `co.edu.uniquindio.application.config`:

```java
package co.edu.uniquindio.application.config;

import co.edu.uniquindio.application.security.JwtAuthenticationEntryPoint;
import co.edu.uniquindio.application.security.JWTFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JWTFilter jwtFilter;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // Configura la seguridad HTTP para la aplicaci贸n
        http
                .csrf(AbstractHttpConfigurer::disable)
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(req -> req
                        .requestMatchers("/api/auth/**").permitAll()
                        .anyRequest().authenticated()
                )
                .exceptionHandling(ex -> ex.authenticationEntryPoint(new JwtAuthenticationEntryPoint()))
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        // Configura las pol铆ticas de CORS para permitir solicitudes desde el frontend
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(List.of("*"));
        config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        config.setAllowedHeaders(List.of("*"));
        config.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        // Permite codificar y verificar contrase帽as utilizando BCrypt
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration)
            throws Exception {
        // Proporciona un AuthenticationManager para la autenticaci贸n de usuarios
        return configuration.getAuthenticationManager();
    }
}
```

Esta es la clase principal de configuraci贸n de Spring Security. Se destaca el m茅todo `securityFilterChain()`, que tiene la responsabilidad de hacer la comprobaci贸n de autenticaci贸n del usuario para indicar si se puede proceder con la solicitud o no.

De este m茅todo se destaca la siguiente parte:

```java
http.authorizeHttpRequests(req -> req
    .requestMatchers("/api/auth/**").permitAll()
    .anyRequest().authenticated()
);
```

Esta l铆nea de c贸digo indica que todas las solicitudes que comiencen con `/api/auth/` son permitidas, incluso las de swagger (`/swagger-ui/**`, `/v3/api-docs/**`) deber铆an ser permitidas, pero las dem谩s solo son permitidas si el usuario est谩 autenticado con un token. Para m谩s informaci贸n se recomienda [visitar este art铆culo](https://medium.com/@espinozajge/protegiendo-tu-aplicaci%C3%B3n-web-con-spring-security-y-autenticaci%C3%B3n-basada-en-tokens-jwt-1321cbe4c4c3).

> **锔 Importante:** Estas rutas deben coincidir con las definidas en los diferentes `@RestController`. Verifique bien las rutas que desea proteger y las que no.

### 9. Ejemplos de configuraci贸n de rutas

A manera de ejemplo, si queremos que cualquier usuario pueda acceder a cualquier ruta tenga o no la autorizaci贸n, podemos escribir:

```java
http.authorizeHttpRequests(req -> req.anyRequest().permitAll());
```

O si queremos que todas las rutas est茅n protegidas (se requiere autenticaci贸n):

```java
http.authorizeHttpRequests(req -> req.anyRequest().authenticated());
```

Tambi茅n se pueden validar aspectos de la ruta relacionados con el m茅todo HTTP correspondiente:

```java
http.authorizeHttpRequests(req -> req
    .requestMatchers(HttpMethod.POST, "/api/users").permitAll()
);
```

Incluso, y lo m谩s importante, se puede restringir el acceso a las rutas seg煤n el rol del usuario definido en el token de autenticaci贸n:

```java
http.authorizeHttpRequests(req -> req
    .requestMatchers("/api/bookings/**").hasAuthority("ROLE_GUEST")
);
```

> **锔 Importante:** Puede ser necesario agregar `.requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()` para permitir el acceso a Swagger UI y as铆 poder probar los endpoints desde all铆.

### 10. Modificar registro de usuarios

Dado que JWT requiere de cifrado de contrase帽as, modifique el m茅todo de registro de usuarios nuevos de la clase `UsuarioServicioImpl` para que se use `PasswordEncoder`:

```java
// Se mapea el DTO a una entidad
User newUser = userMapper.toEntity(userDTO);

// Se codifica la contrase帽a
newUser.setPassword(passwordEncoder.encode(userDTO.password()));
```

Para cifrar la contrase帽a se hace uso del m茅todo `encode` de `passwordEncoder`.

### 11. A帽adir `PasswordEncoder` al servicio

A la clase `UserServiceImpl` a帽ada el atributo `passwordEncoder`:

```java
private final PasswordEncoder passwordEncoder;
```

Dado que la clase `UserServiceImpl` ya tiene el constructor con `@RequiredArgsConstructor`, no es necesario modificar nada m谩s. Spring inyectar谩 autom谩ticamente la instancia de `PasswordEncoder` definida en la clase `SecurityConfig`.

### 12. Implementar servicio de login

Finalmente, el servicio de negocio para hacer login (iniciar sesi贸n):

```java
public TokenDTO login(LoginDTO loginDTO) throws Exception {
    Optional<User> optionalUser = userRepository.findByEmail(loginDTO.email());

    if(optionalUser.isEmpty()){
        throw new Exception("El usuario no existe");
    }

    User user = optionalUser.get();

    // Verificar si la contrase帽a es correcta usando el PasswordEncoder
    if(!passwordEncoder.matches(loginDTO.password(), user.getPassword())){
        throw new Exception("El usuario no existe");
    }

    String token = jwtUtils.generateToken(user.getId(), createClaims(user));
    return new TokenDTO(token);
}

private Map<String, String> createClaims(User user){
    return Map.of(
        "email", user.getEmail(),
        "name", user.getName(),
        "role", "ROLE_"+user.getRole().name()
    );
}
```

En este m茅todo se valida que el usuario exista y que la contrase帽a sea correcta usando el m茅todo `matches` de `PasswordEncoder`. Si todo es correcto, se genera el token JWT usando la clase `JWTUtils` y se retorna en un DTO llamado `TokenDTO`. Este token debe ser almacenado en el frontend para enviarlo en las solicitudes que requieran autenticaci贸n.

> **锔 NOTA:** Es necesario crear un nuevo DTO con el nombre `TokenDTO`, este DTO s贸lo tiene el atributo `token` de tipo `String`.

### 13. Acceder al ID del usuario autenticado

Si necesita acceder al ID del usuario que est谩 almacenado en el token de autenticaci贸n de la solicitud dentro de un m茅todo en los servicios de negocio, puede hacerlo de la siguiente manera:

```java
User user = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
String idUser = user.getUsername();
```

Esto nos devuelve el ID y con 茅l podemos verificar cosas relacionadas a la seguridad. Por ejemplo, con esto podemos validar que un usuario solo pueda editar sus propios datos personales, no los de otra persona.

`SecurityContextHolder` es una clase de Spring Security que permite acceder al **contexto de seguridad actual**, donde se almacena la informaci贸n del usuario autenticado. Este objeto se inicializa en el filtro `JWTFilter` que creamos anteriormente. Por lo tanto, siempre que se haga una solicitud con un token v谩lido, este objeto tendr谩 la informaci贸n del usuario.

Tenga en cuenta que debe agregar los siguientes imports a la clase que lo requiera:

```java
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;
```

Puede crear un m茅todo en `AuthService` para obtener el ID del usuario autenticado (usando el c贸digo anterior) y reutilizarlo en los servicios de negocio donde lo necesite.


### 14. Probar endpoints que requieren autenticaci贸n

Para probar los endpoints que requieren autenticaci贸n, se puede utilizar una herramienta como Postman, Insomnia o incluso Swagger UI si lo tiene configurado. En la herramienta que use, debe agregar un header a la solicitud con el nombre `Authorization` y el valor `Bearer <token>`, donde `<token>` es el token JWT que obtuvo al iniciar sesi贸n.

Por ejemplo, en este caso se usar谩n archivos `.http` de IntelliJ IDEA. Cree un archivo llamado `auth.http` en la carpeta `src/test/resources` con el siguiente contenido:

```bash
### Login
POST http://localhost:8080/api/auth/login
Content-Type: application/json

{
  "email": "pepito@gmail.com",
  "password": "12345678"
}
```

Cabe destacar que debe existir un usuario con ese correo y contrase帽a en la base de datos para que la solicitud sea exitosa, de lo contrario, debe cambiar los datos por los de un usuario que exista en su base de datos.

**Ejecute el proyecto de Spring Boot** y luego ejecute la solicitud de login. Si todo est谩 correcto, deber铆a obtener una respuesta similar a esta:

```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
}
```

> 锔 **Nota:** Si lo desea, puede acceder a [https://www.jwt.io](https://www.jwt.io) para decodificar el token y ver su contenido. Copie el valor del token (la cadena larga que empieza con `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`) y p茅guelo en el campo "Encoded Value" de la p谩gina. De inmediato ver谩 el contenido del token en la secci贸n "Decoded".

Copie el valor del token y 煤selo para probar otros endpoints que requieran autenticaci贸n. Por ejemplo, si tiene un endpoint para actualizar los datos del usuario, agregue el header `Authorization` con as铆:

```bash
### Actualizar un usuario
PUT http://localhost:8080/api/users/<id_user>
Content-Type: application/json
Authorization: Bearer <token>

{
  "name": "Carlos",
  "phone": "333333",
  "photoUrl": "mi foto",
  "dateBirth": "2000-08-22"
}
```

Aseg煤rese de reemplazar `<id_user>` por el ID real del usuario que desea actualizar y `<token>` por el token JWT que obtuvo al iniciar sesi贸n. Si todo est谩 correcto, deber铆a obtener una respuesta con un c贸digo 200 y los datos actualizados del usuario.

### 15. Usar variable de entorno para el token

Incluso, para evitar copiar y pegar el token cada vez que quiera probar un endpoint, puede crear una variable de entorno y usarla en el header de la solicitud. De esta manera, solo necesita actualizar la variable cuando inicie sesi贸n nuevamente. 

En el archivo `auth.http`, modifique la solicitud de login para que guarde el token en una variable llamada `auth_token`, as铆:

{% raw %}
```bash
### Login
POST http://localhost:8080/api/auth/login
Content-Type: application/json

{
  "email": "pepito@gmail.com",
  "password": "12345678"
}

> {% client.global.set("auth_token", response.body.token); %}
```
{% endraw %}

Luego, en las solicitudes que requieran autenticaci贸n, puede usar la variable `auth_token` en el header `Authorization`, as铆:

```bash
### Actualizar un usuario
PUT http://localhost:8080/api/users/<id_user>
Content-Type: application/json
Authorization: Bearer {{auth_token}}

{
  "name": "Carlos",
  "phone": "333333",
  "photoUrl": "mi foto",
  "dateBirth": "2000-08-22"
}
```

Ejecute la solicitud de login primero para que la variable `auth_token` se actualice con el nuevo token. Luego, puede ejecutar la solicitud de actualizaci贸n del usuario y deber铆a funcionar correctamente.

### 16. Control de versiones

Recuerde hacer commit de sus avances en el repositorio de git y subirlos a GitHub.

---

## Para la pr贸xima clase

- Qu茅 es Oauth2 y OpenID.
- Qu茅 servicios de autenticaci贸n existen en la nube (Firebase, Auth0, Okta, etc.) y por qu茅 delegarlos a un tercero.
- Investigar qu茅 es Angular, programaci贸n funcional y programaci贸n reactiva.
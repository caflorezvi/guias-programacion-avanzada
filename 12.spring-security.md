```
Programa de Ingenier√≠a de Sistemas y Computaci√≥n
Universidad del Quind√≠o

T√≠tulo: Spring Security y JWT
Duraci√≥n estimada: 240
Docentes: Carlos Andr√©s Florez, Christian Andr√©s Candela
Gu√≠a: 12
```

# Spring Security y JWT

## üéØ Objetivo

Implementar y configurar la seguridad de autenticaci√≥n y autorizaci√≥n de usuarios haciendo uso de Spring Security y JSON Web Token (JWT).

---

## Conceptos b√°sicos

Bases de datos relacionales, Java, Spring Boot.

---

## Contextualizaci√≥n Te√≥rica

Un aspecto fundamental en el desarrollo de aplicaciones web es la seguridad. En el backend es necesario implementar mecanismos que permitan identificar a los usuarios y validar que tengan los permisos adecuados para acceder a los recursos y servicios que ofrece la aplicaci√≥n. En Spring se cuenta con un m√≥dulo especializado para manejar la seguridad de las aplicaciones llamado **Spring Security**.

### Spring Security

Spring Security es el m√≥dulo de seguridad de Spring Framework que permite construir aplicaciones en el backend que cumplan con los est√°ndares m√≠nimos de seguridad. Spring Security aplica dos tipos de seguridad:

- **La autenticaci√≥n** se refiere al proceso de verificaci√≥n de la identidad de un usuario, en funci√≥n de las credenciales proporcionadas. Un ejemplo com√∫n es ingresar un nombre de usuario y una contrase√±a cuando inicia sesi√≥n en un sitio web. Se refiere a la respuesta de la pregunta ¬øQui√©n eres?

- **La autorizaci√≥n** se refiere al proceso de determinar si un usuario tiene el permiso adecuado para realizar una acci√≥n en particular o leer datos en particular, suponiendo que el usuario se haya autenticado con √©xito. Puede considerarse como una respuesta a la pregunta ¬øPuede un usuario hacer/leer esto?

En Spring Security, cada petici√≥n que se le hace al backend pasa por varios filtros, para evaluar su contenido y validar si el usuario tiene la autenticaci√≥n correcta y la autorizaci√≥n adecuada para acceder al servicio solicitado.

Internamente, los filtros que se eval√∫an pasan (de forma muy resumida) por los siguientes:

![img](media/security1.png)

#### Proceso de Autenticaci√≥n

Consideremos una aplicaci√≥n web con Spring Security para autenticar usuarios. Cuando el usuario env√≠a el formulario de inicio de sesi√≥n:

1. `UsernamePasswordAuthenticationFilter` crea una instancia de `UsernamePasswordAuthenticationToken` con las credenciales
2. Esta instancia se pasa al `AuthenticationManager`, que delega la validaci√≥n a un `AuthenticationProvider`
3. El `AuthenticationProvider` valida las credenciales, y si son correctas, crea una nueva instancia de `Authentication` con los datos del usuario
4. Si la autenticaci√≥n es exitosa, el `AuthenticationManager` almacena la instancia en el contexto de seguridad y el usuario puede acceder a √°reas protegidas
5. Si falla, se lanza una excepci√≥n y el usuario es redirigido a la p√°gina de inicio de sesi√≥n con un mensaje de error

El `AuthenticationProvider` es una interfaz que puede ser implementada por m√∫ltiples proveedores, usando diferentes tipos de credenciales de usuario, como contrase√±as, tokens de seguridad o certificados digitales. Entre los proveedores m√°s importantes se encuentran:

- `OpenIDAuthenticationProvider`
- `JwtAuthenticationProvider`
- `OAuth2AuthenticationProvider`
- Y otros

### JWT

JSON Web Token (JWT) es un est√°ndar abierto (RFC-7519) basado en JSON para crear un token que sirva para enviar datos entre aplicaciones o servicios y garantizar que sean v√°lidos y seguros. Se considera a JWT como un m√©todo de autenticaci√≥n sin estado.

El caso m√°s com√∫n de uso de los JWT es para manejar la autenticaci√≥n en aplicaciones m√≥viles o web. Para esto:

1. El usuario se autentica enviando sus datos de inicio de sesi√≥n al servidor
2. El servidor genera el JWT y se lo env√≠a a la aplicaci√≥n cliente
3. En cada petici√≥n, el cliente env√≠a este token que el servidor usa para verificar que el usuario est√© correctamente autenticado y saber qui√©n es

#### Estructura de JWT

Los JWT tienen una estructura definida y est√°ndar basada en tres partes:

```
[Header].[Payload].[Signature]
```

- **Header (Encabezado):** contiene la lista de operaciones criptogr√°ficas que se aplican al JWT. Esta puede ser la t√©cnica de firma, informaci√≥n de metadatos sobre el tipo de contenido, etc.

- **Payload (Carga √∫til):** contiene los datos reales que se transferir√°n mediante el token. Esta parte tambi√©n se conoce como la parte de "reclamaciones" del token JWT.

- **Signature (Firma):** se usa para verificar que el mensaje no se modific√≥ en el camino.

Las primeras dos partes (header y payload) son strings en **base64** creados a partir de dos JSON. La tercera parte (signature) toma las otras dos partes y las encripta usando un algoritmo (normalmente SHA-256).

![img](media/security2.png)

**Para m√°s informaci√≥n:** https://jwt.io/ y https://spring.io/projects/spring-security

---

## Precauciones y Recomendaciones

- Recuerde verificar que tiene instalado el JDK de Java (preferiblemente la versi√≥n 21)
- Aseg√∫rese de que tiene el servidor de base de datos en ejecuci√≥n (MongoDB, MySQL, PostgreSQL, etc.)
- Use un cliente REST como Postman o Insomnia para probar los servicios del backend.

---

## Evaluaci√≥n o Resultado

Se espera que el estudiante logre crear la configuraci√≥n necesaria para a√±adir los m√©todos de autenticaci√≥n y autorizaci√≥n por medio de JWT.

---

## Procedimiento

Continuaremos trabajando en el proyecto final del espacio acad√©mico que iniciamos en las gu√≠as anteriores. Si no ha completado la gu√≠a anterior, por favor h√°galo antes de continuar con esta.

### 1. A√±adir dependencias

A√±adir las siguientes dependencias en el archivo `build.gradle`:

```groovy
implementation 'org.springframework.boot:spring-boot-starter-security'
implementation 'io.jsonwebtoken:jjwt-api:0.13.0'
runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.13.0'
runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.13.0'
```

La primera dependencia se encarga de a√±adir los aspectos b√°sicos de Spring Security, las tres siguientes est√°n relacionadas a JWT.

Elimine la dependencia de `spring-security-crypto` si ya la tiene, ya que `spring-boot-starter-security` la incluye.

> ‚ö†Ô∏è **Importante:** Recuerde sincronizar el proyecto con Gradle para que las nuevas dependencias se descarguen e instalen correctamente.

### 2. Verificar seguridad activada

Ejecute el proyecto e intente acceder a algunas de las rutas de la API. Deber√≠a evidenciar un bloqueo total del acceso a la API, ya que se activa un mecanismo de seguridad que restringe cualquier solicitud no autorizada.

### 3. Crear paquete de seguridad

Crear un paquete con el nombre `co.edu.uniquindio.application.security` donde se alojar√°n las clases relacionadas con la seguridad de la aplicaci√≥n y la configuraci√≥n de Spring Security.

### 4. Crear clase `JWTUtils`

Dentro del paquete de seguridad, cree la clase `JWTUtils`:

```java
package co.edu.uniquindio.application.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.stereotype.Component;
import javax.crypto.SecretKey;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.Map;

@Component
public class JWTUtils {
    
    public String generateToken(String id, Map<String, String> claims) {
        Instant now = Instant.now();
        return Jwts.builder()
                .claims(claims)
                .subject(id)
                .issuedAt(Date.from(now))
                .expiration(Date.from(now.plus(1L, ChronoUnit.HOURS)))
                .signWith(getKey())
                .compact();
    }
    
    public Jws<Claims> parseJwt(String jwtString) throws ExpiredJwtException,
            UnsupportedJwtException, MalformedJwtException, IllegalArgumentException {
        JwtParser jwtParser = Jwts.parser().verifyWith(getKey()).build();
        return jwtParser.parseSignedClaims(jwtString);
    }
    
    private SecretKey getKey(){
        String secretKey = "secretsecretsecretsecretsecretsecretsecretsecret";
        byte[] secretKeyBytes = secretKey.getBytes();
        return Keys.hmacShaKeyFor(secretKeyBytes);
    }
}
```

Esta clase `JWTUtils` contiene m√©todos importantes como:
- Crear el token JWT con el m√©todo `generateToken()`
- Firmar el token usando la clave secreta con el m√©todo `getKey()`
- Validar y decodificar el token con el m√©todo `parseJwt()`

Los m√©todos de esta clase son de utilidad para los mecanismos de autorizaci√≥n as√≠ como en los servicios de negocio de login y registro. En el m√©todo `generateToken()` podemos agregar m√°s informaci√≥n al Token agregando m√°s `claim()` (clave-valor).

> ‚ö†Ô∏è **NOTA:** Haga que la clave secreta venga dada desde el archivo `application.properties` usando `@Value("${jwt.secret}")` para que no est√© hardcodeada en el c√≥digo. La clave debe tener al menos 32 caracteres.

### 5. Crear clase `JWTFilter`

En el mismo paquete agregue la clase `JWTFilter`:

```java
package co.edu.uniquindio.application.security;

import co.edu.uniquindio.application.services.impl.UserDetailsServiceImpl;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JWTFilter extends OncePerRequestFilter{
    
    private final JWTUtils jwtUtil;
    private final UserDetailsServiceImpl userDetailsService;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException {
        
        // Obtener el token del header de la solicitud
        String token = getToken(request);
        
        // Si no hay token, continuar con la cadena de filtros
        if (token == null) {
            chain.doFilter(request, response);
            return;
        }
        
        try {
            // Validar el token y obtener el payload
            Jws<Claims> payload = jwtUtil.parseJwt(token);
            String username = payload.getPayload().getSubject();
            
            // Si el usuario no est√° autenticado, crear un nuevo objeto de autenticaci√≥n
            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                
                // Crear un objeto UserDetails con el nombre de usuario y el rol
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                
                // Crear un objeto de autenticaci√≥n y establecerlo en el contexto de seguridad
                UsernamePasswordAuthenticationToken authentication = new 
                        UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                        );
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            // Si el token no es v√°lido, enviar un error 401
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Unauthorized");
            return;
        }
        
        // Continuar con la cadena de filtros
        chain.doFilter(request, response);
    }
    
    private String getToken(HttpServletRequest req) {
        String header = req.getHeader("Authorization");
        return header != null && header.startsWith("Bearer ") ? header.replace("Bearer ", "") : null;
    }
}
```

En esta clase se captura el token JWT que viene en el header de la solicitud HTTP. Si no hay token, se contin√∫a con la cadena de filtros sin hacer nada. Si hay un token, se valida usando la clase `JWTUtils`. Si el token no es v√°lido, se env√≠a un error 401 (no autorizado) en la respuesta.

Adem√°s, si el token es v√°lido, se crea un objeto de autenticaci√≥n y se establece en el **contexto de seguridad de Spring** para que pueda ser utilizado en los servicios de negocio.

Para m√°s informaci√≥n sobre [SecurityContextHolder](https://medium.com/@CodeWithTech/understanding-securitycontext-and-securitycontextholder-in-spring-security-e8ec9c030819) y [OncePerRequestFilter](https://www.baeldung.com/spring-onceperrequestfilter) puede visitar los enlaces.

### 6. Crear clase `JwtAuthenticationEntryPoint`

En el mismo paquete agregue la clase `JwtAuthenticationEntryPoint`:

```java
package co.edu.uniquindio.application.security;

import co.edu.uniquindio.application.dto.ResponseDTO;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;
import org.springframework.security.core.AuthenticationException;

import java.io.IOException;

@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException {

        ResponseDTO<String> dto = new ResponseDTO<>(true, "No tienes permisos para acceder a este recurso");
        response.setContentType("application/json");
        response.setStatus(403);
        response.getWriter().write(new ObjectMapper().writeValueAsString(dto));
        response.getWriter().flush();
        response.getWriter().close();
    }
}
```

En esta clase se lanza la excepci√≥n asociada a la solicitud del usuario (en el m√©todo `commence`). Si la solicitud es v√°lida este m√©todo no se invoca, s√≥lo se invoca si hay excepciones que se le debe notificar al usuario como cuando el token es incorrecto, est√° vencido o es requerido.

> **‚ö†Ô∏è Importante:** Debe tener el DTO `ResponseDTO` creado en el paquete `co.edu.uniquindio.application.dto`, el cual se cre√≥ en gu√≠as anteriores.

### 7. Crear UserDetailsServiceImpl

En el paquete `co.edu.uniquindio.application.service.impl` cree la clase `UserDetailsServiceImpl`:

```java
package co.edu.uniquindio.application.services.impl;

import co.edu.uniquindio.application.model.User;
import co.edu.uniquindio.application.repositories.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String id) throws UsernameNotFoundException {

        User user = userRepository.findById(id)
                .orElseThrow(() -> new UsernameNotFoundException("Usuario no encontrado"));
        
        List<GrantedAuthority> authorities = new ArrayList<>();
        authorities.add(new SimpleGrantedAuthority(user.getRole().name()));

        return new org.springframework.security.core.userdetails.User(
                user.getId(),
                user.getPassword(),
                authorities
        );
    }
}
```

Esta clase valida que el usuario presente en el token JWT exista en el sistema y permite extraer su rol y dem√°s datos necesarios. Spring Security utiliza el objeto `UserDetails` para representar al usuario autenticado y mantener su informaci√≥n en el contexto de seguridad durante las peticiones.

> **‚ö†Ô∏è Importante:** Dado que la clase `User` ya existe en el proyecto, y Spring Security tambi√©n tiene una clase llamada `User`, para evitar conflictos de nombres, se ha importado la clase `User` de Spring Security con su ruta completa en el retorno del m√©todo `loadUserByUsername`.


### 8. Crear SecurityConfig

Crear una nueva clase con el nombre `SecurityConfig` en el paquete `co.edu.uniquindio.application.config`:

```java
package co.edu.uniquindio.application.config;

import co.edu.uniquindio.application.security.JwtAuthenticationEntryPoint;
import co.edu.uniquindio.application.security.JWTFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JWTFilter jwtFilter;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // Configura la seguridad HTTP para la aplicaci√≥n
        http
                .csrf(AbstractHttpConfigurer::disable)
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(req -> req
                        .requestMatchers("/api/auth/**").permitAll()
                        .anyRequest().authenticated()
                )
                .exceptionHandling(ex -> ex.authenticationEntryPoint(new JwtAuthenticationEntryPoint()))
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        // Configura las pol√≠ticas de CORS para permitir solicitudes desde el frontend
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(List.of("*"));
        config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        config.setAllowedHeaders(List.of("*"));
        config.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        // Permite codificar y verificar contrase√±as utilizando BCrypt
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration)
            throws Exception {
        // Proporciona un AuthenticationManager para la autenticaci√≥n de usuarios
        return configuration.getAuthenticationManager();
    }
}
```

Esta es la clase principal de configuraci√≥n de Spring Security. Se destaca el m√©todo `securityFilterChain()`, que tiene la responsabilidad de hacer la comprobaci√≥n de autenticaci√≥n del usuario para indicar si se puede proceder con la solicitud o no.

De este m√©todo se destaca la siguiente parte:

```java
http.authorizeHttpRequests(req -> req
    .requestMatchers("/api/auth/**").permitAll()
    .anyRequest().authenticated()
);
```

Esta l√≠nea de c√≥digo indica que todas las solicitudes que comiencen con `/api/auth/` son permitidas, incluso las de swagger (`/swagger-ui/**`, `/v3/api-docs/**`) deber√≠an ser permitidas, pero las dem√°s solo son permitidas si el usuario est√° autenticado con un token. Para m√°s informaci√≥n se recomienda [visitar este art√≠culo](https://medium.com/@espinozajge/protegiendo-tu-aplicaci%C3%B3n-web-con-spring-security-y-autenticaci%C3%B3n-basada-en-tokens-jwt-1321cbe4c4c3).

> **‚ö†Ô∏è Importante:** Estas rutas deben coincidir con las definidas en los diferentes `@RestController`. Verifique bien las rutas que desea proteger y las que no.

### 9. Ejemplos de configuraci√≥n de rutas

A manera de ejemplo, si queremos que cualquier usuario pueda acceder a cualquier ruta tenga o no la autorizaci√≥n, podemos escribir:

```java
http.authorizeHttpRequests(req -> req.anyRequest().permitAll());
```

O si queremos que todas las rutas est√©n protegidas (se requiere autenticaci√≥n):

```java
http.authorizeHttpRequests(req -> req.anyRequest().authenticated());
```

Tambi√©n se pueden validar aspectos de la ruta relacionados con el m√©todo HTTP correspondiente:

```java
http.authorizeHttpRequests(req -> req
    .requestMatchers(HttpMethod.POST, "/api/users").permitAll()
);
```

Incluso, y lo m√°s importante, se puede restringir el acceso a las rutas seg√∫n el rol del usuario definido en el token de autenticaci√≥n:

```java
http.authorizeHttpRequests(req -> req
    .requestMatchers("/api/bookings/**").hasAuthority("ROLE_GUEST")
);
```

> **‚ö†Ô∏è Importante:** Puede ser necesario agregar `.requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()` para permitir el acceso a Swagger UI y as√≠ poder probar los endpoints desde all√≠.

### 10. Modificar registro de usuarios

Dado que JWT requiere de cifrado de contrase√±as, modifique el m√©todo de registro de usuarios nuevos de la clase `UsuarioServicioImpl` para que se use `PasswordEncoder`:

```java
// Se mapea el DTO a una entidad
User newUser = userMapper.toEntity(userDTO);

// Se codifica la contrase√±a
newUser.setPassword(passwordEncoder.encode(userDTO.password()));
```

Para cifrar la contrase√±a se hace uso del m√©todo `encode` de `passwordEncoder`.

### 11. A√±adir `PasswordEncoder` al servicio

A la clase `UserServiceImpl` a√±ada el atributo `passwordEncoder`:

```java
private final PasswordEncoder passwordEncoder;
```

Dado que la clase `UserServiceImpl` ya tiene el constructor con `@RequiredArgsConstructor`, no es necesario modificar nada m√°s. Spring inyectar√° autom√°ticamente la instancia de `PasswordEncoder` definida en la clase `SecurityConfig`.

### 12. Implementar servicio de login

Finalmente, el servicio de negocio para hacer login (iniciar sesi√≥n):

```java
public TokenDTO login(LoginDTO loginDTO) throws Exception {
    Optional<User> optionalUser = userRepository.findByEmail(loginDTO.email());

    if(optionalUser.isEmpty()){
        throw new Exception("El usuario no existe");
    }

    User user = optionalUser.get();

    // Verificar si la contrase√±a es correcta usando el PasswordEncoder
    if(!passwordEncoder.matches(loginDTO.password(), user.getPassword())){
        throw new Exception("El usuario no existe");
    }

    String token = jwtUtils.generateToken(user.getId(), createClaims(user));
    return new TokenDTO(token);
}

private Map<String, String> createClaims(User user){
    return Map.of(
        "email", user.getEmail(),
        "name", user.getName(),
        "role", "ROLE_"+user.getRole().name()
    );
}
```

En este m√©todo se valida que el usuario exista y que la contrase√±a sea correcta usando el m√©todo `matches` de `PasswordEncoder`. Si todo es correcto, se genera el token JWT usando la clase `JWTUtils` y se retorna en un DTO llamado `TokenDTO`. Este token debe ser almacenado en el frontend para enviarlo en las solicitudes que requieran autenticaci√≥n.

> **‚ö†Ô∏è NOTA:** Es necesario crear un nuevo DTO con el nombre `TokenDTO`, este DTO s√≥lo tiene el atributo `token` de tipo `String`.

### 13. Acceder al ID del usuario autenticado

Si necesita acceder al ID del usuario que est√° almacenado en el token de autenticaci√≥n de la solicitud dentro de un m√©todo en los servicios de negocio, puede hacerlo de la siguiente manera:

```java
User user = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
String idUser = user.getUsername();
```

Esto nos devuelve el ID y con √©l podemos verificar cosas relacionadas a la seguridad. Por ejemplo, con esto podemos validar que un usuario solo pueda editar sus propios datos personales, no los de otra persona.

`SecurityContextHolder` es una clase de Spring Security que permite acceder al **contexto de seguridad actual**, donde se almacena la informaci√≥n del usuario autenticado. Este objeto se inicializa en el filtro `JWTFilter` que creamos anteriormente. Por lo tanto, siempre que se haga una solicitud con un token v√°lido, este objeto tendr√° la informaci√≥n del usuario.

Tenga en cuenta que debe agregar los siguientes imports a la clase que lo requiera:

```java
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;
```

Puede crear un m√©todo en `AuthService` para obtener el ID del usuario autenticado (usando el c√≥digo anterior) y reutilizarlo en los servicios de negocio donde lo necesite.


### 14. Probar endpoints que requieren autenticaci√≥n

Para probar los endpoints que requieren autenticaci√≥n, se puede utilizar una herramienta como Postman, Insomnia o incluso Swagger UI si lo tiene configurado. En la herramienta que use, debe agregar un header a la solicitud con el nombre `Authorization` y el valor `Bearer <token>`, donde `<token>` es el token JWT que obtuvo al iniciar sesi√≥n.

Por ejemplo, en este caso se usar√°n archivos `.http` de IntelliJ IDEA. Cree un archivo llamado `auth.http` en la carpeta `src/test/resources` con el siguiente contenido:

```bash
### Login
POST http://localhost:8080/api/auth/login
Content-Type: application/json

{
  "email": "pepito@gmail.com",
  "password": "12345678"
}
```

Cabe destacar que debe existir un usuario con ese correo y contrase√±a en la base de datos para que la solicitud sea exitosa, de lo contrario, debe cambiar los datos por los de un usuario que exista en su base de datos.

**Ejecute el proyecto de Spring Boot** y luego ejecute la solicitud de login. Si todo est√° correcto, deber√≠a obtener una respuesta similar a esta:

```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
}
```

> ‚ö†Ô∏è **Nota:** Si lo desea, puede acceder a [https://www.jwt.io](https://www.jwt.io) para decodificar el token y ver su contenido. Copie el valor del token (la cadena larga que empieza con `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`) y p√©guelo en el campo "Encoded Value" de la p√°gina. De inmediato ver√° el contenido del token en la secci√≥n "Decoded".

Copie el valor del token y √∫selo para probar otros endpoints que requieran autenticaci√≥n. Por ejemplo, si tiene un endpoint para actualizar los datos del usuario, agregue el header `Authorization` con as√≠:

```bash
### Actualizar un usuario
PUT http://localhost:8080/api/users/<id_user>
Content-Type: application/json
Authorization: Bearer <token>

{
  "name": "Carlos",
  "phone": "333333",
  "photoUrl": "mi foto",
  "dateBirth": "2000-08-22"
}
```

Aseg√∫rese de reemplazar `<id_user>` por el ID real del usuario que desea actualizar y `<token>` por el token JWT que obtuvo al iniciar sesi√≥n. Si todo est√° correcto, deber√≠a obtener una respuesta con un c√≥digo 200 y los datos actualizados del usuario.

### 15. Usar variable de entorno para el token

Incluso, para evitar copiar y pegar el token cada vez que quiera probar un endpoint, puede crear una variable de entorno y usarla en el header de la solicitud. De esta manera, solo necesita actualizar la variable cuando inicie sesi√≥n nuevamente. 

En el archivo `auth.http`, modifique la solicitud de login para que guarde el token en una variable llamada `auth_token`, as√≠:

{% raw %}
```bash
### Login
POST http://localhost:8080/api/auth/login
Content-Type: application/json

{
  "email": "pepito@gmail.com",
  "password": "12345678"
}

> {% client.global.set("auth_token", response.body.token); %}
```
{% endraw %}

Luego, en las solicitudes que requieran autenticaci√≥n, puede usar la variable `{{auth_token}}` en el header `Authorization`, as√≠:

```bash
### Actualizar un usuario
PUT http://localhost:8080/api/users/<id_user>
Content-Type: application/json
Authorization: Bearer {{auth_token}}

{
  "name": "Carlos",
  "phone": "333333",
  "photoUrl": "mi foto",
  "dateBirth": "2000-08-22"
}   
```

Ejecute la solicitud de login primero para que la variable `auth_token` se actualice con el nuevo token. Luego, puede ejecutar la solicitud de actualizaci√≥n del usuario y deber√≠a funcionar correctamente.

### 16. Control de versiones

Recuerde hacer commit de sus avances en el repositorio de git y subirlos a GitHub.

---

## Para la pr√≥xima clase

- Qu√© es Oauth2 y OpenID.
- Qu√© servicios de autenticaci√≥n existen en la nube (Firebase, Auth0, Okta, etc.) y por qu√© delegarlos a un tercero.
- Investigar qu√© es Angular, programaci√≥n funcional y programaci√≥n reactiva.
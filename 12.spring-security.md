```
Programa de Ingeniería de Sistemas y Computación
Universidad del Quindío

Título: Spring Security y JWT
Duración estimada: 240
Docentes: Carlos Andrés Florez, Christian Andrés Candela
Guía: 12
```

# Spring Security y JWT

## 🎯 Objetivo

Implementar y configurar la seguridad de autenticación y autorización de usuarios haciendo uso de Spring Security y JSON Web Token (JWT).

---

## Conceptos básicos

Bases de datos relacionales, Java, Spring Boot.

---

## Contextualización Teórica

Un aspecto fundamental en el desarrollo de aplicaciones web es la seguridad. En el backend es necesario implementar mecanismos que permitan identificar a los usuarios y validar que tengan los permisos adecuados para acceder a los recursos y servicios que ofrece la aplicación. En Spring se cuenta con un módulo especializado para manejar la seguridad de las aplicaciones llamado **Spring Security**.

### Spring Security

Spring Security es el módulo de seguridad de Spring Framework que permite construir aplicaciones en el backend que cumplan con los estándares mínimos de seguridad. Spring Security aplica dos tipos de seguridad:

- **La autenticación** se refiere al proceso de verificación de la identidad de un usuario, en función de las credenciales proporcionadas. Un ejemplo común es ingresar un nombre de usuario y una contraseña cuando inicia sesión en un sitio web. Se refiere a la respuesta de la pregunta ¿Quién eres?

- **La autorización** se refiere al proceso de determinar si un usuario tiene el permiso adecuado para realizar una acción en particular o leer datos en particular, suponiendo que el usuario se haya autenticado con éxito. Puede considerarse como una respuesta a la pregunta ¿Puede un usuario hacer/leer esto?

En Spring Security, cada petición que se le hace al backend pasa por varios filtros, para evaluar su contenido y validar si el usuario tiene la autenticación correcta y la autorización adecuada para acceder al servicio solicitado.

Internamente, los filtros que se evalúan pasan (de forma muy resumida) por los siguientes:

![img](media/security1.png)

#### Proceso de Autenticación

Consideremos una aplicación web con Spring Security para autenticar usuarios. Cuando el usuario envía el formulario de inicio de sesión:

1. `UsernamePasswordAuthenticationFilter` crea una instancia de `UsernamePasswordAuthenticationToken` con las credenciales
2. Esta instancia se pasa al `AuthenticationManager`, que delega la validación a un `AuthenticationProvider`
3. El `AuthenticationProvider` valida las credenciales, y si son correctas, crea una nueva instancia de `Authentication` con los datos del usuario
4. Si la autenticación es exitosa, el `AuthenticationManager` almacena la instancia en el contexto de seguridad y el usuario puede acceder a áreas protegidas
5. Si falla, se lanza una excepción y el usuario es redirigido a la página de inicio de sesión con un mensaje de error

El `AuthenticationProvider` es una interfaz que puede ser implementada por múltiples proveedores, usando diferentes tipos de credenciales de usuario, como contraseñas, tokens de seguridad o certificados digitales. Entre los proveedores más importantes se encuentran:

- `OpenIDAuthenticationProvider`
- `JwtAuthenticationProvider`
- `OAuth2AuthenticationProvider`
- Y otros

### JWT

JSON Web Token (JWT) es un estándar abierto (RFC-7519) basado en JSON para crear un token que sirva para enviar datos entre aplicaciones o servicios y garantizar que sean válidos y seguros. Se considera a JWT como un método de autenticación sin estado.

El caso más común de uso de los JWT es para manejar la autenticación en aplicaciones móviles o web. Para esto:

1. El usuario se autentica enviando sus datos de inicio de sesión al servidor
2. El servidor genera el JWT y se lo envía a la aplicación cliente
3. En cada petición, el cliente envía este token que el servidor usa para verificar que el usuario esté correctamente autenticado y saber quién es

#### Estructura de JWT

Los JWT tienen una estructura definida y estándar basada en tres partes:

```
[Header].[Payload].[Signature]
```

- **Header (Encabezado):** contiene la lista de operaciones criptográficas que se aplican al JWT. Esta puede ser la técnica de firma, información de metadatos sobre el tipo de contenido, etc.

- **Payload (Carga útil):** contiene los datos reales que se transferirán mediante el token. Esta parte también se conoce como la parte de "reclamaciones" del token JWT.

- **Signature (Firma):** se usa para verificar que el mensaje no se modificó en el camino.

Las primeras dos partes (header y payload) son strings en **base64** creados a partir de dos JSON. La tercera parte (signature) toma las otras dos partes y las encripta usando un algoritmo (normalmente SHA-256).

![img](media/security2.png)

**Para más información:** https://jwt.io/ y https://spring.io/projects/spring-security

---

## Precauciones y Recomendaciones

- Recuerde verificar que tiene instalado el JDK de Java (preferiblemente la versión 21)
- Asegúrese de que tiene el servidor de base de datos en ejecución (MongoDB, MySQL, PostgreSQL, etc.)
- Use un cliente REST como Postman o Insomnia para probar los servicios del backend.

---

## Evaluación o Resultado

Se espera que el estudiante logre crear la configuración necesaria para añadir los métodos de autenticación y autorización por medio de JWT.

---

## Procedimiento

Continuaremos trabajando en el proyecto final del espacio académico que iniciamos en las guías anteriores. Si no ha completado la guía anterior, por favor hágalo antes de continuar con esta.

### 1. Añadir dependencias

Añadir las siguientes dependencias en el archivo `build.gradle`:

```groovy
implementation 'org.springframework.boot:spring-boot-starter-security'
implementation 'io.jsonwebtoken:jjwt-api:0.13.0'
runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.13.0'
runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.13.0'
```

La primera dependencia se encarga de añadir los aspectos básicos de Spring Security, las tres siguientes están relacionadas a JWT.

Elimine la dependencia de `spring-security-crypto` si ya la tiene, ya que `spring-boot-starter-security` la incluye.

> ⚠️ **Importante:** Recuerde sincronizar el proyecto con Gradle para que las nuevas dependencias se descarguen e instalen correctamente.

### 2. Verificar seguridad activada

Ejecute el proyecto e intente acceder a algunas de las rutas de la API. Debería evidenciar un bloqueo total del acceso a la API, ya que se activa un mecanismo de seguridad que restringe cualquier solicitud no autorizada.

### 3. Crear paquete de seguridad

Crear un paquete con el nombre `co.edu.uniquindio.application.security` donde se alojarán las clases relacionadas con la seguridad de la aplicación y la configuración de Spring Security.

### 4. Crear clase `JWTUtils`

Dentro del paquete de seguridad, cree la clase `JWTUtils`:

```java
package co.edu.uniquindio.application.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.stereotype.Component;
import javax.crypto.SecretKey;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.Map;

@Component
public class JWTUtils {
    
    public String generateToken(String id, Map<String, String> claims) {
        Instant now = Instant.now();
        return Jwts.builder()
                .claims(claims)
                .subject(id)
                .issuedAt(Date.from(now))
                .expiration(Date.from(now.plus(1L, ChronoUnit.HOURS)))
                .signWith(getKey())
                .compact();
    }
    
    public Jws<Claims> parseJwt(String jwtString) throws ExpiredJwtException,
            UnsupportedJwtException, MalformedJwtException, IllegalArgumentException {
        JwtParser jwtParser = Jwts.parser().verifyWith(getKey()).build();
        return jwtParser.parseSignedClaims(jwtString);
    }
    
    private SecretKey getKey(){
        String secretKey = "secretsecretsecretsecretsecretsecretsecretsecret";
        byte[] secretKeyBytes = secretKey.getBytes();
        return Keys.hmacShaKeyFor(secretKeyBytes);
    }
}
```

Esta clase `JWTUtils` contiene métodos importantes como:
- Crear el token JWT con el método `generateToken()`
- Firmar el token usando la clave secreta con el método `getKey()`
- Validar y decodificar el token con el método `parseJwt()`

Los métodos de esta clase son de utilidad para los mecanismos de autorización así como en los servicios de negocio de login y registro. En el método `generateToken()` podemos agregar más información al Token agregando más `claim()` (clave-valor).

> ⚠️ **NOTA:** Haga que la clave secreta venga dada desde el archivo `application.properties` usando `@Value("${jwt.secret}")` para que no esté hardcodeada en el código. La clave debe tener al menos 32 caracteres.

### 5. Crear clase `JWTFilter`

En el mismo paquete agregue la clase `JWTFilter`:

```java
package co.edu.uniquindio.application.security;

import co.edu.uniquindio.application.services.impl.UserDetailsServiceImpl;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JWTFilter extends OncePerRequestFilter{
    
    private final JWTUtils jwtUtil;
    private final UserDetailsServiceImpl userDetailsService;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException {
        
        // Obtener el token del header de la solicitud
        String token = getToken(request);
        
        // Si no hay token, continuar con la cadena de filtros
        if (token == null) {
            chain.doFilter(request, response);
            return;
        }
        
        try {
            // Validar el token y obtener el payload
            Jws<Claims> payload = jwtUtil.parseJwt(token);
            String username = payload.getPayload().getSubject();
            
            // Si el usuario no está autenticado, crear un nuevo objeto de autenticación
            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                
                // Crear un objeto UserDetails con el nombre de usuario y el rol
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                
                // Crear un objeto de autenticación y establecerlo en el contexto de seguridad
                UsernamePasswordAuthenticationToken authentication = new 
                        UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                        );
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            // Si el token no es válido, enviar un error 401
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Unauthorized");
            return;
        }
        
        // Continuar con la cadena de filtros
        chain.doFilter(request, response);
    }
    
    private String getToken(HttpServletRequest req) {
        String header = req.getHeader("Authorization");
        return header != null && header.startsWith("Bearer ") ? header.replace("Bearer ", "") : null;
    }
}
```

En esta clase se captura el token JWT que viene en el header de la solicitud HTTP. Si no hay token, se continúa con la cadena de filtros sin hacer nada. Si hay un token, se valida usando la clase `JWTUtils`. Si el token no es válido, se envía un error 401 (no autorizado) en la respuesta.

Además, si el token es válido, se crea un objeto de autenticación y se establece en el **contexto de seguridad de Spring** para que pueda ser utilizado en los servicios de negocio.

Para más información sobre [SecurityContextHolder](https://medium.com/@CodeWithTech/understanding-securitycontext-and-securitycontextholder-in-spring-security-e8ec9c030819) y [OncePerRequestFilter](https://www.baeldung.com/spring-onceperrequestfilter) puede visitar los enlaces.

### 6. Crear clase `JwtAuthenticationEntryPoint`

En el mismo paquete agregue la clase `JwtAuthenticationEntryPoint`:

```java
package co.edu.uniquindio.application.security;

import co.edu.uniquindio.application.dto.ResponseDTO;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;
import org.springframework.security.core.AuthenticationException;

import java.io.IOException;

@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException {

        ResponseDTO<String> dto = new ResponseDTO<>(true, "No tienes permisos para acceder a este recurso");
        response.setContentType("application/json");
        response.setStatus(403);
        response.getWriter().write(new ObjectMapper().writeValueAsString(dto));
        response.getWriter().flush();
        response.getWriter().close();
    }
}
```

En esta clase se lanza la excepción asociada a la solicitud del usuario (en el método `commence`). Si la solicitud es válida este método no se invoca, sólo se invoca si hay excepciones que se le debe notificar al usuario como cuando el token es incorrecto, está vencido o es requerido.

> **⚠️ Importante:** Debe tener el DTO `ResponseDTO` creado en el paquete `co.edu.uniquindio.application.dto`, el cual se creó en guías anteriores.

### 7. Crear UserDetailsServiceImpl

En el paquete `co.edu.uniquindio.application.service.impl` cree la clase `UserDetailsServiceImpl`:

```java
package co.edu.uniquindio.application.services.impl;

import co.edu.uniquindio.application.model.User;
import co.edu.uniquindio.application.repositories.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String id) throws UsernameNotFoundException {

        User user = userRepository.findById(id)
                .orElseThrow(() -> new UsernameNotFoundException("Usuario no encontrado"));
        
        List<GrantedAuthority> authorities = new ArrayList<>();
        authorities.add(new SimpleGrantedAuthority(user.getRole().name()));

        return new org.springframework.security.core.userdetails.User(
                user.getId(),
                user.getPassword(),
                authorities
        );
    }
}
```

Esta clase valida que el usuario presente en el token JWT exista en el sistema y permite extraer su rol y demás datos necesarios. Spring Security utiliza el objeto `UserDetails` para representar al usuario autenticado y mantener su información en el contexto de seguridad durante las peticiones.

> **⚠️ Importante:** Dado que la clase `User` ya existe en el proyecto, y Spring Security también tiene una clase llamada `User`, para evitar conflictos de nombres, se ha importado la clase `User` de Spring Security con su ruta completa en el retorno del método `loadUserByUsername`.


### 8. Crear SecurityConfig

Crear una nueva clase con el nombre `SecurityConfig` en el paquete `co.edu.uniquindio.application.config`:

```java
package co.edu.uniquindio.application.config;

import co.edu.uniquindio.application.security.JwtAuthenticationEntryPoint;
import co.edu.uniquindio.application.security.JWTFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JWTFilter jwtFilter;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // Configura la seguridad HTTP para la aplicación
        http
                .csrf(AbstractHttpConfigurer::disable)
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(req -> req
                        .requestMatchers("/api/auth/**").permitAll()
                        .anyRequest().authenticated()
                )
                .exceptionHandling(ex -> ex.authenticationEntryPoint(new JwtAuthenticationEntryPoint()))
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        // Configura las políticas de CORS para permitir solicitudes desde el frontend
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(List.of("*"));
        config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        config.setAllowedHeaders(List.of("*"));
        config.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        // Permite codificar y verificar contraseñas utilizando BCrypt
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration)
            throws Exception {
        // Proporciona un AuthenticationManager para la autenticación de usuarios
        return configuration.getAuthenticationManager();
    }
}
```

Esta es la clase principal de configuración de Spring Security. Se destaca el método `securityFilterChain()`, que tiene la responsabilidad de hacer la comprobación de autenticación del usuario para indicar si se puede proceder con la solicitud o no.

De este método se destaca la siguiente parte:

```java
http.authorizeHttpRequests(req -> req
    .requestMatchers("/api/auth/**").permitAll()
    .anyRequest().authenticated()
);
```

Esta línea de código indica que todas las solicitudes que comiencen con `/api/auth/` son permitidas, incluso las de swagger (`/swagger-ui/**`, `/v3/api-docs/**`) deberían ser permitidas, pero las demás solo son permitidas si el usuario está autenticado con un token. Para más información se recomienda [visitar este artículo](https://medium.com/@espinozajge/protegiendo-tu-aplicaci%C3%B3n-web-con-spring-security-y-autenticaci%C3%B3n-basada-en-tokens-jwt-1321cbe4c4c3).

> **⚠️ Importante:** Estas rutas deben coincidir con las definidas en los diferentes `@RestController`. Verifique bien las rutas que desea proteger y las que no.

### 9. Ejemplos de configuración de rutas

A manera de ejemplo, si queremos que cualquier usuario pueda acceder a cualquier ruta tenga o no la autorización, podemos escribir:

```java
http.authorizeHttpRequests(req -> req.anyRequest().permitAll());
```

O si queremos que todas las rutas estén protegidas (se requiere autenticación):

```java
http.authorizeHttpRequests(req -> req.anyRequest().authenticated());
```

También se pueden validar aspectos de la ruta relacionados con el método HTTP correspondiente:

```java
http.authorizeHttpRequests(req -> req
    .requestMatchers(HttpMethod.POST, "/api/users").permitAll()
);
```

Incluso, y lo más importante, se puede restringir el acceso a las rutas según el rol del usuario definido en el token de autenticación:

```java
http.authorizeHttpRequests(req -> req
    .requestMatchers("/api/bookings/**").hasAuthority("ROLE_GUEST")
);
```

> **⚠️ Importante:** Puede ser necesario agregar `.requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()` para permitir el acceso a Swagger UI y así poder probar los endpoints desde allí.

### 10. Modificar registro de usuarios

Dado que JWT requiere de cifrado de contraseñas, modifique el método de registro de usuarios nuevos de la clase `UsuarioServicioImpl` para que se use `PasswordEncoder`:

```java
// Se mapea el DTO a una entidad
User newUser = userMapper.toEntity(userDTO);

// Se codifica la contraseña
newUser.setPassword(passwordEncoder.encode(userDTO.password()));
```

Para cifrar la contraseña se hace uso del método `encode` de `passwordEncoder`.

### 11. Añadir `PasswordEncoder` al servicio

A la clase `UserServiceImpl` añada el atributo `passwordEncoder`:

```java
private final PasswordEncoder passwordEncoder;
```

Dado que la clase `UserServiceImpl` ya tiene el constructor con `@RequiredArgsConstructor`, no es necesario modificar nada más. Spring inyectará automáticamente la instancia de `PasswordEncoder` definida en la clase `SecurityConfig`.

### 12. Implementar servicio de login

Finalmente, el servicio de negocio para hacer login (iniciar sesión):

```java
public TokenDTO login(LoginDTO loginDTO) throws Exception {
    Optional<User> optionalUser = userRepository.findByEmail(loginDTO.email());

    if(optionalUser.isEmpty()){
        throw new Exception("El usuario no existe");
    }

    User user = optionalUser.get();

    // Verificar si la contraseña es correcta usando el PasswordEncoder
    if(!passwordEncoder.matches(loginDTO.password(), user.getPassword())){
        throw new Exception("El usuario no existe");
    }

    String token = jwtUtils.generateToken(user.getId(), createClaims(user));
    return new TokenDTO(token);
}

private Map<String, String> createClaims(User user){
    return Map.of(
        "email", user.getEmail(),
        "name", user.getName(),
        "role", "ROLE_"+user.getRole().name()
    );
}
```

En este método se valida que el usuario exista y que la contraseña sea correcta usando el método `matches` de `PasswordEncoder`. Si todo es correcto, se genera el token JWT usando la clase `JWTUtils` y se retorna en un DTO llamado `TokenDTO`. Este token debe ser almacenado en el frontend para enviarlo en las solicitudes que requieran autenticación.

> **⚠️ NOTA:** Es necesario crear un nuevo DTO con el nombre `TokenDTO`, este DTO sólo tiene el atributo `token` de tipo `String`.

### 13. Acceder al ID del usuario autenticado

Si necesita acceder al ID del usuario que está almacenado en el token de autenticación de la solicitud dentro de un método en los servicios de negocio, puede hacerlo de la siguiente manera:

```java
User user = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
String idUser = user.getUsername();
```

Esto nos devuelve el ID y con él podemos verificar cosas relacionadas a la seguridad. Por ejemplo, con esto podemos validar que un usuario solo pueda editar sus propios datos personales, no los de otra persona.

`SecurityContextHolder` es una clase de Spring Security que permite acceder al **contexto de seguridad actual**, donde se almacena la información del usuario autenticado. Este objeto se inicializa en el filtro `JWTFilter` que creamos anteriormente. Por lo tanto, siempre que se haga una solicitud con un token válido, este objeto tendrá la información del usuario.

Tenga en cuenta que debe agregar los siguientes imports a la clase que lo requiera:

```java
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;
```

Puede crear un método en `AuthService` para obtener el ID del usuario autenticado (usando el código anterior) y reutilizarlo en los servicios de negocio donde lo necesite.


### 14. Probar endpoints que requieren autenticación

Para probar los endpoints que requieren autenticación, se puede utilizar una herramienta como Postman, Insomnia o incluso Swagger UI si lo tiene configurado. En la herramienta que use, debe agregar un header a la solicitud con el nombre `Authorization` y el valor `Bearer <token>`, donde `<token>` es el token JWT que obtuvo al iniciar sesión.

Por ejemplo, en este caso se usarán archivos `.http` de IntelliJ IDEA. Cree un archivo llamado `auth.http` en la carpeta `src/test/resources` con el siguiente contenido:

```bash
### Login
POST http://localhost:8080/api/auth/login
Content-Type: application/json

{
  "email": "pepito@gmail.com",
  "password": "12345678"
}
```

Cabe destacar que debe existir un usuario con ese correo y contraseña en la base de datos para que la solicitud sea exitosa, de lo contrario, debe cambiar los datos por los de un usuario que exista en su base de datos.

**Ejecute el proyecto de Spring Boot** y luego ejecute la solicitud de login. Si todo está correcto, debería obtener una respuesta similar a esta:

```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
}
```

> ⚠️ **Nota:** Si lo desea, puede acceder a [https://www.jwt.io](https://www.jwt.io) para decodificar el token y ver su contenido. Copie el valor del token (la cadena larga que empieza con `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`) y péguelo en el campo "Encoded Value" de la página. De inmediato verá el contenido del token en la sección "Decoded".

Copie el valor del token y úselo para probar otros endpoints que requieran autenticación. Por ejemplo, si tiene un endpoint para actualizar los datos del usuario, agregue el header `Authorization` con así:

```bash
### Actualizar un usuario
PUT http://localhost:8080/api/users/<id_user>
Content-Type: application/json
Authorization: Bearer <token>

{
  "name": "Carlos",
  "phone": "333333",
  "photoUrl": "mi foto",
  "dateBirth": "2000-08-22"
}
```

Asegúrese de reemplazar `<id_user>` por el ID real del usuario que desea actualizar y `<token>` por el token JWT que obtuvo al iniciar sesión. Si todo está correcto, debería obtener una respuesta con un código 200 y los datos actualizados del usuario.

### 15. Usar variable de entorno para el token

Incluso, para evitar copiar y pegar el token cada vez que quiera probar un endpoint, puede crear una variable de entorno y usarla en el header de la solicitud. De esta manera, solo necesita actualizar la variable cuando inicie sesión nuevamente. 

En el archivo `auth.http`, modifique la solicitud de login para que guarde el token en una variable llamada `auth_token`, así:

{% raw %}
```bash
### Login
POST http://localhost:8080/api/auth/login
Content-Type: application/json

{
  "email": "pepito@gmail.com",
  "password": "12345678"
}

> {% client.global.set("auth_token", response.body.token); %}
```
{% endraw %}

Luego, en las solicitudes que requieran autenticación, puede usar la variable `{{auth_token}}` en el header `Authorization`, así:

```bash
### Actualizar un usuario
PUT http://localhost:8080/api/users/<id_user>
Content-Type: application/json
Authorization: Bearer {{auth_token}}

{
  "name": "Carlos",
  "phone": "333333",
  "photoUrl": "mi foto",
  "dateBirth": "2000-08-22"
}   
```

Ejecute la solicitud de login primero para que la variable `auth_token` se actualice con el nuevo token. Luego, puede ejecutar la solicitud de actualización del usuario y debería funcionar correctamente.

### 16. Control de versiones

Recuerde hacer commit de sus avances en el repositorio de git y subirlos a GitHub.

---

## Para la próxima clase

- Qué es Oauth2 y OpenID.
- Qué servicios de autenticación existen en la nube (Firebase, Auth0, Okta, etc.) y por qué delegarlos a un tercero.
- Investigar qué es Angular, programación funcional y programación reactiva.
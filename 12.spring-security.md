```
Programa de Ingeniería de Sistemas y Computación
Universidad del Quindío

Título: Spring Security y JWT
Duración estimada: 240
Docentes: Carlos Andrés Florez, Christian Andrés Candela
Guía: 12
```

# Spring Security y JWT

## 🎯 Objetivo

Implementar y configurar la seguridad de autenticación y autorización de usuarios haciendo uso de Spring Security y JSON Web Token (JWT).

---

## Conceptos básicos

Bases de datos relacionales, Java, Spring Boot.

---

## Contextualización Teórica

Un aspecto fundamental en el desarrollo de aplicaciones web es la seguridad. En el backend es necesario implementar mecanismos que permitan identificar a los usuarios y validar que tengan los permisos adecuados para acceder a los recursos y servicios que ofrece la aplicación. En Spring se cuenta con un módulo especializado para manejar la seguridad de las aplicaciones llamado **Spring Security**.

### Spring Security

Spring Security es el módulo de seguridad de Spring Framework que permite construir aplicaciones en el backend que cumplan con los estándares mínimos de seguridad. Spring Security aplica dos tipos de seguridad:

- **La autenticación** se refiere al proceso de verificación de la identidad de un usuario, en función de las credenciales proporcionadas. Un ejemplo común es ingresar un nombre de usuario y una contraseña cuando inicia sesión en un sitio web. Se refiere a la respuesta de la pregunta ¿Quién eres?

- **La autorización** se refiere al proceso de determinar si un usuario tiene el permiso adecuado para realizar una acción en particular o leer datos en particular, suponiendo que el usuario se haya autenticado con éxito. Puede considerarse como una respuesta a la pregunta ¿Puede un usuario hacer/leer esto?

En Spring Security, cada petición que se le hace al backend pasa por varios filtros, para evaluar su contenido y validar si el usuario tiene la autenticación correcta y la autorización adecuada para acceder al servicio solicitado.

#### Proceso de Autenticación

Consideremos una aplicación web con Spring Security para autenticar usuarios. Cuando el usuario envía el formulario de inicio de sesión:

1. `UsernamePasswordAuthenticationFilter` crea una instancia de `UsernamePasswordAuthenticationToken` con las credenciales
2. Esta instancia se pasa al `AuthenticationManager`, que delega la validación a un `AuthenticationProvider`
3. El `AuthenticationProvider` valida las credenciales, y si son correctas, crea una nueva instancia de `Authentication` con los datos del usuario
4. Si la autenticación es exitosa, el `AuthenticationManager` almacena la instancia en el contexto de seguridad y el usuario puede acceder a áreas protegidas
5. Si falla, se lanza una excepción y el usuario es redirigido a la página de inicio de sesión con un mensaje de error

El `AuthenticationProvider` es una interfaz que puede ser implementada por múltiples proveedores, usando diferentes tipos de credenciales de usuario, como contraseñas, tokens de seguridad o certificados digitales. Entre los proveedores más importantes se encuentran:

- `OpenIDAuthenticationProvider`
- `JwtAuthenticationProvider`
- `OAuth2AuthenticationProvider`
- Y otros

### JWT

JSON Web Token (JWT) es un estándar abierto (RFC-7519) basado en JSON para crear un token que sirva para enviar datos entre aplicaciones o servicios y garantizar que sean válidos y seguros. Se considera a JWT como un método de autenticación sin estado.

El caso más común de uso de los JWT es para manejar la autenticación en aplicaciones móviles o web. Para esto:

1. El usuario se autentica enviando sus datos de inicio de sesión al servidor
2. El servidor genera el JWT y se lo envía a la aplicación cliente
3. En cada petición, el cliente envía este token que el servidor usa para verificar que el usuario esté correctamente autenticado y saber quién es

#### Estructura de JWT

Los JWT tienen una estructura definida y estándar basada en tres partes:

```
[Header].[Payload].[Signature]
```

- **Header (Encabezado):** contiene la lista de operaciones criptográficas que se aplican al JWT. Esta puede ser la técnica de firma, información de metadatos sobre el tipo de contenido, etc.

- **Payload (Carga útil):** contiene los datos reales que se transferirán mediante el token. Esta parte también se conoce como la parte de "reclamaciones" del token JWT.

- **Signature (Firma):** se usa para verificar que el mensaje no se modificó en el camino.

Las primeras dos partes (header y payload) son strings en **base64** creados a partir de dos JSON. La tercera parte (signature) toma las otras dos partes y las encripta usando un algoritmo (normalmente SHA-256).

**Para más información:** https://jwt.io/ y https://spring.io/projects/spring-security

---

## Precauciones y Recomendaciones

- Recuerde verificar que tiene instalado el JDK de Java (preferiblemente la versión 21)
- Asegúrese de que tiene el servidor de base de datos en ejecución (MongoDB, MySQL, PostgreSQL, etc.)
- Use un cliente REST como Postman o Insomnia para probar los servicios del backend.

---

## Evaluación o Resultado

Se espera que el estudiante logre crear la configuración necesaria para añadir los métodos de autenticación y autorización por medio de JWT.

---

## Procedimiento

Continuaremos trabajando en el proyecto final del espacio académico que iniciamos en las guías anteriores. Si no ha completado la guía anterior, por favor hágalo antes de continuar con esta.

### 1. Añadir dependencias

Añadir las siguientes dependencias en el archivo `build.gradle`:

```groovy
implementation 'org.springframework.boot:spring-boot-starter-security'
implementation 'io.jsonwebtoken:jjwt-api:0.13.0'
runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.13.0'
runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.13.0'
```

La primera dependencia se encarga de añadir los aspectos básicos de Spring Security, las tres siguientes están relacionadas a JWT.

Elimine la dependencia de `spring-security-crypto` si ya la tiene, ya que `spring-boot-starter-security` la incluye.

> ⚠️ **Importante:** Recuerde sincronizar el proyecto con Gradle para que las nuevas dependencias se descarguen e instalen correctamente.

### 2. Verificar seguridad activada

Ejecute el proyecto e intente acceder a algunas de las rutas de la API. Debería evidenciar un bloqueo total del acceso a la API, ya que se activa un mecanismo de seguridad que restringe cualquier solicitud no autorizada.

### 3. Crear paquete de seguridad

Crear un paquete con el nombre `co.edu.uniquindio.application.security` donde se alojarán las clases relacionadas con la seguridad de la aplicación y la configuración de Spring Security.

### 4. Crear clase `JWTUtils`

Dentro del paquete de seguridad, cree la clase `JWTUtils`:

```java
package co.edu.uniquindio.application.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.stereotype.Component;
import javax.crypto.SecretKey;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.Map;

@Component
public class JWTUtils {
    
    public String generateToken(String id, Map<String, String> claims) {
        Instant now = Instant.now();
        return Jwts.builder()
                .claims(claims)
                .subject(id)
                .issuedAt(Date.from(now))
                .expiration(Date.from(now.plus(1L, ChronoUnit.HOURS)))
                .signWith(getKey())
                .compact();
    }
    
    public Jws<Claims> parseJwt(String jwtString) throws ExpiredJwtException,
            UnsupportedJwtException, MalformedJwtException, IllegalArgumentException {
        JwtParser jwtParser = Jwts.parser().verifyWith(getKey()).build();
        return jwtParser.parseSignedClaims(jwtString);
    }
    
    private SecretKey getKey(){
        String secretKey = "secretsecretsecretsecretsecretsecretsecretsecret";
        byte[] secretKeyBytes = secretKey.getBytes();
        return Keys.hmacShaKeyFor(secretKeyBytes);
    }
}
```

Esta clase `JWTUtils` contiene métodos importantes como:
- Crear el token JWT con el método `generateToken()`
- Firmar el token usando la clave secreta con el método `getKey()`
- Validar y decodificar el token con el método `parseJwt()`

Los métodos de esta clase son de utilidad para los mecanismos de autorización así como en los servicios de negocio de login y registro. En el método `generateToken()` podemos agregar más información al Token agregando más `claim()` (clave-valor).

> ⚠️ **NOTA:** Haga que la clave secreta venga dada desde el archivo `application.properties`.

### 5. Crear clase `JWTFilter`

En el mismo paquete agregue la clase `JWTFilter`:

```java
package co.edu.uniquindio.application.security;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;

@Component
@RequiredArgsConstructor
public class JWTFilter extends OncePerRequestFilter{
    
    private final JWTUtils jwtUtil;
    private final UserDetailsServiceImpl userDetailsService;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException {
        
        // Obtener el token del header de la solicitud
        String token = getToken(request);
        
        // Si no hay token, continuar con la cadena de filtros
        if (token == null) {
            chain.doFilter(request, response);
            return;
        }
        
        try {
            // Validar el token y obtener el payload
            Jws<Claims> payload = jwtUtil.parseJwt(token);
            String username = payload.getPayload().getSubject();
            
            // Si el usuario no está autenticado, crear un nuevo objeto de autenticación
            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                
                // Crear un objeto UserDetails con el nombre de usuario y el rol
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                
                // Crear un objeto de autenticación y establecerlo en el contexto de seguridad
                UsernamePasswordAuthenticationToken authentication = new 
                        UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                        );
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            // Si el token no es válido, enviar un error 401
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Unauthorized");
            return;
        }
        
        // Continuar con la cadena de filtros
        chain.doFilter(request, response);
    }
    
    private String getToken(HttpServletRequest req) {
        String header = req.getHeader("Authorization");
        return header != null && header.startsWith("Bearer ") ? header.replace("Bearer ", "") : null;
    }
}
```

En esta clase se verifica que el token enviado desde alguna solicitud desde el frontend sea válido para comprobar los datos enviados y validar que el usuario que envió la solicitud sí exista.

### 6. Crear clase `AutenticacionEntryPoint`

En el mismo paquete agregue la clase `AutenticacionEntryPoint`:

```java
package co.edu.uniquindio.application.security;

import co.edu.uniquindio.application.dto.ResponseDTO;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;
import org.springframework.security.core.AuthenticationException;

import java.io.IOException;

@Component
public class AutenticacionEntryPoint implements AuthenticationEntryPoint {
    
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                        AuthenticationException authException) throws IOException {
        
        ResponseDTO<String> dto = new ResponseDTO<>(true, "No tienes permisos para acceder a este recurso");
        response.setContentType("application/json");
        response.setStatus(403);
        response.getWriter().write(new ObjectMapper().writeValueAsString(dto));
        response.getWriter().flush();
        response.getWriter().close();
    }
}
```

En esta clase se lanza la excepción asociada a la solicitud del usuario (en el método `commence`). Si la solicitud es válida este método no se invoca, sólo se invoca si hay excepciones que se le debe notificar al usuario como cuando el token es incorrecto, está vencido o es requerido.

> **⚠️ Importante:** Debe tener el DTO `ResponseDTO` creado en el paquete `co.edu.uniquindio.application.dto`.

### 7. Crear UserDetailsServicioImpl

En el paquete `co.edu.uniquindio.application.service.impl` cree la clase `UserDetailsServicioImpl`:

```java
package co.edu.uniquindio.application.service.impl;

import co.edu.uniquindio.application.model.User;
import co.edu.uniquindio.application.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.bson.types.ObjectId;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        
        if(!ObjectId.isValid(username)) {
            throw new UsernameNotFoundException("ID de usuario inválido");
        }

        User user = userRepository.findById(new ObjectId(username))
                .orElseThrow(() -> new UsernameNotFoundException("Usuario no encontrado"));
        
        List<GrantedAuthority> authorities = new ArrayList<>();
        authorities.add(new SimpleGrantedAuthority(user.getRole().name()));

        return new User(
                user.getId().toString(),
                user.getPassword(),
                authorities
        );
    }
}
```

Esta clase valida que el usuario presente en el token JWT exista en el sistema y permite extraer su rol y demás datos necesarios. Spring Security utiliza el objeto `UserDetails` para representar al usuario autenticado y mantener su información en el contexto de seguridad durante las peticiones.

### 8. Crear SecurityConfig

Crear una nueva clase con el nombre `SecurityConfig` en el paquete `co.edu.uniquindio.application.config`:

```java
package co.edu.uniquindio.application.config;

import co.edu.uniquindio.application.security.AuthenticationEntryPoint;
import co.edu.uniquindio.application.security.JWTFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {
    
    private final JWTFilter jwtFilter;
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // Configura la seguridad HTTP para la aplicación
        http
            .csrf(AbstractHttpConfigurer::disable)
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            .sessionManagement(session -> 
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(req -> req
                .requestMatchers("/api/auth/**").permitAll()
                .anyRequest().authenticated()
            )
            .exceptionHandling(ex -> ex.authenticationEntryPoint(new AutenticacionEntryPoint()))
            .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        // Configura las políticas de CORS para permitir solicitudes desde el frontend
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(List.of("*"));
        config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        config.setAllowedHeaders(List.of("*"));
        config.setAllowCredentials(true);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        // Permite codificar y verificar contraseñas utilizando BCrypt
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration) 
            throws Exception {
        // Proporciona un AuthenticationManager para la autenticación de usuarios
        return configuration.getAuthenticationManager();
    }
}
```

Esta es la clase principal de configuración de Spring Security. Se destaca el método `securityFilterChain()`, que tiene la responsabilidad de hacer la comprobación de autenticación del usuario para indicar si se puede proceder con la solicitud o no.

De este método se destaca la siguiente parte:

```java
http.authorizeHttpRequests(req -> req
    .requestMatchers("/api/auth/**").permitAll()
    .anyRequest().authenticated()
);
```

Esta línea de código indica que todas las solicitudes que comiencen con "/api/auth/" son permitidas, incluso las de swagger ("/swagger-ui/**", "/v3/api-docs/**") deberían ser permitidas, pero las demás solo son permitidas si el usuario está autenticado con un token.

> **⚠️ IMPORTANTE:** Estas rutas deben coincidir con las definidas en los diferentes `RestController`.

**Para más información:** https://medium.com/@espinozajge/protegiendo-tu-aplicaci%C3%B3n-web-con-spring-security-y-autenticaci%C3%B3n-basada-en-tokens-jwt-1321cbe4c4c3

### 9. Ejemplos de configuración de rutas

A manera de ejemplo, si queremos que cualquier usuario pueda acceder a cualquier ruta tenga o no la autorización, podemos escribir:

```java
http.authorizeHttpRequests(req -> req.anyRequest().permitAll());
```

O si queremos que todas las rutas estén protegidas (se requiere autenticación):

```java
http.authorizeHttpRequests(req -> req.anyRequest().authenticated());
```

También se pueden validar aspectos de la ruta relacionados con el método HTTP correspondiente:

```java
http.authorizeHttpRequests(req -> req
    .requestMatchers(HttpMethod.POST, "/api/users").permitAll()
);
```

Incluso, y lo más importante, se puede restringir el acceso a las rutas según el rol del usuario definido en el token de autenticación:

```java
http.authorizeHttpRequests(req -> req
    .requestMatchers("/api/users/**").hasAuthority("ROLE_USER")
);
```

### 10. Modificar registro de usuarios

Dado que JWT requiere de cifrado de contraseñas, modifique el método de registro de usuarios nuevos de la clase `UsuarioServicioImpl` para que se use `PasswordEncoder`:

```java
// Se mapea el DTO a un documento
User newUser = userMapper.toDocument(createUserDTO);

// Se codifica la contraseña
newUser.setPassword(passwordEncoder.encode(createUserDTO.password()));
```

Para cifrar la contraseña se hace uso del método `encode` de `passwordEncoder`.

### 11. Añadir `PasswordEncoder` al servicio

A la clase `UsuarioServicioImpl` añada el atributo `passwordEncoder` e inicialícelo ya sea con `@Autowired` o en el constructor de la clase (con `@RequiredArgsConstructor`):

```java
private final PasswordEncoder passwordEncoder;
```

### 12. Implementar servicio de login

Finalmente, el servicio de negocio para hacer login (iniciar sesión):

```java
public TokenDTO login(LoginDTO loginDTO) throws Exception {
    Optional<User> optionalUser = userRepository.findByEmail(loginDTO.email());

    if(optionalUser.isEmpty()){
        throw new Exception("El usuario no existe");
    }

    User user = optionalUser.get();

    // Verificar si la contraseña es correcta usando el PasswordEncoder
    if(!passwordEncoder.matches(loginDTO.password(), user.getPassword())){
        throw new Exception("El usuario no existe");
    }

    String token = jwtUtils.generateToken(user.getId().toString(), createClaims(user));
    return new TokenDTO(token);
}

private Map<String, String> createClaims(User user){
    return Map.of(
        "email", user.getEmail(),
        "name", user.getName(),
        "role", "ROLE_"+user.getRole().name()
    );
}
```

> **⚠️ NOTA:** Es necesario crear un nuevo DTO con el nombre `TokenDTO`, este DTO sólo tiene el atributo `token` de tipo `String`.

### 13. Acceder al ID del usuario autenticado

Si necesita acceder al ID del usuario que está almacenado en el token de autenticación de la solicitud dentro de un método en los servicios de negocio, puede hacerlo de la siguiente manera:

```java
User user = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
String idUser = user.getUsername();
```

Esto nos devuelve el ID y con él podemos verificar cosas relacionadas a la seguridad. Por ejemplo, con esto podemos validar que un usuario solo pueda editar sus propios datos personales, no los de otra persona.

Tenga en cuenta que debe agregar los siguientes imports a la clase que lo requiera:

```java
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;
```

### 14. Control de versiones

Recuerde hacer commit de sus avances en el repositorio de git.

---

## Para la próxima clase

- Qué es Oauth2 y OpenID.
- Qué servicios de autenticación existen en la nube (Firebase, Auth0, Okta, etc.) y por qué delegarlos a un tercero.
- Investigar qué es Angular, programación funcional y programación reactiva.
```
Programa de Ingenier铆a de Sistemas y Computaci贸n
Universidad del Quind铆o

T铆tulo: Spring Security y JWT
Duraci贸n estimada: 240
Docentes: Carlos Andr茅s Florez, Christian Andr茅s Candela
Gu铆a: 12
```

# Spring Security y JWT

##  Objetivo

Implementar y configurar la seguridad de autenticaci贸n y autorizaci贸n de usuarios haciendo uso de Spring Security y JSON Web Token (JWT).

---

## Conceptos b谩sicos

Bases de datos relacionales, Java, Spring Boot.

---

## Contextualizaci贸n Te贸rica

Un aspecto fundamental en el desarrollo de aplicaciones web es la seguridad. En el backend es necesario implementar mecanismos que permitan identificar a los usuarios y validar que tengan los permisos adecuados para acceder a los recursos y servicios que ofrece la aplicaci贸n. En Spring se cuenta con un m贸dulo especializado para manejar la seguridad de las aplicaciones llamado **Spring Security**.

### Spring Security

Spring Security es el m贸dulo de seguridad de Spring Framework que permite construir aplicaciones en el backend que cumplan con los est谩ndares m铆nimos de seguridad. Spring Security aplica dos tipos de seguridad:

- **La autenticaci贸n** se refiere al proceso de verificaci贸n de la identidad de un usuario, en funci贸n de las credenciales proporcionadas. Un ejemplo com煤n es ingresar un nombre de usuario y una contrase帽a cuando inicia sesi贸n en un sitio web. Se refiere a la respuesta de la pregunta 驴Qui茅n eres?

- **La autorizaci贸n** se refiere al proceso de determinar si un usuario tiene el permiso adecuado para realizar una acci贸n en particular o leer datos en particular, suponiendo que el usuario se haya autenticado con 茅xito. Puede considerarse como una respuesta a la pregunta 驴Puede un usuario hacer/leer esto?

En Spring Security, cada petici贸n que se le hace al backend pasa por varios filtros, para evaluar su contenido y validar si el usuario tiene la autenticaci贸n correcta y la autorizaci贸n adecuada para acceder al servicio solicitado.

#### Proceso de Autenticaci贸n

Consideremos una aplicaci贸n web con Spring Security para autenticar usuarios. Cuando el usuario env铆a el formulario de inicio de sesi贸n:

1. `UsernamePasswordAuthenticationFilter` crea una instancia de `UsernamePasswordAuthenticationToken` con las credenciales
2. Esta instancia se pasa al `AuthenticationManager`, que delega la validaci贸n a un `AuthenticationProvider`
3. El `AuthenticationProvider` valida las credenciales, y si son correctas, crea una nueva instancia de `Authentication` con los datos del usuario
4. Si la autenticaci贸n es exitosa, el `AuthenticationManager` almacena la instancia en el contexto de seguridad y el usuario puede acceder a 谩reas protegidas
5. Si falla, se lanza una excepci贸n y el usuario es redirigido a la p谩gina de inicio de sesi贸n con un mensaje de error

El `AuthenticationProvider` es una interfaz que puede ser implementada por m煤ltiples proveedores, usando diferentes tipos de credenciales de usuario, como contrase帽as, tokens de seguridad o certificados digitales. Entre los proveedores m谩s importantes se encuentran:

- `OpenIDAuthenticationProvider`
- `JwtAuthenticationProvider`
- `OAuth2AuthenticationProvider`
- Y otros

### JWT

JSON Web Token (JWT) es un est谩ndar abierto (RFC-7519) basado en JSON para crear un token que sirva para enviar datos entre aplicaciones o servicios y garantizar que sean v谩lidos y seguros. Se considera a JWT como un m茅todo de autenticaci贸n sin estado.

El caso m谩s com煤n de uso de los JWT es para manejar la autenticaci贸n en aplicaciones m贸viles o web. Para esto:

1. El usuario se autentica enviando sus datos de inicio de sesi贸n al servidor
2. El servidor genera el JWT y se lo env铆a a la aplicaci贸n cliente
3. En cada petici贸n, el cliente env铆a este token que el servidor usa para verificar que el usuario est茅 correctamente autenticado y saber qui茅n es

#### Estructura de JWT

Los JWT tienen una estructura definida y est谩ndar basada en tres partes:

```
[Header].[Payload].[Signature]
```

- **Header (Encabezado):** contiene la lista de operaciones criptogr谩ficas que se aplican al JWT. Esta puede ser la t茅cnica de firma, informaci贸n de metadatos sobre el tipo de contenido, etc.

- **Payload (Carga 煤til):** contiene los datos reales que se transferir谩n mediante el token. Esta parte tambi茅n se conoce como la parte de "reclamaciones" del token JWT.

- **Signature (Firma):** se usa para verificar que el mensaje no se modific贸 en el camino.

Las primeras dos partes (header y payload) son strings en **base64** creados a partir de dos JSON. La tercera parte (signature) toma las otras dos partes y las encripta usando un algoritmo (normalmente SHA-256).

**Para m谩s informaci贸n:** https://jwt.io/ y https://spring.io/projects/spring-security

---

## Precauciones y Recomendaciones

- Recuerde verificar que tiene instalado el JDK de Java (preferiblemente la versi贸n 21)
- Aseg煤rese de que tiene el servidor de base de datos en ejecuci贸n (MongoDB, MySQL, PostgreSQL, etc.)
- Use un cliente REST como Postman o Insomnia para probar los servicios del backend.

---

## Evaluaci贸n o Resultado

Se espera que el estudiante logre crear la configuraci贸n necesaria para a帽adir los m茅todos de autenticaci贸n y autorizaci贸n por medio de JWT.

---

## Procedimiento

Continuaremos trabajando en el proyecto final del espacio acad茅mico que iniciamos en las gu铆as anteriores. Si no ha completado la gu铆a anterior, por favor h谩galo antes de continuar con esta.

### 1. A帽adir dependencias

A帽adir las siguientes dependencias en el archivo `build.gradle`:

```groovy
implementation 'org.springframework.boot:spring-boot-starter-security'
implementation 'io.jsonwebtoken:jjwt-api:0.13.0'
runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.13.0'
runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.13.0'
```

La primera dependencia se encarga de a帽adir los aspectos b谩sicos de Spring Security, las tres siguientes est谩n relacionadas a JWT.

Elimine la dependencia de `spring-security-crypto` si ya la tiene, ya que `spring-boot-starter-security` la incluye.

> 锔 **Importante:** Recuerde sincronizar el proyecto con Gradle para que las nuevas dependencias se descarguen e instalen correctamente.

### 2. Verificar seguridad activada

Ejecute el proyecto e intente acceder a algunas de las rutas de la API. Deber铆a evidenciar un bloqueo total del acceso a la API, ya que se activa un mecanismo de seguridad que restringe cualquier solicitud no autorizada.

### 3. Crear paquete de seguridad

Crear un paquete con el nombre `co.edu.uniquindio.application.security` donde se alojar谩n las clases relacionadas con la seguridad de la aplicaci贸n y la configuraci贸n de Spring Security.

### 4. Crear clase `JWTUtils`

Dentro del paquete de seguridad, cree la clase `JWTUtils`:

```java
package co.edu.uniquindio.application.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import org.springframework.stereotype.Component;
import javax.crypto.SecretKey;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.Map;

@Component
public class JWTUtils {
    
    public String generateToken(String id, Map<String, String> claims) {
        Instant now = Instant.now();
        return Jwts.builder()
                .claims(claims)
                .subject(id)
                .issuedAt(Date.from(now))
                .expiration(Date.from(now.plus(1L, ChronoUnit.HOURS)))
                .signWith(getKey())
                .compact();
    }
    
    public Jws<Claims> parseJwt(String jwtString) throws ExpiredJwtException,
            UnsupportedJwtException, MalformedJwtException, IllegalArgumentException {
        JwtParser jwtParser = Jwts.parser().verifyWith(getKey()).build();
        return jwtParser.parseSignedClaims(jwtString);
    }
    
    private SecretKey getKey(){
        String secretKey = "secretsecretsecretsecretsecretsecretsecretsecret";
        byte[] secretKeyBytes = secretKey.getBytes();
        return Keys.hmacShaKeyFor(secretKeyBytes);
    }
}
```

Esta clase `JWTUtils` contiene m茅todos importantes como:
- Crear el token JWT con el m茅todo `generateToken()`
- Firmar el token usando la clave secreta con el m茅todo `getKey()`
- Validar y decodificar el token con el m茅todo `parseJwt()`

Los m茅todos de esta clase son de utilidad para los mecanismos de autorizaci贸n as铆 como en los servicios de negocio de login y registro. En el m茅todo `generateToken()` podemos agregar m谩s informaci贸n al Token agregando m谩s `claim()` (clave-valor).

> 锔 **NOTA:** Haga que la clave secreta venga dada desde el archivo `application.properties`.

### 5. Crear clase `JWTFilter`

En el mismo paquete agregue la clase `JWTFilter`:

```java
package co.edu.uniquindio.application.security;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;

@Component
@RequiredArgsConstructor
public class JWTFilter extends OncePerRequestFilter{
    
    private final JWTUtils jwtUtil;
    private final UserDetailsServiceImpl userDetailsService;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException {
        
        // Obtener el token del header de la solicitud
        String token = getToken(request);
        
        // Si no hay token, continuar con la cadena de filtros
        if (token == null) {
            chain.doFilter(request, response);
            return;
        }
        
        try {
            // Validar el token y obtener el payload
            Jws<Claims> payload = jwtUtil.parseJwt(token);
            String username = payload.getPayload().getSubject();
            
            // Si el usuario no est谩 autenticado, crear un nuevo objeto de autenticaci贸n
            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                
                // Crear un objeto UserDetails con el nombre de usuario y el rol
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                
                // Crear un objeto de autenticaci贸n y establecerlo en el contexto de seguridad
                UsernamePasswordAuthenticationToken authentication = new 
                        UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                        );
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            // Si el token no es v谩lido, enviar un error 401
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Unauthorized");
            return;
        }
        
        // Continuar con la cadena de filtros
        chain.doFilter(request, response);
    }
    
    private String getToken(HttpServletRequest req) {
        String header = req.getHeader("Authorization");
        return header != null && header.startsWith("Bearer ") ? header.replace("Bearer ", "") : null;
    }
}
```

En esta clase se verifica que el token enviado desde alguna solicitud desde el frontend sea v谩lido para comprobar los datos enviados y validar que el usuario que envi贸 la solicitud s铆 exista.

### 6. Crear clase `AutenticacionEntryPoint`

En el mismo paquete agregue la clase `AutenticacionEntryPoint`:

```java
package co.edu.uniquindio.application.security;

import co.edu.uniquindio.application.dto.ResponseDTO;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;
import org.springframework.security.core.AuthenticationException;

import java.io.IOException;

@Component
public class AutenticacionEntryPoint implements AuthenticationEntryPoint {
    
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                        AuthenticationException authException) throws IOException {
        
        ResponseDTO<String> dto = new ResponseDTO<>(true, "No tienes permisos para acceder a este recurso");
        response.setContentType("application/json");
        response.setStatus(403);
        response.getWriter().write(new ObjectMapper().writeValueAsString(dto));
        response.getWriter().flush();
        response.getWriter().close();
    }
}
```

En esta clase se lanza la excepci贸n asociada a la solicitud del usuario (en el m茅todo `commence`). Si la solicitud es v谩lida este m茅todo no se invoca, s贸lo se invoca si hay excepciones que se le debe notificar al usuario como cuando el token es incorrecto, est谩 vencido o es requerido.

> **锔 Importante:** Debe tener el DTO `ResponseDTO` creado en el paquete `co.edu.uniquindio.application.dto`.

### 7. Crear UserDetailsServicioImpl

En el paquete `co.edu.uniquindio.application.service.impl` cree la clase `UserDetailsServicioImpl`:

```java
package co.edu.uniquindio.application.service.impl;

import co.edu.uniquindio.application.model.User;
import co.edu.uniquindio.application.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.bson.types.ObjectId;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        
        if(!ObjectId.isValid(username)) {
            throw new UsernameNotFoundException("ID de usuario inv谩lido");
        }

        User user = userRepository.findById(new ObjectId(username))
                .orElseThrow(() -> new UsernameNotFoundException("Usuario no encontrado"));
        
        List<GrantedAuthority> authorities = new ArrayList<>();
        authorities.add(new SimpleGrantedAuthority(user.getRole().name()));

        return new User(
                user.getId().toString(),
                user.getPassword(),
                authorities
        );
    }
}
```

Esta clase valida que el usuario presente en el token JWT exista en el sistema y permite extraer su rol y dem谩s datos necesarios. Spring Security utiliza el objeto `UserDetails` para representar al usuario autenticado y mantener su informaci贸n en el contexto de seguridad durante las peticiones.

### 8. Crear SecurityConfig

Crear una nueva clase con el nombre `SecurityConfig` en el paquete `co.edu.uniquindio.application.config`:

```java
package co.edu.uniquindio.application.config;

import co.edu.uniquindio.application.security.AuthenticationEntryPoint;
import co.edu.uniquindio.application.security.JWTFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {
    
    private final JWTFilter jwtFilter;
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // Configura la seguridad HTTP para la aplicaci贸n
        http
            .csrf(AbstractHttpConfigurer::disable)
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            .sessionManagement(session -> 
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(req -> req
                .requestMatchers("/api/auth/**").permitAll()
                .anyRequest().authenticated()
            )
            .exceptionHandling(ex -> ex.authenticationEntryPoint(new AutenticacionEntryPoint()))
            .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        // Configura las pol铆ticas de CORS para permitir solicitudes desde el frontend
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(List.of("*"));
        config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        config.setAllowedHeaders(List.of("*"));
        config.setAllowCredentials(true);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        // Permite codificar y verificar contrase帽as utilizando BCrypt
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration configuration) 
            throws Exception {
        // Proporciona un AuthenticationManager para la autenticaci贸n de usuarios
        return configuration.getAuthenticationManager();
    }
}
```

Esta es la clase principal de configuraci贸n de Spring Security. Se destaca el m茅todo `securityFilterChain()`, que tiene la responsabilidad de hacer la comprobaci贸n de autenticaci贸n del usuario para indicar si se puede proceder con la solicitud o no.

De este m茅todo se destaca la siguiente parte:

```java
http.authorizeHttpRequests(req -> req
    .requestMatchers("/api/auth/**").permitAll()
    .anyRequest().authenticated()
);
```

Esta l铆nea de c贸digo indica que todas las solicitudes que comiencen con "/api/auth/" son permitidas, incluso las de swagger ("/swagger-ui/**", "/v3/api-docs/**") deber铆an ser permitidas, pero las dem谩s solo son permitidas si el usuario est谩 autenticado con un token.

> **锔 IMPORTANTE:** Estas rutas deben coincidir con las definidas en los diferentes `RestController`.

**Para m谩s informaci贸n:** https://medium.com/@espinozajge/protegiendo-tu-aplicaci%C3%B3n-web-con-spring-security-y-autenticaci%C3%B3n-basada-en-tokens-jwt-1321cbe4c4c3

### 9. Ejemplos de configuraci贸n de rutas

A manera de ejemplo, si queremos que cualquier usuario pueda acceder a cualquier ruta tenga o no la autorizaci贸n, podemos escribir:

```java
http.authorizeHttpRequests(req -> req.anyRequest().permitAll());
```

O si queremos que todas las rutas est茅n protegidas (se requiere autenticaci贸n):

```java
http.authorizeHttpRequests(req -> req.anyRequest().authenticated());
```

Tambi茅n se pueden validar aspectos de la ruta relacionados con el m茅todo HTTP correspondiente:

```java
http.authorizeHttpRequests(req -> req
    .requestMatchers(HttpMethod.POST, "/api/users").permitAll()
);
```

Incluso, y lo m谩s importante, se puede restringir el acceso a las rutas seg煤n el rol del usuario definido en el token de autenticaci贸n:

```java
http.authorizeHttpRequests(req -> req
    .requestMatchers("/api/users/**").hasAuthority("ROLE_USER")
);
```

### 10. Modificar registro de usuarios

Dado que JWT requiere de cifrado de contrase帽as, modifique el m茅todo de registro de usuarios nuevos de la clase `UsuarioServicioImpl` para que se use `PasswordEncoder`:

```java
// Se mapea el DTO a un documento
User newUser = userMapper.toDocument(createUserDTO);

// Se codifica la contrase帽a
newUser.setPassword(passwordEncoder.encode(createUserDTO.password()));
```

Para cifrar la contrase帽a se hace uso del m茅todo `encode` de `passwordEncoder`.

### 11. A帽adir `PasswordEncoder` al servicio

A la clase `UsuarioServicioImpl` a帽ada el atributo `passwordEncoder` e inicial铆celo ya sea con `@Autowired` o en el constructor de la clase (con `@RequiredArgsConstructor`):

```java
private final PasswordEncoder passwordEncoder;
```

### 12. Implementar servicio de login

Finalmente, el servicio de negocio para hacer login (iniciar sesi贸n):

```java
public TokenDTO login(LoginDTO loginDTO) throws Exception {
    Optional<User> optionalUser = userRepository.findByEmail(loginDTO.email());

    if(optionalUser.isEmpty()){
        throw new Exception("El usuario no existe");
    }

    User user = optionalUser.get();

    // Verificar si la contrase帽a es correcta usando el PasswordEncoder
    if(!passwordEncoder.matches(loginDTO.password(), user.getPassword())){
        throw new Exception("El usuario no existe");
    }

    String token = jwtUtils.generateToken(user.getId().toString(), createClaims(user));
    return new TokenDTO(token);
}

private Map<String, String> createClaims(User user){
    return Map.of(
        "email", user.getEmail(),
        "name", user.getName(),
        "role", "ROLE_"+user.getRole().name()
    );
}
```

> **锔 NOTA:** Es necesario crear un nuevo DTO con el nombre `TokenDTO`, este DTO s贸lo tiene el atributo `token` de tipo `String`.

### 13. Acceder al ID del usuario autenticado

Si necesita acceder al ID del usuario que est谩 almacenado en el token de autenticaci贸n de la solicitud dentro de un m茅todo en los servicios de negocio, puede hacerlo de la siguiente manera:

```java
User user = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
String idUser = user.getUsername();
```

Esto nos devuelve el ID y con 茅l podemos verificar cosas relacionadas a la seguridad. Por ejemplo, con esto podemos validar que un usuario solo pueda editar sus propios datos personales, no los de otra persona.

Tenga en cuenta que debe agregar los siguientes imports a la clase que lo requiera:

```java
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;
```

### 14. Control de versiones

Recuerde hacer commit de sus avances en el repositorio de git.

---

## Para la pr贸xima clase

- Qu茅 es Oauth2 y OpenID.
- Qu茅 servicios de autenticaci贸n existen en la nube (Firebase, Auth0, Okta, etc.) y por qu茅 delegarlos a un tercero.
- Investigar qu茅 es Angular, programaci贸n funcional y programaci贸n reactiva.
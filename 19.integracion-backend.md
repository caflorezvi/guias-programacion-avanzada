```
Programa de Ingenier铆a de Sistemas y Computaci贸n
Universidad del Quind铆o

T铆tulo: Integraci贸n con la API del backend
Duraci贸n estimada: 120
Docentes: Carlos Andr茅s Florez
Gu铆a: 19
```

# Integraci贸n con la API del backend 

##  Objetivo 

Integrar una aplicaci贸n frontend desarrollada en Angular con una API REST implementada mediante en Spring Boot, incluyendo la gesti贸n de autenticaci贸n mediante tokens JWT.

---

## Conceptos b谩sicos

- **Lenguaje de programaci贸n TypeScript**: Superset de JavaScript que a帽ade tipado est谩tico y otras caracter铆sticas.
- **Servicios en Angular**: Clases que proporcionan funcionalidades espec铆ficas y pueden ser compartidas entre diferentes componentes de una aplicaci贸n Angular. Se utilizan para manejar la l贸gica de negocio, interactuar con APIs, gestionar el estado de la aplicaci贸n, entre otros.
- **Componentes en Angular**: Bloques reutilizables de c贸digo que encapsulan la l贸gica, la plantilla HTML y los estilos CSS para crear partes independientes de una aplicaci贸n web.
- **API REST**: Conjunto de reglas y convenciones para construir y consumir servicios web que permiten la comunicaci贸n entre diferentes sistemas a trav茅s de HTTP.
- **JWT (JSON Web Token)**: Est谩ndar abierto para la transmisi贸n segura de informaci贸n entre partes como un objeto JSON. Se utiliza com煤nmente para la autenticaci贸n y autorizaci贸n en aplicaciones web.

---

## Contextualizaci贸n Te贸rica

Como se ha visto en las gu铆as anteriores, **Angular es un framework frontend** que nos permite crear aplicaciones web de una sola p谩gina (SPA - Single Page Application) y **Spring Boot es un framework backend** que nos permite crear APIs REST para gestionar la l贸gica del negocio y la persistencia de datos en una base de datos.

Para conectarnos a una API desde Angular, **es necesario crear un servicio** que se encargue de manejar las solicitudes HTTP hacia el backend. Este servicio actuar谩 como intermediario entre los componentes de la aplicaci贸n y la API REST.

Una vez creado dicho servicio, se puede utilizar el m贸dulo `HttpClient` de Angular para realizar las solicitudes HTTP. `HttpClient` es un servicio que proporciona una serie de funciones para enviar y recibir datos a trav茅s de HTTP. Algunas de sus caracter铆sticas principales son:

- La capacidad de solicitar objetos de respuesta tipados (generalmente mediante JSON).
- Manejo de errores simplificado.
- Caracter铆sticas para la implementaci贸n de pruebas.
- Intercepci贸n de solicitudes y respuestas.
- Manejo de peticiones as铆ncronas mediante `Observable`.

Para conectar con la API del backend utilizaremos su ruta HTTP. Es importante recordar que cada clase anotada con `@RestController` define, a trav茅s de `@RequestMapping`, la ruta del servicio correspondiente. Luego, accederemos a dicha ruta mediante un `Observable`, que b谩sicamente es una **funci贸n as铆ncrona** encargada de obtener o extraer la respuesta de la API.

La arquitectura t铆pica de trabajo entre Angular y Spring Boot se puede ilustrar en la siguiente imagen.

![Arquitectura t铆pica de trabajo entre Angular y Spring Boot](/media/back-front.png)

*Imagen tomada de: [https://github.com/anasmak04/Gestion-des-stagiaires-Projet-fil-rouge?tab=readme-ov-file](https://github.com/anasmak04/Gestion-des-stagiaires-Projet-fil-rouge?tab=readme-ov-file).*

Podemos destacar que los componentes que realmente establecen la conexi贸n entre el frontend y el backend son el `@RestController`, en el lado del servidor, y el `HttpClient`, en el lado del cliente. Ambos interact煤an intercambiando informaci贸n que, a su vez, es gestionada por distintos objetos y capas de menor jerarqu铆a, encargados de procesar la solicitud de manera adecuada.

Para m谩s informaci贸n:

- [https://angular.dev/tutorials/first-app/09-services](https://angular.dev/tutorials/first-app/09-services)
- [https://angular.dev/guide/http](https://angular.dev/guide/http)
- [https://medium.com/@henriquezcontrerasc/desarrollando-aplicaciones-web-con-spring-boot-y-angular-modelos-jpa-servicios-controladores-86f90b95d0f2](https://medium.com/@henriquezcontrerasc/desarrollando-aplicaciones-web-con-spring-boot-y-angular-modelos-jpa-servicios-controladores-86f90b95d0f2)

---

## Precauciones y Recomendaciones

Verifique que tiene instalado NodeJS en su 煤ltima versi贸n para poder compilar y ejecutar la aplicaci贸n de Angular. Tenga en cuenta que **el proyecto del backend construido con Spring Boot debe estar en ejecuci贸n** para que la integraci贸n funcione correctamente. 

No olvide configurar correctamente los endpoints y puertos en los servicios de Angular para que coincidan con los definidos en el backend. Aseg煤rese de manejar adecuadamente los errores en las solicitudes HTTP para mejorar la experiencia del usuario y facilitar la depuraci贸n.

---

## Evaluaci贸n o Resultado

Se espera que el estudiante aprenda a programar la correcta integraci贸n de la API REST de servicios que proporciona el backend hecha con Spring Boot, con la aplicaci贸n frontend desarrollada en Angular y as铆 poder enviar informaci贸n para que se guarde en la base de datos o consultarla para mostrarla en las diferentes p谩ginas web del proyecto.

---

## Procedimiento

### 1. Creaci贸n de servicios b谩sicos

Para iniciar la integraci贸n de Angular con la API REST de Spring Boot es necesario crear varios servicios. Como ya vimos, un servicio es un proveedor de datos, contiene l贸gica que no necesitamos s贸lo en un componente, sino que los podemos usar en varios componentes por toda la aplicaci贸n; estos servicios se inyectan en los componentes que los necesitan mediante el constructor.

Primero vamos a crear el servicio para gestionar el token de autenticaci贸n, escriba lo siguiente en el cmd de Windows o en la terminal de GNU/Linux o Mac (recuerde ejecutar esto en la carpeta **services** del proyecto de Angular):

```bash
ng generate service token-service --skip-tests
```

Otro servicio que es necesario es el que usaremos para conectarnos con en el endpoint `api/auth` de la API de Spring Boot.

```bash
ng generate service auth-service --skip-tests
```

Lo ideal es que cada endpoint de la API REST tenga un servicio correspondiente en Angular. Estos servicios ser谩n utilizados por los componentes, los cuales delegan en ellos la responsabilidad de acceder a la informaci贸n y realizar operaciones sobre los datos.

### 2. Configuraci贸n del servicio de token

Modifique el archivo `token-service.ts` a帽adiendo una constante que se llame `TOKEN_KEY` y que tenga el valor `"AuthToken"`, as铆:

```typescript
import { Injectable } from '@angular/core';

const TOKEN_KEY = "AuthToken";

@Injectable({
  providedIn: 'root'
})
export class TokenService {
  constructor() { }
}
```

Adicionalmente agregue las siguientes funciones:

- `setToken()`: Esta funci贸n permite guardar el token devuelto por el backend una vez nos autenticamos por medio del formulario de login. El token se guarda en `sessionStorage` que es un objeto de almacenamiento del navegador web.

```typescript
private setToken(token: string) {
  window.sessionStorage.removeItem(TOKEN_KEY);
  window.sessionStorage.setItem(TOKEN_KEY, token);
}
```

- `getToken()`: Con esta funci贸n podemos acceder al token guardado en el `sessionStorage`.

```typescript
public getToken(): string | null {
  return sessionStorage.getItem(TOKEN_KEY);
}
```

- `isLogged()`: Para que podamos verificar en cualquier momento si estamos logueados o no se recomienda implementar la siguiente funci贸n.

```typescript
public isLogged(): boolean {
  if (this.getToken()) {
    return true;
  }
  return false;
}
```

- Es necesario contar con la funci贸n de `login()` para "Iniciar sesi贸n", b谩sicamente esta funci贸n guarda el token en el `sessionStorage`.

```typescript
public login(token: string) {
  this.setToken(token);    
}
```

- Finalmente, tambi茅n es necesario contar con la funci贸n de `logout()` para "cerrar sesi贸n", esta funci贸n borra el token del `sessionStorage`.

```typescript
public logout() {
  window.sessionStorage.clear();
}
```

### 3. Decodificaci贸n del payload del token

Dado que el Token contiene informaci贸n cifrada referente al correo electr贸nico del usuario, su rol y otros datos, entonces es 煤til contar con la funci贸n `decodePayload()` para poder descifrar esta informaci贸n. Como vimos anteriormente el Token est谩 compuesto por tres partes que son el `header`, `payload` y `signature`. El `payload` es el que contiene estos datos (est谩 ubicado en la posici贸n 1 si se divide el token por `"."`).

Agregue la siguiente funci贸n a la clase anterior:

```typescript
private decodePayload(token: string): any {
  const payload = token!.split(".")[1];
  const base64 = payload.replace(/-/g, '+').replace(/_/g, '/');
  const decodedPayload = atob(base64);
  return JSON.parse(decodedPayload);
}
```

El token est谩 cifrado en **String Base64**, para descifrarlo debemos hacer uso de la funci贸n `atob()` y luego retornamos el `payload` como un JSON.

### 4. Funciones para leer datos del token

Agregue algunas funciones a la clase TokenService para poder leer los datos del Payload del token JWT. Por ejemplo, para leer el id del usuario o su rol, puede agregar las siguientes:

```typescript
public getUserId(): string {
  const token = this.getToken();
  if (token) {
    const values = this.decodePayload(token);
    return values.sub;
  }
  return "";
}

public getRole(): string {
  const token = this.getToken();
  if (token) {
    const values = this.decodePayload(token);
    return values.role;
  }
  return "";
}
```

Cada funci贸n obtiene el token del `sessionStorage`, si el token existe, entonces se decodifica el `payload` y se retorna el valor correspondiente. En caso de que no exista el token, se retorna una cadena vac铆a.

> 锔 **Importante:** Se asume que el token JWT generado desde el backend tiene en sus claims el campo `sub` (subject) y `role`. Si en su caso no los tiene o se llaman diferente debe hacer el ajuste correspondiente.

### 5. Configuraci贸n de HttpClient

Modifique el archivo `app.config.ts` que est谩 dentro de la carpeta `app` y a帽ada lo siguiente:

Al inicio del archivo escriba el `import`:

```typescript
import { provideHttpClient } from '@angular/common/http';
```

Dentro de la lista de `providers` agregue:

```typescript
provideHttpClient()
```

Este m贸dulo nos permitir谩 realizar peticiones HTTP `GET`, `POST`, `PUT`, `DELETE`, etc, Desde nuestra aplicaci贸n de Angular a una API cualquiera, en nuestro caso la API ser谩 la que hicimos con Spring Boot.

### 6. Implementaci贸n del servicio de autenticaci贸n

Modifique el archivo `auth-service.ts` a帽adiendo un atributo que indique la URL del endpoint, adem谩s agregue `HttpClient` en el constructor as铆:

```typescript
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private authURL = "http://localhost:8080/api/auth";

  constructor(private http: HttpClient) { }
}
```

y agregue las siguientes funciones:

```typescript
public login(loginDTO: LoginDTO): Observable<ResponseDTO> {
  return this.http.post<ResponseDTO>(`${this.authURL}/login`, loginDTO);
}
```

> 锔 **Nota:** Organice los endpoints de acuerdo a las rutas de su controlador de autenticaci贸n (`AuthController`) del backend, y utilice el puerto correcto.

`HttpClient` utiliza m茅todos como `post()`, `get()`, `delete()` y `put()` para realizar solicitudes HTTP de forma as铆ncrona al backend. En este caso, la funci贸n `login()` usa el m茅todo `post()` porque se comunica con un endpoint del backend que est谩 anotado con `@PostMapping` en Spring Boot, lo que indica que acepta solicitudes HTTP POST.

Estos m茅todos devuelven un `Observable`, que **representa una secuencia de datos que puede ser emitida de forma as铆ncrona**. Esto permite suscribirse a la respuesta de la API y manejar los datos cuando est茅n disponibles, as铆 como gestionar errores o finalizar procesos una vez completada la solicitud. El uso de `Observable` facilita la programaci贸n reactiva en Angular, promoviendo un flujo de datos m谩s flexible y eficiente.

Para m谩s informaci贸n: [https://angular.io/guide/observables](https://angular.io/guide/observables)

### 7. Creaci贸n de interfaces DTO

Debe crear las interfaces `LoginDTO` y `ResponseDTO`, ya que el backend usa objetos de este tipo. Los DTO se deben crear en la carpeta **models** del proyecto de Angular. 

Para crear la interface `LoginDTO` puede hacerlo as铆:

```bash
ng generate interface LoginDTO
```

Este DTO debe tener los mismos atributos que el DTO del backend, entonces si en el backend tenemos la clase `LoginDTO` con `email` y `password` (ver m谩s abajo), entonces el DTO en Angular debe quedar igual. Por ejemplo:

**Backend (Java)**

```java
package co.edu.uniquindio.application.dto.user;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public record LoginDTO(
        @Email @NotBlank String email,
        @NotBlank String password
) {
}
```

**Frontend (TypeScript)**

```typescript
export interface LoginDTO {
    email: string,
    password: string
}
```

As铆 mismo cree la interface `ResponseDTO` que usaremos para manejar las respuestas del backend. Puede crearla as铆:

```bash
ng generate interface ResponseDTO
```

**Backend (Java)**

```java
package co.edu.uniquindio.application.dto;

public record ResponseDTO<T>(
    boolean error,
    T content
) {
}
```

**Frontend (TypeScript)**

```typescript
export interface ResponseDTO {
    error: boolean,
    content: any
}
```

Observe que es importante que los atributos de ambas clases tengan los mismos nombres y los mismos tipos de datos.

### 8. Inyecci贸n de servicios el el componente de login

Agregue en el constructor del componente `Login` los dos servicios creados previamente, as铆:

```typescript
constructor(private authService: AuthService, private tokenService: TokenService) {
  ...
}
```

Al agregar estas variables en el constructor se inicializan autom谩ticamente gracias a la inyecci贸n de dependencias. Recuerde hacer el `import` correspondiente de las clases `AuthService` y `TokenService`. **Si el constructor tiene m谩s par谩metros no los borre.**

### 9. Integraci贸n del servicio de autenticaci贸n

Modifique la funci贸n `login()` de dicha clase para que quede as铆:

```typescript
public login() {
  // Obtenemos los datos del formulario y los convertimos a LoginDTO
  const loginDTO = this.loginForm.value as LoginDTO;

  this.authService.login(loginDTO).subscribe({
    next: (data) => {
      this.tokenService.login(data.content.token); // Guardamos el token usando el servicio de token
      this.router.navigate(['/']).then(() => window.location.reload()); // Redireccionamos al inicio y recargamos la p谩gina
    },
    error: (error) => {
      Swal.fire({
        icon: 'error',
        title: 'Error',
        text: error.error.content // Mostramos el mensaje de error del backend
      });
    }
  });
}
```

Utilizamos el servicio `authService` para invocar la funci贸n `login()`, a la que se le pasa un objeto `LoginDTO` con los datos recolectados desde el formulario. **Mediante la funci贸n `subscribe()` nos suscribimos al `Observable` retornado por el servicio.** Si la respuesta es exitosa, se ejecuta el callback `next()`, donde se pueden procesar los datos recibidos. En caso de que ocurra un error, este se captura en el callback `error()`, permitiendo mostrar mensajes o realizar acciones correspondientes. En ambos casos, la respuesta proviene del backend, ya sea con datos v谩lidos o con informaci贸n sobre el error.

No olvide agregar `Router` en el constructor para poder hacer la redirecci贸n al inicio una vez el login sea exitoso, as铆 como hacer el `import` correspondiente:

```typescript
import { Router } from '@angular/router';
...
constructor(private router: Router) {
  ...
}
```

Adem谩s, se recomienda usar la librer铆a `SweetAlert2` (que se explic贸 en la gu铆a anterior) para informarle al usuario acerca de todas las respuestas del backend. Recuerde que para poder usarla debe agregar el `import` en la parte superior del archivo.

### 10. Prueba del login

Ingrese a la p谩gina de login y compruebe que los mensajes funcionan correctamente. Pruebe escribiendo datos incorrectos para que aparezca la alerta, tambi茅n pruebe con datos de acceso v谩lidos y verifique que lo redirecciona al inicio. **Para probar esto, el servidor de Spring Boot debe estar en ejecuci贸n.**

> 锔 **Importante:** Recuerde tener presente que se debe verificar si el usuario tiene la cuenta activa o inactiva para poder hacer la redirecci贸n adecuada. Tambi茅n es importante que el **backend est茅 configurado** para permitir peticiones desde el frontend (CORS).

### 11. Verificaci贸n del token en el navegador

Cuando el login sea correcto, vaya a las herramientas de desarrolladores del navegador web (F12), luego vaya a la pesta帽a Application (o Storage seg煤n el navegador), en la parte izquierda elija Session storage - [http://localhost:4200](http://localhost:4200) y all铆 debe aparecer el token de sesi贸n que nos devolvi贸 el backend.

La llave `AuthToken` contiene el valor del token JWT que representa la sesi贸n del usuario en el frontend.

### 12. Creaci贸n del servicio de usuarios

Cree un nuevo servicio, este servicio lo usaremos para conectarnos con los endpoints del usuario (donde est谩 crear, eliminar, actualizar, obtener, etc.).

Para crear el servicio en el frontend escriba lo siguiente en el cmd de Windows o en la terminal de GNU/Linux o MacOS en la carpeta **services** del proyecto:

```bash
ng generate service user-service --skip-tests
```

### 13. Implementaci贸n del servicio de usuarios

Modifique el archivo `user-service.ts` a帽adiendo un atributo que indique la URL del endpoint, adem谩s agregue `HttpClient` en el constructor as铆:

```typescript
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class UserService {
  private usersURL = "http://localhost:8080/api/users";

  constructor(private http: HttpClient) { }
}

```

y agregue las siguientes funciones:

```typescript
public create(createUserDTO: CreateUserDTO): Observable<ResponseDTO> {
  return this.http.post<ResponseDTO>(this.usersURL, createUserDTO);
}

public edit(editUserDTO: EditUserDTO): Observable<ResponseDTO> {
  return this.http.put<ResponseDTO>(this.usersURL, editUserDTO);
}

public delete(id: string): Observable<ResponseDTO> {
  return this.http.delete<ResponseDTO>(`${this.usersURL}/${id}`);
}

public get(id: string): Observable<ResponseDTO> {
  return this.http.get<ResponseDTO>(`${this.usersURL}/${id}`);
}

// Permite obtener los alojamientos de un usuario paginados
public getPlaces(id: string, page: number): Observable<ResponseDTO> {
  return this.http.get<ResponseDTO>(`${this.usersURL}/${id}/places`, { params: { page } }); // Si el backend usa @RequestParam para paginaci贸n se debe enviar as铆
}
```

> 锔 **Importante:** Organice los endpoints de acuerdo a las rutas de su controlador de usuarios del backend (`UserController`), los m茅todos HTTP deben coincidir con los definidos en el backend. Adem谩s, utilice el puerto correcto.

Debe crear las interfaces `CreateUserDTO` y `EditUserDTO` as铆 como hicimos en el punto 7 de esta gu铆a. Es importante tener en cuenta que todos los DTO tambi茅n pueden crearse en un 煤nico archivo de TypeScript, agrup谩ndolos por interfaces.

### 14. Inyecci贸n del servicio en el componente de registro

En el constructor del componente `Registro` agregue el servicio `UserService`, como ya hemos hecho con los dem谩s servicios, as铆:

```typescript
constructor(private userService: UserService) {
  ...
}
```

Recuerde hacer el `import` correspondiente de la clase `UserService`. **Si el constructor tiene m谩s par谩metros no los borre.**

### 15. Implementaci贸n del registro

Luego, modifique la funci贸n `createUser()` de dicha clase para que quede as铆:

```typescript
public createUser() {
  // Obtenemos los datos del formulario y los convertimos a CreateUserDTO
  const createUserDTO = this.registerForm.value as CreateUserDTO;

  this.userService.create(createUserDTO).subscribe({
    next: (data) => {
      // Mostramos el mensaje de 茅xito del backend
      Swal.fire({
        title: 'xito',
        text: data.content,
        icon: 'success'
      });
    },
    error: (error) => {
      // Mostramos el mensaje de error del backend
      Swal.fire({
        title: 'Error',
        text: error.error.content,
        icon: 'error'
      });
    }
  });
}
```

### 16. Prueba del registro

Ingrese a la p谩gina de registro y compruebe que los mensajes funcionan correctamente. Ingrese alg煤n correo repetido y verifique que s铆 se muestre el mensaje de error, luego haga un registro con los datos correctos y verifique que se muestra el mensaje adecuado. **Para probar esto, el servidor de Spring Boot debe estar en ejecuci贸n.**

### 17. Actualizaci贸n del servicio de alojamientos

Con base en lo explicado anteriormente, modifique el servicio `PlacesService` para que integre los endpoints de la API de alojamientos haciendo uso de `HttpClient` y `Observable`. Recuerde eliminar la funci贸n `createTestPlaces()` y la variable `places` ya que ahora los alojamientos se obtendr谩n desde el backend.

```typescript
import { HttpClient, HttpParams } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { ResponseDTO } from '../models/response-dto';
import { CreatePlaceDTO } from '../models/create-place-dto';
import { EditPlaceDTO } from '../models/edit-place-dto';

@Injectable({
  providedIn: 'root'
})
export class PlacesService {

  private placesURL = "http://localhost:8080/api/places";

  constructor(private http: HttpClient) { }

  public create(createPlaceDTO: CreatePlaceDTO): Observable<ResponseDTO> {
    return this.http.post<ResponseDTO>(this.placesURL, createPlaceDTO);
  }

  public edit(id: number, editPlaceDTO: EditPlaceDTO): Observable<ResponseDTO> {
    return this.http.put<ResponseDTO>(`${this.placesURL}/${id}`, editPlaceDTO);
  }

  public delete(id: number): Observable<ResponseDTO> {
    return this.http.delete<ResponseDTO>(`${this.placesURL}/${id}`);
  }

  public getById(id: number): Observable<ResponseDTO> {
    return this.http.get<ResponseDTO>(`${this.placesURL}/${id}`);
  }

  public getAll(
    page: number, 
    filters?: { 
      city?: string;
      // Agregar m谩s filtros si es necesario
    }
  ): Observable<ResponseDTO> {

    // Se utiliza HttpParams para enviar los par谩metros como @RequestParam. Dado que page es obligatorio, se inicializa con ese valor.
    let params = new HttpParams().set('page', page.toString());

    // Si se env铆an filtros, se agregan a los par谩metros
    if (filters) {
      if (filters.city) params = params.set('city', filters.city);
      // Agregar m谩s filtros si es necesario
    }

    return this.http.get<ResponseDTO>(this.placesURL, { params });
  }

}
```

Observe que cada funci贸n est谩 asociada a un m茅todo HTTP y, al igual que el servicio de autenticaci贸n, el servicio de alojamientos utiliza su propia URL (endpoint). **Se destaca la 煤ltima funci贸n `getAll()`, ya que, si se requiere enviar par谩metros que Spring Boot interpreta como @RequestParam, estos deben ser enviados de esa manera.**

Puede que su puerto e incluso los endpoints sean diferentes, debe comprobarlo con su implementaci贸n de los controladores del backend. Es importante resaltar que estas no son todas las funciones que debe tener la clase `PlacesService`, solo se muestran estas a manera de ejemplo, usted debe agregar las funciones que falten.

> 锔 **Importante:** Cree los DTO necesarios para el correcto funcionamiento del servicio y modifique `PlaceDTO` para que coincida con el que retorna el backend (en el caso de la funci贸n `get()` y `getAll()`).

### 18. Modificaci贸n del componente Home

Modifique la funci贸n `ngOnInit()` del componente `Home` para que consulte los alojamientos desde el backend y cuando llegue la respuesta, se debe crear el mapa y se dibuja los marcadores, para que quede as铆:

```typescript
ngOnInit(): void {
  this.getPlaces(0); // Obtener los alojamientos desde el backend usando paginaci贸n
}

public getPlaces(page: number) {
  this.placesService.getAll(page).subscribe({
    next: (data) => {
      this.mapService.create(); // Crear el mapa cuando ya se tienen los alojamientos
      this.mapService.drawMarkers(data.content);  // Recuerde mapear la respuesta a MarkerDTO.
    },
    error: (error) => {
      Swal.fire('Error!', "Error al obtener los alojamientos", 'error');
    }
  });
}
```

### 19. Verificaci贸n de alojamientos en el inicio

Ingrese a la p谩gina de inicio y compruebe que los alojamientos si se est谩n cargando correctamente desde el backend. **Para probar esto, el servidor de Spring Boot debe estar en ejecuci贸n. Y se asume que debe tener alojamientos creados en la base de datos con ubicaciones v谩lidas.**

### 20. Servicios de alojamiento y ciudades

**Cree dos nuevos servicios: uno para los servicios del alojamiento y otro para las ciudades.** Cada servicio debe implementar todos los endpoints correspondientes de la API, utilizando `HttpClient` y `Observable`. Si las ciudades est谩n definidas como una enumeraci贸n en el backend, debe crear un `RestController` que exponga la lista de ciudades. En caso contrario, si las ciudades se representan como cadenas de texto (strings), no ser谩 necesario implementar el servicio para ciudades.

Recuerde que para crear los servicios debe escribir lo siguiente en el cmd de Windows o en la terminal de GNU/Linux o MacOS en la carpeta **services** del proyecto:

```bash
ng generate service place-services-service --skip-tests
```

```bash
ng generate service city-service --skip-tests
```

### 21. Inyecci贸n de los servicios de alojamiento en `CreatePlace`

Agregue en el constructor del componente `CreatePlace` el servicio que obtiene los servicios de alojamiento creado en el punto anterior. As铆 como hemos hecho con los dem谩s servicios.

### 22. Consultar los servicios de alojamiento

Dado que al momento de crear un alojamiento es necesario que el usuario pueda seleccionar uno o varios servicios para el alojamiento, entonces es necesario obtener la lista de servicios desde el backend.

Agregue el m茅todo `getServices()` en el componente `CreatePlace` para que quede as铆:

```typescript
public getServices(){
  this.placeServicesService.getAll().subscribe({
    next: (data) => {
      this.services = data.content;
    },
    error: (error) => {
      Swal.fire('Error!', "Error al obtener los servicios", 'error');
    }
  })
}
```

En el callback `next()` asignamos la lista que nos devuelve el backend a la variable `services` de la clase `CreatePlace`. Esta lista la puede usar para mostrar los servicios en el formulario de creaci贸n de alojamientos.

Haga que la lista de servicios se muestre en el archivo `create-place.html` utilizando la variable `services` y que el usuario pueda seleccionar uno o varios servicios para el alojamiento que est谩 creando.

### 23. Gesti贸n de ciudades

Como se indic贸 anteriormente, si cre贸 el servicio de ciudades para acceder a la lista disponible en el backend, entonces debe proceder de forma similar a lo hecho con los servicios del alojamiento: inyecte el servicio correspondiente y cree una funci贸n para obtener todas las ciudades.

### 24. Verificaci贸n de servicios de alojamiento y ciudades

Ingrese a la p谩gina de creaci贸n de alojamientos y compruebe que tanto las ciudades como los servicios de alojamiento si se est谩n cargando correctamente desde el backend. **Para probar esto, el servidor de Spring Boot debe estar en ejecuci贸n.**

### 25. Creaci贸n del servicio de im谩genes

Cree un nuevo servicio que utilizaremos para conectarnos a los endpoints del backend para la gesti贸n de las im谩genes. Para crear el servicio escriba lo siguiente en el cmd de Windows o en la terminal de GNU/Linux o MacOS en la carpeta **services** del proyecto:

```bash
ng generate service image-service --skip-tests
```

### 26. Implementaci贸n del servicio de im谩genes

Modifique el archivo imagen.service.ts para que quede as铆:

```typescript
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { HttpClient } from '@angular/common/http';
import { ResponseDTO } from '../models/response-dto';

@Injectable({
  providedIn: 'root'
})
export class ImageService {
  private imageUrl = "http://localhost:8080/api/images";

  constructor(private http: HttpClient) { }

  public upload(image: File): Observable<ResponseDTO> {
    const formData = new FormData();
    formData.append('file', image);
    return this.http.post<ResponseDTO>(this.imageUrl, formData);
  }

  public delete(id: string): Observable<ResponseDTO> {
    return this.http.delete<ResponseDTO>(this.imageUrl, { params: { id } });
  }
}
```

> 锔 **Nota:** Puede que su puerto e incluso los endpoints sean diferentes, debe comprobarlo con su implementaci贸n de los controladores del backend. **Es importante que revise muy bien que el nombre del `FormData` coincida con el que recibe el `@RequestParam` del backend.**

### 27. Inyecci贸n del servicio de im谩genes

Inyecta el servicio `ImageService` en el constructor del componente `CreatePlace` para acceder a las funciones de la carga de im谩genes.

### 28. Actualizaci贸n del formulario de crear alojamiento

Modifique el formulario de crear alojamiento (`create-place.html`) para que incluya un bot贸n que le permita al usuario subir las im谩genes que ha seleccionado para el alojamiento.

Cambie la secci贸n donde estaba el `input` de tipo `file` para que quede as铆:

```html
<div class="col-12 col-sm-6">
    <label class="form-label">Im谩genes del alojamiento: </label>
    <div class="d-flex align-items-center gap-2">
        <input class="form-control flex-grow-1" type="file" (change)="onFileChange($event)" />
        <button class="btn btn-primary" type="button" (click)="uploadImages()" style="white-space: nowrap;">
            <span class="material-symbols-rounded filled">add_photo_alternate</span>
            Subir im谩genes
        </button>
    </div>
</div>
```

### 29. Modificaci贸n del evento de submit

Quite el (`ngSubmit`) de la etiqueta `form` y agregue el evento `(click)` al bot贸n de crear alojamiento que est谩 al final del formulario. El evento del bot贸n debe quedar as铆:

```html
<button (click)="createNewPlace()">
  ...
</button>
```

> 锔 **Nota:** No quite el contenido del bot贸n ni las dem谩s propiedades o validaciones. Solo agregue el evento del `(click)`.

### 30. Funci贸n para subir im谩genes

Cree la funci贸n `uploadImages()` en el componente `CreatePlace` para que invoque el servicio del backend que guarda la imagen en *Cloudinary* y nos retorna la ruta. Puede hacerlo as铆:

```typescript
public uploadImages() {
  if (this.imagePlace != null) {
    this.imageService.upload(this.imagePlace).subscribe({
      next: (data) => {

        // Se agrega la url de la imagen al formulario. Si ya hay im谩genes, se conservan y se agrega la nueva.
        this.createPlaceForm.patchValue({
          images: [...(this.createPlaceForm.value.images || []), data.content.url] //Accedemos a la url desde el content del ResponseDTO
        });

        Swal.fire('Exito!', 'Se ha subido la imagen.', 'success');
      },
      error: (error) => {
        Swal.fire('Error!', error.error.content, 'error');
      }
    });
  }
}
```

Hacemos uso del servicio `imageService` para invocar la funci贸n `upload` a la que le pasamos el archivo seleccionado en el formulario, si la respuesta del servicio es correcta (o sea, se invoca el callback `next()` dentro del `subscribe()`) guardamos la url de la imagen en el campo correspondiente en el formulario (DTO).

> 锔 **Nota:** En esta implementaci贸n solo se est谩 capturando la primera imagen y es la que se env铆a al servicio del backend. Ajuste el c贸digo para que pueda subir varias im谩genes si as铆 lo desea.

### 31. Actualizaci贸n de la funci贸n `onFileChange`

Modifique la funci贸n `onFileChange()` para que quede as铆:

```typescript
public onFileChange(event: Event) {
  const input = event.target as HTMLInputElement;

  if (input.files && input.files.length > 0) {
    const files = Array.from(input.files);
    this.imagePlace = files[0];
  }
}
```

Es necesario **crear una variable** a nivel de la clase para guardar all铆 el archivo seleccionado desde el `input`:

```typescript
imagePlace?: File;
```

### 32. Funci贸n para crear el alojamiento

Por 煤ltimo, al momento de crear el alojamiento, haga uso de la funci贸n `create()` del servicio `placesService` para que se env铆e la petici贸n al backend, puede quedar as铆:

```typescript
public createNewPlace() {
  const createPlaceDTO = this.createPlaceForm.value as CreatePlaceDTO;

  this.placesService.create(createPlaceDTO).subscribe({
    next: (data) => {
      Swal.fire("Exito!", data.content, "success");
    },
    error: (error) => {
      Swal.fire('Error!', error.error.content, 'error');
    }
  });
}
```

### 33. Prueba de creaci贸n de alojamientos

Vaya a la p谩gina de crear un alojamiento nuevo, llene el formulario y verifique que la respuesta desde el backend es correcta, adem谩s verifique que la foto si qued贸 subida en Cloudinary. **Para probar esto, el servidor de Spring Boot debe estar en ejecuci贸n.**

Dado que este endpoint **est谩 protegido y solo el usuario autenticado** puede acceder a 茅l, puede que falle, ya que no hemos integrado a煤n el token de autenticaci贸n en las peticiones. Esto lo haremos en la siguiente gu铆a.

Por ahora, es importante que verifique que el formulario funciona correctamente, que tiene todos los campos necesarios y que las validaciones funcionan bien. Para estar seguro de que los datos se est谩n **asignando correctamente al DTO**, puede imprimir el objeto `createPlaceDTO` en la consola del navegador antes de llamar al servicio.

锔 **Seguridad en el backend:**

Si quiere probar que el endpoint funciona correctamente, puede desprotegerlo temporalmente en el backend para hacer la prueba. Para esto simplemente modifique el m茅todo `securityFilterChain` de la clase `SecurityConfig` para que la parte de `authorizeHttpRequests` quede as铆:

```java
authorizeHttpRequests( req -> req.anyRequest().permitAll() )
```

Puede comentar las dem谩s reglas de autorizaci贸n. Recuerde volver a proteger el endpoint una vez haya terminado las pruebas.

### 34. Uso del ID de usuario desde el token

Dado que el frontend ya tiene guardado el token devuelto por el backend (al hacer login), entonces se puede integrar los servicios que requieren del id del usuario, por ejemplo, editar su perfil, listar sus alojamientos, etc. 

En el componente de gesti贸n de alojamientos del usuario (por ejemplo, `MyPlaces`), inyecte el servicio `TokenService` en el constructor de la clase para poder acceder al id del usuario desde el token. Luego, llame a la funci贸n `getUserId()` del servicio `TokenService` para obtener el id del usuario y usarlo en las peticiones al backend, por ejemplo:

```typescript
public getMyPlaces() {
  // Se obtiene el id del usuario desde el token usando el servicio TokenService
  const userId = this.tokenService.getUserId();

  // Se llama al servicio para obtener los alojamientos del usuario (el 0 indica la p谩gina, debe ajustarlo si usa paginaci贸n)
  this.userService.getPlaces(userId, 0).subscribe({
    next: (data) => {
      this.places = data.content;
    },
    error: (error) => {
      Swal.fire('Error!', "Error al obtener los alojamientos", 'error');
    }
  });
}
```

En cualquier componente donde sea necesario acceder al id del usuario para realizar alguna petici贸n, debe hacer uso de la funci贸n `getUserId()` de la clase `TokenService`.

### 35. Integraci贸n completa de servicios

**Programe los servicios necesarios** para conectarse adecuadamente a la API del backend e integre dichos servicios en los componentes que lo requieran. Recuerde hacer uso de **SweetAlert2** para informar al usuario constantemente de los mensajes del backend.

### 36. Control de versiones

Recuerde guardar todos los cambios en GIT y en GitHub.

---

## Para la pr贸xima clase

**Una buena pr谩ctica en Angular es tener todas las urls de los endpoints de la API REST en un solo archivo de constantes.** Esto se conoce como `environment`. Investigue acerca del tema e intente implementarlo en el proyecto para que quede m谩s organizado.

Este art铆culo puede ser de ayuda:

- [https://medium.com/zurvin/angular-8-environments-facilito-2dea177bbe94](https://medium.com/zurvin/angular-8-environments-facilito-2dea177bbe94)

- Investigue c贸mo usar cookies en lugar de `sessionstorage` para manejar el token de autenticaci贸n. Puede leer acerca de `ngx-cookie-service`.
```
Programa de Ingenier铆a de Sistemas y Computaci贸n
Universidad del Quind铆o

T铆tulo: Guards e Interceptor en Angular
Duraci贸n estimada: 120
Docentes: Carlos Andr茅s Florez
Gu铆a: 20
```

# Guards e Interceptor en Angular

##  Objetivo 

Implementar la protecci贸n de rutas en Angular mediante el uso de guards, y configurar un interceptor que se encargue de adjuntar el token de autenticaci贸n en cada solicitud HTTP realizada desde el frontend hacia el backend.

---

## Conceptos b谩sicos

- **Lenguaje de programaci贸n TypeScript**: Superset de JavaScript que a帽ade tipado est谩tico y otras caracter铆sticas.
- **Servicios en Angular**: Clases que proporcionan funcionalidades espec铆ficas y pueden ser compartidas entre diferentes componentes de una aplicaci贸n Angular. Se utilizan para manejar la l贸gica de negocio, interactuar con APIs, gestionar el estado de la aplicaci贸n, entre otros.
- **Componentes en Angular**: Bloques reutilizables de c贸digo que encapsulan la l贸gica, la plantilla HTML y los estilos CSS para crear partes independientes de una aplicaci贸n web.
- **API REST**: Conjunto de reglas y convenciones para construir y consumir servicios web que permiten la comunicaci贸n entre diferentes sistemas a trav茅s de HTTP.
- **JWT (JSON Web Token)**: Est谩ndar abierto para la transmisi贸n segura de informaci贸n entre partes como un objeto JSON. Se utiliza com煤nmente para la autenticaci贸n y autorizaci贸n en aplicaciones web.
- **Spring Security**: Framework de seguridad para aplicaciones Java que proporciona autenticaci贸n, autorizaci贸n y protecci贸n contra amenazas comunes.
  
---

## Contextualizaci贸n Te贸rica

En esta gu铆a se abordar谩n dos conceptos fundamentales en el desarrollo de aplicaciones web con Angular: los **Guards** y los **Interceptors**. Ambos son mecanismos que permiten gestionar la seguridad y el flujo de datos en una aplicaci贸n, pero operan en diferentes niveles y con prop贸sitos distintos.

### Guards

Los **Guards** en Angular funcionan de manera similar a middlewares: se ejecutan antes de cargar una ruta y determinan si esta puede ser accedida o no. Una de sus principales ventajas es que, **al impedir la carga de rutas no autorizadas, se evita que los usuarios accedan a p谩ginas para las cuales no tienen permisos**. Adem谩s, su uso permite una mejor organizaci贸n del c贸digo, ya que la l贸gica relacionada con permisos y control de acceso se mantiene separada de la configuraci贸n de las rutas, lo que facilita el mantenimiento y la escalabilidad de la aplicaci贸n.

### Interceptors

Un **interceptor** se encarga de inspeccionar y/o modificar tanto las peticiones que se env铆an desde la aplicaci贸n de Angular al servidor como las respuestas que esta recibe. En otras palabras, act煤a sobre el ciclo completo de solicitud y respuesta, permitiendo aplicar l贸gica personalizada en ambos sentidos de la comunicaci贸n.

Podemos representar el funcionamiento de un interceptor con la siguiente imagen:

![Interceptor HTTP](media/middleware.webp)

#### Operaciones del interceptor HTTP

Generalmente, un interceptor puede realizar las siguientes operaciones:

- Modificar encabezados HTTP
- Modificar el cuerpo de la solicitud
- Establecer token de autenticaci贸n/autorizaci贸n
- Modificar la respuesta HTTP
- Manejo de errores
- Registro y monitoreo de eventos

#### Uso del interceptor en nuestro proyecto

En nuestro contexto, el interceptor es una implementaci贸n de `HttpInterceptor` que utilizamos para **a帽adir autom谩ticamente el token de autenticaci贸n a todas las peticiones HTTP** dirigidas al backend. Recordemos que la mayor铆a de los endpoints de nuestra API REST est谩n protegidos mediante Spring Security, el cual deniega el acceso si no se proporciona un token v谩lido generado por JWT (Bearer Token).

Adem谩s, el interceptor nos permite implementar la funcionalidad de *refresh token*, de modo que, cuando un token ha expirado, se pueda solicitar uno nuevo al servidor y as铆 extender la sesi贸n del usuario sin interrupciones constantes.

---

## Precauciones y Recomendaciones

Verifique que tiene instalado NodeJS en su 煤ltima versi贸n para poder compilar y ejecutar la aplicaci贸n de Angular. Tenga en cuenta que el proyecto de backend constru铆do en IntelliJ IDEA debe estar en ejecuci贸n al momento de probar la API.

---

## Evaluaci贸n o Resultado

Se espera que el estudiante aprenda a configurar la protecci贸n de rutas correctamente seg煤n el estado de la sesi贸n y del tipo de rol del usuario haciendo uso de guards, tambi茅n se espera que el estudiante configure un interceptor para agregar en el encabezado de las peticiones HTTP el token de autenticaci贸n (si es que est谩 disponible).

---

## Procedimiento

### 1. Creaci贸n del guard de login

Para proteger las rutas podemos usar guards. **Cree una nueva carpeta que se llame guards (dentro de la carpeta app)** y ubicados dentro de dicha carpeta escribimos lo siguiente en el cmd de windows o en la terminal de GNU/Linux o MacOS.

```bash
ng generate service login-service --skip-tests
```

### 2. Implementaci贸n del LoginGuard

Modifique el archivo `login-service.ts` (que creamos en el punto anterior) para que quede as铆:

```typescript
import { Injectable, inject } from '@angular/core';
import { ActivatedRouteSnapshot, CanActivateFn, Router, RouterStateSnapshot } from '@angular/router';
import { TokenService } from '../services/token-service';

@Injectable({
  providedIn: 'root'
})
export class LoginService {
  constructor(private tokenService: TokenService, private router: Router) { }

  canActivate(next: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {
    if (this.tokenService.isLogged()) {
      this.router.navigate([""]);
      return false;
    }
    return true;
  }
}

export const LoginGuard: CanActivateFn = (next: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean => {
  return inject(LoginService).canActivate(next, state);
}
```

En este servicio se define la funci贸n `canActivate`, la cual verifica si el usuario ya ha iniciado sesi贸n. En caso afirmativo, se realiza una redirecci贸n a la p谩gina de inicio. Esto es 煤til porque un usuario autenticado no deber铆a poder acceder a las p谩ginas de login o registro, ya que est谩n destinadas 煤nicamente a usuarios no autenticados. Finalmente, se crea una constante que permite ejecutar esta validaci贸n desde las rutas.

### 3. Configuraci贸n del LoginGuard en las rutas

Modifique el archivo `app.routes.ts` que est谩 dentro de la carpeta `app` y a帽ada lo siguiente en la lista `routes`:

```typescript
{ path: 'login', component: Login, canActivate: [LoginGuard] },
{ path: 'register', component: Register, canActivate: [LoginGuard] }
```

Como se explic贸 en el punto anterior la idea de usar `LoginGuard` es evitar que un usuario logueado pueda ver la p谩gina de login y de registro. 

Recuerde hacer el `import` de `LoginGuard` en `app.routes.ts` para que funcione correctamente.

### 4. Actualizaci贸n del header seg煤n el estado de sesi贸n

Dado que ya tenemos la implementaci贸n de sesi贸n con el token del backend, podemos mejorar la p谩gina web haciendo algunos cambios como la de ocultar o mostrar men煤s (o secciones) en el header si la persona est谩 logueada o no. Para esto, es necesario modificar el componente `Header`, en el archivo `header.ts` haga lo siguiente:

```typescript
import { Component, signal } from '@angular/core';
import { Router, RouterModule } from '@angular/router';
import { TokenService } from '../../services/token-service';

@Component({
  selector: 'app-header',
  imports: [RouterModule],
  templateUrl: './header.html',
  styleUrl: './header.css'
})
export class Header {
  protected readonly title = signal('BookingsUQ');
  isLogged = false;
  email: string = "";

  constructor(private tokenService: TokenService, private router: Router) {
    this.isLogged = this.tokenService.isLogged();
    if (this.isLogged) {
      this.email = this.tokenService.getEmail();
    }
  }

  public logout() {
    // Borrar token del sessionStorage
    this.tokenService.logout();
    // Redirigir al inicio y recargar la p谩gina
    this.router.navigate(['/']).then(() => window.location.reload());
  }
}
```

Se agregan dos atributos en el componente `Header`, uno para saber si el usuario est谩 logueado (`isLogged`) y otro para guardar el `email` (si est谩 logueado). Ambos valores se pueden obtener haciendo uso del servicio `TokenService`.

### 5. Funci贸n getEmail en TokenService

Si no la tiene, programe la funci贸n `getEmail()` en el archivo `token-service.ts` as铆:

```typescript
public getEmail(): string {
  const token = this.getToken();
  if (token) {
    const values = this.decodePayload(token);
    return values.email;
  }
  return "";
}
```

> 锔 **Nota:** Verifique si desde el backend se est谩 enviado en los claims del JWT el valor email, si no es as铆, modifique el backend para que lo env铆e. Si lo desea, puede enviar otro valor diferente como el nombre de usuario (username).

### 6. Modificaci贸n del HTML del header

Ahora modifique el archivo `header.html` en la secci贸n del header donde est谩 el bot贸n de login y registro para que quede as铆:

{% raw %}
```html
<div class="text-end">
  @if (!isLogged) {
    <button type="button" routerLink="/login" class="btn btn-outline-light me-2">Login</button>
    <button type="button" routerLink="/registro" class="btn btn-primary">Registro</button>
  }@else {
    <label class="me-3">Hola {{email}}</label>
    <button type="button" (click)="logout()" class="btn btn-outline-light">Logout</button>
  }
</div>
```
{% endraw %}

B谩sicamente, por medio del `@if` mostramos el bot贸n de login y registro si el usuario no est谩 logueado. De lo contrario (`@else`) se muestra el email del usuario y el bot贸n de logout.

### 7. Prueba del header din谩mico

Pruebe el funcionamiento de la p谩gina, inicie sesi贸n y observe qu茅 pasa. Luego cierre sesi贸n y observe qu茅 pasa.

### 8. Modificaci贸n del men煤 seg煤n el estado de sesi贸n

Haga que se muestre un men煤 si el usuario no est谩 logueado, y otro men煤 si est谩 logueado. Esto por medio de `@if` y la variable `isLogged`. Esto es importante para mejorar la experiencia del usuario, ya que no tendr铆a sentido mostrar opciones de men煤 que no puede usar.

Incluso, puede hacer que se muestren diferentes opciones de men煤 seg煤n el rol del usuario (si es afitri贸n o hu茅sped). Recuerde que el rol lo puede obtener por medio de `TokenService` usando la funci贸n `getRole()` la cual captura el rol del usuario desde el token JWT.

### 9. Configuraci贸n de rutas con RoleGuard

Los guards nos permiten implementar comprobaciones m谩s estrictas; por ejemplo, podemos restringir el acceso a una p谩gina para que solo sea accesible por un rol espec铆fico.

En el proyecto final, contamos con **funcionalidades exclusivas para anfitriones** y otras accesibles **煤nicamente para hu茅spedes autenticados**. Por ejemplo, los anfitriones (host) pueden ver sus alojamientos creados, crear nuevos, editarlos, entre otras, mientras que solo los hu茅spedes (guest) pueden crear una reserva, calificar, ver sus reservas, entre otras acciones. Por lo tanto, **es necesario validar** ciertas rutas mediante guards para asegurar el acceso adecuado.

En la lista routes del archivo `app.routes.ts` a帽adiremos lo siguiente (**no borre lo que tiene solo adicione las nuevas propiedades**):

```typescript
{ path: 'create-place', component: CreatePlace, canActivate: [RoleGuard], data: { expectedRole: ["ROLE_HOST"] } },
{ path: 'edit-place/:id', component: CreatePlace, canActivate: [RoleGuard], data: { expectedRole: ["ROLE_HOST"] } },
{ path: "my-places", component: MyPlaces, canActivate: [RoleGuard], data: { expectedRole: ["ROLE_HOST"] } },
```

Es importante mencionar que en la lista de `expectedRole` debemos escribir el nombre del rol tal como lo retorna el backend (esto se hace en el backend cuando crea el token JWT). En nuestro caso, el backend retorna el token con el rol `ROLE_HOST` o `ROLE_GUEST`, y as铆 se debe escribir para que se haga la comprobaci贸n adecuadamente. **En el c贸digo anterior solo se muestran algunas rutas a manera de ejemplo, usted debe configurar las que falten.**

### 10. Creaci贸n del RoleGuard

Creamos una nueva guard de la siguiente manera (recuerde ejecutarlo en la carpeta **guards** del proyecto):

```bash
ng generate service role-service --skip-tests
```

### 11. Implementaci贸n del RoleGuard

Modificamos el archivo `role-service.ts` (creado en el punto anterior) para que quede as铆:

```typescript
import { inject, Injectable } from '@angular/core';
import { TokenService } from '../services/token-service';
import { ActivatedRouteSnapshot, CanActivateFn, Router, RouterStateSnapshot } from '@angular/router';

@Injectable({
  providedIn: 'root'
})
export class RoleService {

  constructor(private tokenService: TokenService, private router: Router) { }

  canActivate(next: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {

    const expectedRole: string[] = next.data["expectedRole"];
    const realRole = this.tokenService.getRole();

    if (!this.tokenService.isLogged() || !expectedRole.includes(realRole)) {
      this.router.navigate([""]);
      return false;
    }

    return true;
  }

}

export const RoleGuard: CanActivateFn = (next: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean => {
  return inject(RoleService).canActivate(next, state);
}
```

Si no la tiene, programe la funci贸n `getRole()` en el archivo `token-service.ts`, puede basarse en la funci贸n `getEmail()` explicada anteriormente.

### 12. Validaci贸n del RoleGuard

**Valide que todo est谩 funcionando correctamente.** Intente acceder a los componentes de mis alojamientos, crear uno nuevo. Luego inicie sesi贸n e intente de nuevo acceder a dichas p谩ginas. Solo nos debe permitir acceder a dichas p谩ginas si estamos logueados y si tenemos el rol adecuado.

### 13. Aplicaci贸n del guard a todas las rutas

Agregue `canActivate` y el `expectedRole` a todas las rutas de la aplicaci贸n frontend que lo requieran, as铆 como lo hicimos con los componentes explicados anteriormente.

### 14. Creaci贸n del interceptor

Finalmente para hacer que, una vez el usuario haya iniciado sesi贸n, se env铆e el token en cada petici贸n al backend es necesario crear un interceptor. **Para esto, debe crear una nueva carpeta que se llame interceptor (dentro de la carpeta app)** y ubicados dentro de dicha carpeta escribimos lo siguiente en el cmd de windows o en la terminal de Linux o MacOS.

```bash
ng generate interceptor token --skip-tests
```

### 15. Implementaci贸n del interceptor

Modificamos el archivo `token-interceptor.ts` (creado en el punto anterior) para que quede as铆:

```typescript
import { inject } from '@angular/core';
import { HttpInterceptorFn } from '@angular/common/http';
import { TokenService } from '../servicios/token.service';

export const tokenInterceptor: HttpInterceptorFn = (req, next) => {
  const tokenService = inject(TokenService);

  if (!tokenService.isLogged()) {
    return next(req);
  }

  const token = tokenService.getToken();
  const authReq = req.clone({
    setHeaders: {
      Authorization: `Bearer ${token}`
    }
  });

  return next(authReq);
};
```

El interceptor act煤a como un intermediario (*middleware*) entre las peticiones del frontend y las respuestas del backend. Para implementarlo, se debe crear una funci贸n `HttpInterceptorFn`. En ella, se valida si el usuario est谩 autenticado; si es as铆, se agrega al encabezado HTTP el token de autenticaci贸n (Bearer Token), el cual se obtiene a trav茅s del `TokenService`.

### 16. Configuraci贸n del interceptor en app.config

Modifique el archivo `app.config.ts` para que entre en operaci贸n el interceptor creado en el punto anterior.

```typescript
import { ApplicationConfig, provideBrowserGlobalErrorListeners, provideZoneChangeDetection } from '@angular/core';
import { provideRouter } from '@angular/router';
import { provideHttpClient, withInterceptors } from '@angular/common/http';

import { routes } from './app.routes';
import { tokenInterceptor } from './interceptor/token-interceptor';

export const appConfig: ApplicationConfig = {
  providers: [
    provideBrowserGlobalErrorListeners(),
    provideHttpClient(withInterceptors([tokenInterceptor])),
    provideZoneChangeDetection({ eventCoalescing: true }),
    provideRouter(routes)
  ]
};
```

Se ha modificado la configuraci贸n del cliente HTTP para que utilice el interceptor `tokenInterceptor` en todas las peticiones que se realicen.

### 17. Prueba del interceptor

**Pruebe que todo funcione correctamente.** Haga pruebas con diferentes tipos de usuarios, con las rutas y verifique que todo est茅 bien configurado.

> 锔 **Importante:** Si coment贸 las validaciones del m茅todo `securityFilterChain()` de la clase `SecurityConfig` del backend (como se indic贸 en la gu铆a anterior), quite dichos comentarios y deje la clase tal como la ten铆a antes para que las rutas est茅n protegidas.

### 18. Implementaci贸n de refresh token (opcional)

Si al enviar la petici贸n el backend nos retorna un error con el mensaje de que el token ya caduc贸, se recomienda crear una funci贸n `refresh()` para solicitarle al backend que construya un nuevo token y nos lo env铆e, al recibirlo de vuelta lo actualizamos en el `sessionStorage` del frontend y se procede con la solicitud nuevamente.

Para esto, debe crear un nuevo endpoint de tipo `POST`: `@PostMapping("/refresh")` en `AuthController` que permita actualizar el token vencido.

### 19. Funci贸n refresh en el frontend (opcional)

Cree la funci贸n `refresh()` en el servicio `TokenService` del frontend para que quede as铆 para que solicite un nuevo token al backend. **Investigue c贸mo se puede modificar el interceptor para que cuando el backend nos retorna un error 401 se invoque la funci贸n `refresh()`, se actualice el token y env铆e de nuevo la petici贸n al backend con el nuevo token.**

### 20. Control de versiones

Recuerde guardar todos los cambios en Git y en GitHub.

---

## Para la pr贸xima clase

- Lea e investigue sobre el despliegue de nuestros proyectos (backend y frontend) en la nube por medio de alguna herramienta gratuita. Por ejemplo: [https://railway.app/](https://railway.app/), [https://fly.io/](https://fly.io/), [https://firebase.google.com/](https://firebase.google.com/), [https://render.com/](https://render.com/), [https://vercel.com/](https://vercel.com/), y otros.
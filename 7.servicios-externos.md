```
Programa de Ingenier칤a de Sistemas y Computaci칩n
Universidad del Quind칤o

T칤tulo: Servicios Externos
Duraci칩n estimada: 120
Docentes: Carlos Andr칠s Florez, Christian Andr칠s Candela
Gu칤a: 07
```

# Servicios Externos

## 游꿢 Objetivo
Integrar servicios externos como gesti칩n de correos electr칩nicos y gesti칩n de im치genes en proyectos empresariales hechos con Spring Boot.

---

## Conceptos b치sicos
- **API (Interfaz de Programaci칩n de Aplicaciones):** Conjunto de definiciones y protocolos para construir e integrar software de aplicaciones.
- **SDK (Kit de Desarrollo de Software):** Conjunto de herramientas de desarrollo que permite la creaci칩n de aplicaciones para un sistema espec칤fico. Se ofrece como librer칤as o dependencias que se integran en el proyecto. 
- **Java y Spring Boot**.

---

## Contextualizaci칩n Te칩rica

El uso de servicios externos en la programaci칩n de un backend es una pr치ctica com칰n en el desarrollo de aplicaciones web y servicios en l칤nea. Los servicios externos son recursos o funcionalidades proporcionados por terceros a trav칠s de **APIs (Interfaces de Programaci칩n de Aplicaciones)** que se integran en una aplicaci칩n para agregar funcionalidad adicional o para interactuar con datos y servicios externos. En el proyecto final usaremos al menos dos servicios externos: env칤o de correos electr칩nicos y almacenamiento de im치genes en la nube.

### Ventajas del uso de servicios externos

- **Ahorro de tiempo y recursos:** El desarrollo de funcionalidades complejas desde cero puede llevar mucho tiempo y recursos. Utilizar servicios externos preexistentes permite acelerar el desarrollo y centrarse en aspectos 칰nicos de la aplicaci칩n.

- **Experiencia especializada:** Los proveedores de servicios externos suelen ser expertos en sus respectivas 치reas. Al aprovechar sus servicios, podemos beneficiarnos de su experiencia y conocimiento especializado, lo que puede resultar en soluciones m치s robustas y eficientes.

- **Escalabilidad:** Muchos servicios externos est치n dise침ados para manejar cargas de trabajo masivas y escalables autom치ticamente. Esto significa que no tenemos que preocuparnos por la infraestructura subyacente o la capacidad de escalar los servicios seg칰n sea necesario.

- **Actualizaciones y mantenimiento:** Los proveedores de servicios externos se encargan del mantenimiento continuo, la mejora y la actualizaci칩n de sus servicios. Esto reduce la carga de trabajo del equipo de desarrollo en t칠rminos de parches de seguridad, correcci칩n de errores y desarrollo de nuevas caracter칤sticas.

- **Acceso a tecnolog칤as avanzadas:** Los servicios externos pueden ofrecer acceso a tecnolog칤as avanzadas. Esto nos permite aprovechar las 칰ltimas innovaciones sin tener que aprender y desarrollar todo internamente.

- **Menos mantenimiento de c칩digo:** Al usar servicios externos, tenemos menos c칩digo que mantener, lo que simplifica la gesti칩n y reduce la probabilidad de errores en el c칩digo personalizado.

- **Costos predecibles:** Muchos servicios externos tienen modelos de precios claros y predecibles, lo que facilita la planificaci칩n presupuestaria en comparaci칩n con el desarrollo interno, que puede ser m치s dif칤cil de estimar en t칠rminos de costos.

- **Enfoque en el n칰cleo de la aplicaci칩n:** Al externalizar ciertas funciones, podemos concentrarnos en el desarrollo de las caracter칤sticas principales de la aplicaci칩n, lo que puede mejorar la calidad general y la velocidad de entrega.

El uso de servicios externos puede ser una estrategia inteligente para acelerar el desarrollo, reducir costos, mejorar la calidad y aprovechar la experiencia y las capacidades de terceros. Sin embargo, es importante seleccionar proveedores confiables y considerar los riesgos potenciales, como la dependencia de terceros y los posibles cambios en los t칠rminos y precios de los servicios externos.

---

## Precauciones y Recomendaciones

- Verificar que tiene instalado el JDK de Java (preferiblemente la versi칩n 17).
- Leer la documentaci칩n oficial de las librer칤as y servicios que se van a usar.
- No exponer datos sensibles (como contrase침as o claves secretas) en el c칩digo fuente.

---

## Evaluaci칩n o Resultado

Se espera que el estudiante logre crear servicios que se comuniquen con aplicaciones de terceros para integrar funcionalidades como la gesti칩n de env칤o de correos electr칩nicos y carga de im치genes en la nube.

---

## Servicios de terceros - Env칤o de correos electr칩nicos

Continuaremos trabajando en el proyecto final del espacio acad칠mico que iniciamos en las gu칤as anteriores. Si no ha completado la gu칤a anterior, por favor h치galo antes de continuar con esta.

### 1. Agregar dependencias
Una caracter칤stica necesaria en el proyecto es el env칤o de correos electr칩nicos. Para esto usaremos la librer칤a [Simple Java Mail](https://www.simplejavamail.org/). Agregue las siguientes dependencias en el archivo `build.gradle`:

```groovy
implementation 'org.simplejavamail:simple-java-mail:8.12.6'
implementation 'org.simplejavamail:batch-module:8.12.6'
```

Sincronice y descargue las dependencias por medio de Gradle.

### 2. Crear interfaz de servicio
Cree una interfaz que represente el servicio de email en el paquete `co.edu.uniquindio.application.services` llamada `EmailService`:

```java
void sendMail(EmailDTO emailDTO) throws Exception;
```

Cree un DTO llamado `EmailDTO` para encapsular los datos del correo en el paquete `co.edu.uniquindio.application.dto`:

```java
package co.edu.uniquindio.application.dto;

public record EmailDTO(
        String subject,
        String body,
        String recipient
) {
}
```

Este DTO contiene los datos necesarios para enviar un correo electr칩nico: asunto, cuerpo y destinatario.

### 3. Implementar el servicio
Cree la clase que implemente la interfaz en el paquete `co.edu.uniquindio.application.services.impl`:

```java
package co.edu.uniquindio.application.services.impl;

import co.edu.uniquindio.application.dto.EmailDTO;
import co.edu.uniquindio.application.services.EmailService;
import org.simplejavamail.api.email.Email;
import org.simplejavamail.api.mailer.Mailer;
import org.simplejavamail.api.mailer.config.TransportStrategy;
import org.simplejavamail.email.EmailBuilder;
import org.simplejavamail.mailer.MailerBuilder;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

@Service
public class EmailServiceImpl implements EmailService {

    @Override
    @Async
    public void sendMail(EmailDTO emailDTO) throws Exception {
        Email email = EmailBuilder.startingBlank()
            .from("SMTP_USERNAME")
            .to(emailDTO.recipient())
            .withSubject(emailDTO.subject())
            .withPlainText(emailDTO.body())
            .buildEmail();

        try (Mailer mailer = MailerBuilder
            .withSMTPServer("SMTP_HOST", SMTP_PORT, "SMTP_USERNAME", "SMTP_PASSWORD")
            .withTransportStrategy(TransportStrategy.SMTP_TLS)
            .withDebugLogging(true)
            .buildMailer()) {
            
            mailer.sendMail(email);
        }
    }
}
```

Este m칠todo es as칤ncrono y se encarga de enviar un correo electr칩nico utilizando **Simple Java Mail**. Los valores como *"SMTP_HOST"*, *"SMTP_PORT"*, *"SMTP_USERNAME"* y *"SMTP_PASSWORD"* son placeholders y deben ser reemplazados por valores reales. Si lo desea, puede crear estas propiedades en el archivo `application.properties` y luego inyectarlas en la clase usando `@Value`.

>**丘멆잺 NOTA:** El m칠todo `withPlainText()` se podr칤a reemplazar por `withHTMLText()` si el cuerpo del email lleva etiquetas HTML.

### 4. Configurar funcionalidad as칤ncrona
Cree el paquete `co.edu.uniquindio.application.config` y agregue la siguiente clase:

```java
package co.edu.uniquindio.application.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.AsyncConfigurer;
import org.springframework.scheduling.annotation.EnableAsync;

@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {
}
```

Esta clase habilita y configura la funcionalidad as칤ncrona en Spring. Est치 vac칤a porque usaremos la configuraci칩n por defecto. Para usar la funcionalidad as칤ncrona, podemos anotar m칠todos con `@Async` en cualquier bean de Spring.

### 5. Configurar servidor SMTP
Para enviar correos se necesita un servidor SMTP y todos sus datos: *SMTP_HOST*, *SMTP_PORT*, *SMTP_USERNAME* y *SMTP_PASSWORD*. Existen servicios gratuitos (con l칤mites):

- [Moosend](https://moosend.com/blog/free-smtp-server/)
- [Mailgun](https://www.mailgun.com/)
- [Mailchimp](https://mailchimp.com/)
- [Brevo](https://www.brevo.com/es/)

En esta gu칤a usaremos Gmail (no se recomienda usar correos personales, es mejor crear uno para las pruebas).

### 6. Configurar Gmail
1. Cree un nuevo correo en Gmail
2. Active la autenticaci칩n de dos pasos: [https://myaccount.google.com/signinoptions/two-step-verification/enroll-welcome](https://myaccount.google.com/signinoptions/two-step-verification/enroll-welcome)
3. Genere una clave de aplicaci칩n: [https://myaccount.google.com/apppasswords](https://myaccount.google.com/apppasswords) (esta clave es el SMTP_PASSWORD)
4. Copie y guarde la clave ya que no se volver치 a mostrar

**Configuraci칩n para Gmail:**

- SMTP_HOST: `smtp.gmail.com`
- SMTP_PORT: `587`
- SMTP_USERNAME: la direcci칩n del correo electr칩nico
- SMTP_PASSWORD: la clave de aplicaci칩n generada

>**丘멆잺 NOTA:** Si usa otro servicio de correo, consulte la documentaci칩n para obtener los datos correctos del servidor SMTP.

### 7. Actualizar la implementaci칩n
Reemplace todos los valores definidos anteriormente en el m칠todo `sendMail()` de la clase `EmailServiceImpl`.

### 8. Uso del servicio
Para usar el servicio, inicialice `EmailService` en el servicio que lo requiera y llame el m칠todo `sendMail()`:

```java
emailService.sendMail(new EmailDTO("Asunto", "Cuerpo mensaje", "Correo destino"));
```

Este servicio debe ser incluido en aquellos m칠todos de los dem치s servicios que lo requieran. Recuerde que puede hacer inyecci칩n de dependencias de `EmailService` en cualquier clase anotada con `@Service`.

---

## Servicios de terceros - Carga de im치genes en la nube

### 1. Configurar Cloudinary
Otro servicio importante es el almacenamiento de im치genes. Para proyectos peque침os, la mejor opci칩n es tercerizar el almacenamiento de archivos. Usaremos [Cloudinary](https://cloudinary.com/), un servicio gratuito (con limitaciones).

Para asociar un registro de una base de datos con im치genes es recomendable guardar solo la ruta del archivo, NO los bytes de la imagen en la base de datos ya que esto la sobrecarga y vuelve muy lentas las consultas.

### 2. Crear cuenta en Cloudinary
1. Cree una cuenta en [https://cloudinary.com/](https://cloudinary.com/)
2. Inicie sesi칩n e ingrese a la consola: [https://cloudinary.com/console/](https://cloudinary.com/console/)
3. Observe el *Cloud name*, *API key* y *API secret* (los necesitar치 m치s adelante)

### 3. Configurar carpeta
Ingrese al men칰 Media Library y cree una carpeta con el nombre del proyecto. En esta carpeta se guardar치n las im치genes cuando se suban a Cloudinary.

### 4. Agregar dependencia
Agregue la dependencia en el `build.gradle`:

```groovy
implementation 'com.cloudinary:cloudinary-http5:2.3.2'
```

### 5. Crear interfaz del servicio
Cree una interfaz en `co.edu.uniquindio.application.services` llamada `ImageService`:

```java
package co.edu.uniquindio.application.services;

import org.springframework.web.multipart.MultipartFile;
import java.util.Map;

public interface ImageService {
    Map upload(MultipartFile image) throws Exception;
    Map delete(String imageId) throws Exception;
}
```

### 6. Implementar el servicio
Cree la clase `ImageServiceImpl` en `co.edu.uniquindio.application.services.impl`:

```java
package co.edu.uniquindio.application.services.impl;

import co.edu.uniquindio.application.services.ImageService;
import com.cloudinary.Cloudinary;
import com.cloudinary.utils.ObjectUtils;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Service
public class ImageServiceImpl implements ImageService {

    private final Cloudinary cloudinary;

    public ImageServiceImpl(){
        Map<String, String> config = new HashMap<>();
        config.put("cloud_name", "SU_CLOUD_NAME");
        config.put("api_key", "SU_API_KEY");
        config.put("api_secret", "SU_API_SECRET");
        cloudinary = new Cloudinary(config);
    }

    @Override
    public Map upload(MultipartFile image) throws Exception {
        File file = convert(image);
        // Reemplace "app_name" con el nombre de la carpeta donde se guardar치n las im치genes en Cloudinary
        return cloudinary.uploader().upload(file, ObjectUtils.asMap("folder", "app_name"));
    }

    @Override
    public Map delete(String imageId) throws Exception {
        return cloudinary.uploader().destroy(imageId, ObjectUtils.emptyMap());
    }

    private File convert(MultipartFile image) throws IOException {
        File file = File.createTempFile(image.getOriginalFilename(), null);
        FileOutputStream fos = new FileOutputStream(file);
        fos.write(image.getBytes());
        fos.close();
        return file;
    }
}
```

Este servicio tiene tres m칠todos principales:

- **`uploadImage()`:** Recibe el archivo (`MultipartFile`) del frontend. Una vez subida la imagen retorna una respuesta que contiene la url de la imagen y su **id** (entre otros valores).

- **`deleteImage()`:** Recibe el **id** de la imagen para encontrarla y eliminarla.

- **`convert()`:** Convierte un objeto `MultipartFile` en un objeto `File` (requerido por Cloudinary).

>**丘멆잺 IMPORTANTE:** Reemplace *SU_CLOUD_NAME*, *SU_API_KEY*, *SU_API_SECRET* por los valores reales de su cuenta de Cloudinary.

### 7. Crear controlador REST

En el paquete `co.edu.uniquindio.application.controllers` cree la clase `ImageController`:

```java
package co.edu.uniquindio.application.controllers;

import co.edu.uniquindio.application.dto.ResponseDTO;
import co.edu.uniquindio.application.services.ImageService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.Map;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/images")
public class ImageController {

    private final ImageService imageService;

    @PostMapping(consumes = "multipart/form-data")
    public ResponseEntity<ResponseDTO<Map>> upload(@RequestParam("file") MultipartFile image) throws Exception{
        Map response = imageService.upload(image);
        return ResponseEntity.ok( new ResponseDTO<>(false, response) );
    }

    @DeleteMapping
    public ResponseEntity<ResponseDTO<String>> delete(@RequestParam("id") String id) throws Exception{
        imageService.delete(id);
        return ResponseEntity.ok( new ResponseDTO<>(false, "Imagen eliminada exitosamente") );
    }

}
```

Por medio de este controlador, podremos subir y eliminar im치genes por medio de la API del backend. Tenga en cuenta que el endpoint para subir im치genes es un `POST` y debe enviarse el archivo como `form-data`.

Si no dese crear un controlador REST, puede usar el servicio `ImageService` en cualquier otro servicio de la aplicaci칩n y as칤 integrar la funcionalidad de carga y eliminaci칩n de im치genes de manera interna.

### 8. Probar el controlador REST

Use [Postman](https://www.postman.com/), [Insomnia](https://insomnia.rest/) o Swagger (desde [http://localhost:8080/swagger-ui/index.html](http://localhost:8080/swagger-ui/index.html) si tiene Swagger configurado) para probar los endpoints del controlador `ImageController`.

Si funcionan correctamente, el servicio debe retornar un JSON con la informaci칩n de la imagen subida, incluyendo la URL y el ID. Si accede a la URL en un navegador, debe ver la imagen. **Esta URL es la que debe guardar en la base de datos para asociarla con un registro.**

Adem치s, si quiere ver todas las im치genes que ha subido, puede ir a la [consola de Cloudinary](https://console.cloudinary.com/app) y verlas en la carpeta que cre칩 anteriormente.

### 9. Commit de cambios
Recuerde hacer commit de sus avances en el repositorio de git.

---

## Para la pr칩xima clase

- Investigue otros servicios externos que podr칤an ser 칰tiles en el desarrollo de aplicaciones web.
- Investigue sobre Spring Security y JWT.
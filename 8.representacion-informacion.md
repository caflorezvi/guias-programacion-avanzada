```
Programa de Ingeniería de Sistemas y Computación
Universidad del Quindío

Título: Entidades para Representación de Información
Duración estimada: 120
Docentes: Carlos Andrés Florez, Christian Andrés Candela
Guía: 08
```
---

# Entidades para la representación de la información

## 🎯 Objetivo

Comprender el concepto de **entidad** en Spring Boot y su relación con las **tablas** en las bases de datos relacionales, aplicando buenas prácticas de modelado de datos para aplicaciones SQL.

---

## Conceptos Básicos

- **Base de datos**: Conjunto de datos estructurados que se almacenan y gestionan de manera eficiente.
- **JSON**: Formato de intercambio de datos ligero.  
- **POO**: Programación Orientada a Objetos en Java.  
- **Spring Data JPA**: Módulo de Spring para integración con bases de datos relacionales.  
- **Java**

---

## Contextualización Teórica

En el desarrollo de aplicaciones, es común que los datos generados y utilizados por la aplicación necesiten ser almacenados de manera permanente para su posterior recuperación y uso. Tradicionalmente, esto se ha logrado mediante bases de datos relacionales, en las cuales los datos se organizan en tablas con filas y columnas. Sin embargo, los lenguajes de programación orientados a objetos (OOP) como Java trabajan con estructuras de datos representadas mediante clases y objetos, lo que genera una disparidad entre la forma en que se almacenan y manipulan los datos en la aplicación y en la base de datos.

Para interactuar con bases de datos relacionales, los desarrolladores solían escribir consultas SQL manuales dentro del código de la aplicación, lo que llevaba a problemas como:

- **Acoplamiento entre lógica de negocio y acceso a datos**: La mezcla de SQL dentro del código hacía difícil la mantenibilidad y escalabilidad.
- **Errores comunes de seguridad**: Como inyecciones SQL debido al uso inadecuado de concatenaciones de strings.
- **Inconsistencia en las consultas**: Diferentes partes del código podían manejar la misma consulta de formas distintas.
- **Dificultad en la migración de bases de datos**: Al cambiar de base de datos, se requería modificar todas las consultas SQL escritas manualmente.
- **Inconsistencia de datos** al mapear objetos a tablas.   
- **Acoplamiento** entre lógica de negocio y acceso a datos. 

Para solucionar estos problemas, surgieron los frameworks de mapeo objeto-relacional (ORM) y los Object-Document Mapping (ODM), que permiten gestionar la persistencia de datos de manera transparente y eficiente.

### ORM (Object-Relational Mapping)

El mapeo objeto-relacional (ORM, por sus siglas en inglés) es una técnica de programación que permite interactuar con bases de datos relacionales utilizando objetos en un lenguaje de programación orientado a objetos, como Java. ORM permite que los desarrolladores trabajen con estructuras de datos sin escribir directamente consultas SQL, ya que el framework ORM se encarga de traducir las operaciones de los objetos a comandos SQL subyacentes.

Los principales beneficios del uso de ORM incluyen:

- **Abstracción del acceso a datos**: Facilita la escritura y mantenimiento del código.
- **Reducción de errores**: Al evitar SQL manual, se minimizan los errores comunes.
- **Compatibilidad con múltiples bases de datos**: Permite cambiar de base de datos con menor esfuerzo.
- **Gestión de transacciones y caché**: ORM maneja transacciones automáticamente y mejora el rendimiento mediante caché.

Ejemplos populares de frameworks ORM en Java incluyen Hibernate (que implementa JPA), EclipseLink entre otros.

### JPA (Java Persistence API)

JPA es una especificación de Java para la gestión de persistencia y mapeo objeto-relacional. No es una implementación en sí, sino un conjunto de reglas y anotaciones que permiten definir entidades y gestionar su almacenamiento en bases de datos relacionales. Hibernate es la implementación de JPA más utilizada en Java.

JPA proporciona diversas anotaciones para definir entidades, sus atributos y relaciones. A continuación, se presentan las más comunes:

**1. `@Entity`**

Una entidad es un elemento de persistencia, que permite modelar o representar un objeto o información del sistema que estamos construyendo. Toda entidad está compuesta por uno o más atributos, cada uno de los cuales representa una propiedad o información del objeto que se está modelando.

La anotación `@Entity` se usa para marcar una clase como una entidad que se mapeará a una tabla en la base de datos.

```java
import jakarta.persistence.Entity;
import jakarta.persistence.Id;

@Entity
public class User {
    @Id
    private Long id;
    private String fullName;
    private String email;
}
```

**2. `@Table`**

Permite definir el nombre de la tabla en la base de datos. Si no se especifica, JPA utilizará el nombre de la clase como nombre de la tabla.

```java
import jakarta.persistence.Table;

@Entity
@Table(name = "users")
public class User {
    @Id
    private Long id;
    private String fullName;
    private String email;
}
```

**3. `@Id` y `@GeneratedValue`**

Se usan para definir la clave primaria de la entidad y la estrategia de generación del identificador.

```java
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;

@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String fullName;
    private String email;
}
```

La anotación `@GeneratedValue` se utiliza para especificar cómo se generará el valor de la clave primaria. En este caso, se está utilizando la estrategia `IDENTITY`, que permite que la base de datos genere automáticamente el valor del identificador.

**4. `@Column`**

Personaliza las propiedades de un atributo en la base de datos, como su nombre, restricciones y opciones de mapeo.

```java
import jakarta.persistence.Column;

@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "full_name", nullable = false, length = 100)
    private String fullName;

    @Column(unique = true)
    private String email;
}
```

**5. `@ManyToOne`, `@OneToMany`, `@OneToOne`, `@ManyToMany`**

Estas anotaciones definen relaciones entre entidades. Por medio de estas anotaciones, se establecen las llaves foráneas y las relaciones de asociación entre las tablas en la base de datos.

```java
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    private User user;
}

@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToMany(mappedBy = "user")
    private List<Order> orders;
}
```

En esta relación, un usuario puede tener múltiples órdenes, pero cada orden pertenece a un solo usuario. Otro aspecto importante es que las relaciones entre entidades pueden ser unidireccionales o bidireccionales.

---

## Precauciones y Recomendaciones

- Recuerde verificar que tiene instalado el JDK de Java (preferiblemente la versión 21). 
- Asegúrese tener el servidor de base de datos en ejecución.
- Se recomienda que primero se haga un **diagrama de clases** para visualizar la estructura de las entidades y sus relaciones. 

---

## Evaluación o Resultado

Se espera que el estudiante logre modelar entidades lógicas de una aplicación y que por medio de ellas se generen las colecciones correspondientes en la base de datos que las representen de forma adecuada.

---

## Procedimiento

### 1. Configuración inicial

En esta guía trabajaremos en el **proyecto de la tienda** visto en la guía anterior. Agregue la siguiente dependencia en el archivo `build.gradle`.

```groovy
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
runtimeOnly 'org.mariadb.jdbc:mariadb-java-client'
```

Sincronice Gradle para que descargue la dependencia.

### 2. Modificar archivo `application.properties`

Agregue la siguiente configuración en el archivo `src/main/resources/application.properties`:

```properties
# Configuración datasource
spring.datasource.url=jdbc:mariadb://localhost:3306/tienda
spring.datasource.username=root
spring.datasource.password=su_contraseña
spring.datasource.driver-class-name=org.mariadb.jdbc.Driver

# Configuración JPA/Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
```

El archivo `application.properties` es fundamental en un proyecto de Spring. En este archivo se define la configuración de una aplicación, como por ejemplo, la conexión a la base de datos, el uso de modo debug para hacer un logging más detallado, entre otras cosas. Para conocer más sobre las propiedades que se pueden usar, podemos visitar [la documentación oficial de Spring Boot](https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html).

En nuestro caso, el archivo de propiedades, tiene los datos de conexión a la base de datos de MariaDB. Es decir, nos vamos a conectar a la base de datos con el nombre `tienda` que está en el puerto `3306` (que es el puerto por defecto de MariaDB) en `localhost`.

### 3. Crear la base de datos en MariaDB

Para crear la base de datos en MariaDB, debe ingresar al cliente de MariaDB y ejecutar el siguiente comando:

```sql
CREATE DATABASE tienda;
```

### 4. Crear Entidades

A continuación, crearemos las entidades que representarán las tablas en nuestra base de datos. Ubíquese en la carpeta `main/java` y en el paquete `co.edu.uniquindio.application.model`, cree las siguientes clases:

#### Entidad `Customer`

Si aún no la tiene, cree la clase `Customer` que representará a los clientes de nuestra aplicación. Debe quedar así:

```java
package co.edu.uniquindio.application.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter 
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Customer {

    @Id
    private String idNumber;

    private String name;
    private String email;
    private String phoneNumber;
}
```

Se agrega la anotación `@Entity` para indicar que esta clase es una entidad de JPA. También se han agregado las anotaciones `@NoArgsConstructor` y `@AllArgsConstructor` para generar constructores sin argumentos y con todos los argumentos, respectivamente. Esto es útil para la creación de instancias de la entidad.

Además, es recomendable utilizar la anotación `@Builder` para facilitar la creación de instancias de la entidad de manera más legible y mantenible.

> ⚠️ **Importante:** Es obligatorio tener un constructor sin argumentos en las entidades de JPA.

**Restricciones de los campos:**

Es una buena práctica definir las restricciones de las propiedades de la entidad, como por ejemplo, la longitud máxima de un campo o si un campo es obligatorio, etc. Por ejemplo:

```java
@Entity
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Customer {

    @Id
    @Column(length = 10)
    private String idNumber;

    @Column(length = 100, nullable = false)
    private String name;

    @Column(length = 100, nullable = false)
    private String email;

    @Column(length = 15) // Puede ser nulo
    private String phoneNumber;
}
```

Cuando se haga el mapeo a la tabla `customer`, se crearán las columnas correspondientes en la base de datos con las restricciones definidas en las anotaciones `@Column`.

#### Entidad `Product`

La entidad `Product`, con sus campos y restricciones, debe quedar de la siguiente manera:

```java
package co.edu.uniquindio.application.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Product {

    @Id
    private String code;

    @Column(length = 100, nullable = false)
    private String name;

    @Column(length = 100, nullable = false)
    private String type;

    private double price;
    private int quantity;
}
```

Puede ser útil crear un `enum` para los tipos de productos. De esta manera, se puede garantizar que solo se utilicen tipos de productos válidos en la aplicación. Si este `enum` se llama `ProductType`, el campo `type` debe quedar así:

```java
@Column(nullable = false) // No se usa length porque se trata de un enum
private ProductType type;
```

O si un producto, puede tener múltiples tipos, se podría utilizar una colección:

```java
@ElementCollection // Indica que es una colección de elementos básicos
private Set<ProductType> type;
```

#### Entidad `Payment`

La entidad `Payment` estará asociada a cada orden (transacción). Esta entidad debe quedar así:

```java
package co.edu.uniquindio.application.model;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDate;

@Entity
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Payment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private LocalDate date;
    private double amount;
    @Column(length = 50, nullable = false)
    private String status;   // pagado, pendiente, fallido
    @Column(length = 50, nullable = false)
    private String method;   // tarjeta, efectivo, etc.
}
```

En esta entidad también se puede llegar a usar un `enum` para los métodos de pago y los estados de pago.

#### Entidad `Order`

La entidad `Order` representará una orden de compra (transacción) realizada por un cliente. Debe quedar así:

```java
package co.edu.uniquindio.application.model;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDate;
import java.util.List;

@Entity
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Table(name = "orders") // "order" es palabra reservada en SQL
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(nullable = false)
    private Customer customer;

    @Column(nullable = false)
    private LocalDate purchaseDate;

    @OneToOne
    private Payment payment;

    @OneToMany(mappedBy = "order")
    private List<OrderItem> items;
}
```

Como se mencionó anteriormente, las relaciones entre entidades deben definirse usando las anotaciones de JPA correspondientes. Por ejemplo:

- Se usa la anotación `@ManyToOne` para establecer una relación de muchos a uno entre `Order` y `Customer`, lo que significa que un cliente puede tener múltiples órdenes, pero una orden solo puede pertenecer a un cliente.
- Se usa la anotación `@OneToOne` para establecer una relación de uno a uno entre `Order` y `Payment`, lo que significa que cada orden tiene un único pago asociado.
- Se usa la anotación `@OneToMany` para establecer una relación de uno a muchos entre `Order` y `OrderItem`, lo que significa que una orden puede tener múltiples artículos.

Además, se usan las anotaciones `@JoinColumn` para especificar las columnas de unión en las relaciones.

#### Entidad `OrderItem`

Por último, la entidad `OrderItem` representará los artículos de cada orden (transacción). Debe quedar así:

```java
package co.edu.uniquindio.application.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrderItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(nullable = false)
    private Order order;

    @ManyToOne
    @JoinColumn(nullable = false)
    private Product product;

    private int quantity;
    private double subtotal;
}
```

En este caso, cada relación se explica así:

- La relación entre `OrderItem` y `Order` es de muchos a uno, ya que un artículo de la orden pertenece a una única orden, pero una orden puede tener múltiples artículos.
- La relación entre `OrderItem` y `Product` también es de muchos a uno, ya que un artículo de la orden se refiere a un único producto, pero un producto puede estar en múltiples artículos de orden.

### 5. Ejecución del proyecto

Ejecute la aplicación Spring Boot y verifique que no haya errores en la consola. Luego, vaya al cliente de MariaDB y verifique que las tablas se hayan creado correctamente.

### 6. Creación de las entidades del proyecto final

Con base en este ejemplo, cree todas las entidades necesarias para el proyecto final. Asegúrese de incluir las anotaciones adecuadas y de seguir las mejores prácticas de diseño de entidades.

### 7. Confirmar cambios en Git

Recuerde agregar los archivos modificados y nuevos al repositorio de git y hacer commit.

---

## Para la próxima clase
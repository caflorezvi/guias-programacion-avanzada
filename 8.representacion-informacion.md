```
Programa de Ingenier铆a de Sistemas y Computaci贸n
Universidad del Quind铆o

T铆tulo: Entidades para Representaci贸n de Informaci贸n
Duraci贸n estimada: 120
Docentes: Carlos Andr茅s Florez, Christian Andr茅s Candela
Gu铆a: 08
```
---

# Entidades para la representaci贸n de la informaci贸n

##  Objetivo

Comprender el concepto de **entidad** en Spring Boot y su relaci贸n con las **tablas** en las bases de datos relacionales, aplicando buenas pr谩cticas de modelado de datos para aplicaciones SQL.

---

## Conceptos B谩sicos

- **Base de datos**: Conjunto de datos estructurados que se almacenan y gestionan de manera eficiente.
- **JSON**: Formato de intercambio de datos ligero.  
- **POO**: Programaci贸n Orientada a Objetos en Java.  
- **Spring Data JPA**: M贸dulo de Spring para integraci贸n con bases de datos relacionales.  
- **Java**

---

## Contextualizaci贸n Te贸rica

En el desarrollo de aplicaciones, es com煤n que los datos generados y utilizados por la aplicaci贸n necesiten ser almacenados de manera permanente para su posterior recuperaci贸n y uso. Tradicionalmente, esto se ha logrado mediante bases de datos relacionales, en las cuales los datos se organizan en tablas con filas y columnas. Sin embargo, los lenguajes de programaci贸n orientados a objetos (OOP) como Java trabajan con estructuras de datos representadas mediante clases y objetos, lo que genera una disparidad entre la forma en que se almacenan y manipulan los datos en la aplicaci贸n y en la base de datos.

Para interactuar con bases de datos relacionales, los desarrolladores sol铆an escribir consultas SQL manuales dentro del c贸digo de la aplicaci贸n, lo que llevaba a problemas como:

- **Acoplamiento entre l贸gica de negocio y acceso a datos**: La mezcla de SQL dentro del c贸digo hac铆a dif铆cil la mantenibilidad y escalabilidad.
- **Errores comunes de seguridad**: Como inyecciones SQL debido al uso inadecuado de concatenaciones de strings.
- **Inconsistencia en las consultas**: Diferentes partes del c贸digo pod铆an manejar la misma consulta de formas distintas.
- **Dificultad en la migraci贸n de bases de datos**: Al cambiar de base de datos, se requer铆a modificar todas las consultas SQL escritas manualmente.
- **Inconsistencia de datos** al mapear objetos a tablas.   
- **Acoplamiento** entre l贸gica de negocio y acceso a datos. 

Para solucionar estos problemas, surgieron los frameworks de mapeo objeto-relacional (ORM) y los Object-Document Mapping (ODM), que permiten gestionar la persistencia de datos de manera transparente y eficiente.

### ORM (Object-Relational Mapping)

El mapeo objeto-relacional (ORM, por sus siglas en ingl茅s) es una t茅cnica de programaci贸n que permite interactuar con bases de datos relacionales utilizando objetos en un lenguaje de programaci贸n orientado a objetos, como Java. ORM permite que los desarrolladores trabajen con estructuras de datos sin escribir directamente consultas SQL, ya que el framework ORM se encarga de traducir las operaciones de los objetos a comandos SQL subyacentes.

Los principales beneficios del uso de ORM incluyen:

- **Abstracci贸n del acceso a datos**: Facilita la escritura y mantenimiento del c贸digo.
- **Reducci贸n de errores**: Al evitar SQL manual, se minimizan los errores comunes.
- **Compatibilidad con m煤ltiples bases de datos**: Permite cambiar de base de datos con menor esfuerzo.
- **Gesti贸n de transacciones y cach茅**: ORM maneja transacciones autom谩ticamente y mejora el rendimiento mediante cach茅.

Ejemplos populares de frameworks ORM en Java incluyen Hibernate (que implementa JPA), EclipseLink entre otros.

### JPA (Java Persistence API)

JPA es una especificaci贸n de Java para la gesti贸n de persistencia y mapeo objeto-relacional. No es una implementaci贸n en s铆, sino un conjunto de reglas y anotaciones que permiten definir entidades y gestionar su almacenamiento en bases de datos relacionales. Hibernate es la implementaci贸n de JPA m谩s utilizada en Java.

JPA proporciona diversas anotaciones para definir entidades, sus atributos y relaciones. A continuaci贸n, se presentan las m谩s comunes:

**1. `@Entity`**

Una entidad es un elemento de persistencia, que permite modelar o representar un objeto o informaci贸n del sistema que estamos construyendo. Toda entidad est谩 compuesta por uno o m谩s atributos, cada uno de los cuales representa una propiedad o informaci贸n del objeto que se est谩 modelando.

La anotaci贸n `@Entity` se usa para marcar una clase como una entidad que se mapear谩 a una tabla en la base de datos.

```java
import jakarta.persistence.Entity;
import jakarta.persistence.Id;

@Entity
public class User {
    @Id
    private Long id;
    private String fullName;
    private String email;
}
```

**2. `@Table`**

Permite definir el nombre de la tabla en la base de datos. Si no se especifica, JPA utilizar谩 el nombre de la clase como nombre de la tabla.

```java
import jakarta.persistence.Table;

@Entity
@Table(name = "users")
public class User {
    @Id
    private Long id;
    private String fullName;
    private String email;
}
```

**3. `@Id` y `@GeneratedValue`**

Se usan para definir la clave primaria de la entidad y la estrategia de generaci贸n del identificador.

```java
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;

@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String fullName;
    private String email;
}
```

La anotaci贸n `@GeneratedValue` se utiliza para especificar c贸mo se generar谩 el valor de la clave primaria. En este caso, se est谩 utilizando la estrategia `IDENTITY`, que permite que la base de datos genere autom谩ticamente el valor del identificador.

**4. `@Column`**

Personaliza las propiedades de un atributo en la base de datos, como su nombre, restricciones y opciones de mapeo.

```java
import jakarta.persistence.Column;

@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "full_name", nullable = false, length = 100)
    private String fullName;

    @Column(unique = true)
    private String email;
}
```

**5. `@ManyToOne`, `@OneToMany`, `@OneToOne`, `@ManyToMany`**

Estas anotaciones definen relaciones entre entidades. Por medio de estas anotaciones, se establecen las llaves for谩neas y las relaciones de asociaci贸n entre las tablas en la base de datos.

```java
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne
    private User user;
}

@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToMany(mappedBy = "user")
    private List<Order> orders;
}
```

En esta relaci贸n, un usuario puede tener m煤ltiples 贸rdenes, pero cada orden pertenece a un solo usuario. Otro aspecto importante es que las relaciones entre entidades pueden ser unidireccionales o bidireccionales.

---

## Precauciones y Recomendaciones

- Recuerde verificar que tiene instalado el JDK de Java (preferiblemente la versi贸n 21). 
- Aseg煤rese tener el servidor de base de datos en ejecuci贸n.
- Se recomienda que primero se haga un **diagrama de clases** para visualizar la estructura de las entidades y sus relaciones. 

---

## Evaluaci贸n o Resultado

Se espera que el estudiante logre modelar entidades l贸gicas de una aplicaci贸n y que por medio de ellas se generen las colecciones correspondientes en la base de datos que las representen de forma adecuada.

---

## Procedimiento

### 1. Configuraci贸n inicial

En esta gu铆a trabajaremos en el **proyecto de la tienda** visto en la gu铆a anterior. Agregue la siguiente dependencia en el archivo `build.gradle`.

```groovy
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
runtimeOnly 'org.mariadb.jdbc:mariadb-java-client'
```

Sincronice Gradle para que descargue la dependencia.

### 2. Modificar archivo `application.properties`

Agregue la siguiente configuraci贸n en el archivo `src/main/resources/application.properties`:

```properties
# Configuraci贸n datasource
spring.datasource.url=jdbc:mariadb://localhost:3306/tienda
spring.datasource.username=root
spring.datasource.password=su_contrase帽a
spring.datasource.driver-class-name=org.mariadb.jdbc.Driver

# Configuraci贸n JPA/Hibernate
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
```

El archivo `application.properties` es fundamental en un proyecto de Spring. En este archivo se define la configuraci贸n de una aplicaci贸n, como por ejemplo, la conexi贸n a la base de datos, el uso de modo debug para hacer un logging m谩s detallado, entre otras cosas. Para conocer m谩s sobre las propiedades que se pueden usar, podemos visitar [la documentaci贸n oficial de Spring Boot](https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html).

En nuestro caso, el archivo de propiedades, tiene los datos de conexi贸n a la base de datos de MariaDB. Es decir, nos vamos a conectar a la base de datos con el nombre `tienda` que est谩 en el puerto `3306` (que es el puerto por defecto de MariaDB) en `localhost`.

### 3. Crear la base de datos en MariaDB

Para crear la base de datos en MariaDB, debe ingresar al cliente de MariaDB y ejecutar el siguiente comando:

```sql
CREATE DATABASE tienda;
```

### 4. Crear Entidades

A continuaci贸n, crearemos las entidades que representar谩n las tablas en nuestra base de datos. Ub铆quese en la carpeta `main/java` y en el paquete `co.edu.uniquindio.application.model`, cree las siguientes clases:

#### Entidad `Customer`

Si a煤n no la tiene, cree la clase `Customer` que representar谩 a los clientes de nuestra aplicaci贸n. Debe quedar as铆:

```java
package co.edu.uniquindio.application.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter 
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Customer {

    @Id
    private String idNumber;

    private String name;
    private String email;
    private String phoneNumber;
}
```

Se agrega la anotaci贸n `@Entity` para indicar que esta clase es una entidad de JPA. Tambi茅n se han agregado las anotaciones `@NoArgsConstructor` y `@AllArgsConstructor` para generar constructores sin argumentos y con todos los argumentos, respectivamente. Esto es 煤til para la creaci贸n de instancias de la entidad.

Adem谩s, es recomendable utilizar la anotaci贸n `@Builder` para facilitar la creaci贸n de instancias de la entidad de manera m谩s legible y mantenible.

> 锔 **Importante:** Es obligatorio tener un constructor sin argumentos en las entidades de JPA.

**Restricciones de los campos:**

Es una buena pr谩ctica definir las restricciones de las propiedades de la entidad, como por ejemplo, la longitud m谩xima de un campo o si un campo es obligatorio, etc. Por ejemplo:

```java
@Entity
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Customer {

    @Id
    @Column(length = 10)
    private String idNumber;

    @Column(length = 100, nullable = false)
    private String name;

    @Column(length = 100, nullable = false)
    private String email;

    @Column(length = 15) // Puede ser nulo
    private String phoneNumber;
}
```

Cuando se haga el mapeo a la tabla `customer`, se crear谩n las columnas correspondientes en la base de datos con las restricciones definidas en las anotaciones `@Column`.

#### Entidad `Product`

La entidad `Product`, con sus campos y restricciones, debe quedar de la siguiente manera:

```java
package co.edu.uniquindio.application.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Product {

    @Id
    private String code;

    @Column(length = 100, nullable = false)
    private String name;

    @Column(length = 100, nullable = false)
    private String type;

    private double price;
    private int quantity;
}
```

Puede ser 煤til crear un `enum` para los tipos de productos. De esta manera, se puede garantizar que solo se utilicen tipos de productos v谩lidos en la aplicaci贸n. Si este `enum` se llama `ProductType`, el campo `type` debe quedar as铆:

```java
@Column(nullable = false) // No se usa length porque se trata de un enum
private ProductType type;
```

O si un producto, puede tener m煤ltiples tipos, se podr铆a utilizar una colecci贸n:

```java
@ElementCollection // Indica que es una colecci贸n de elementos b谩sicos
private Set<ProductType> type;
```

#### Entidad `Payment`

La entidad `Payment` estar谩 asociada a cada orden (transacci贸n). Esta entidad debe quedar as铆:

```java
package co.edu.uniquindio.application.model;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDate;

@Entity
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Payment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private LocalDate date;
    private double amount;
    @Column(length = 50, nullable = false)
    private String status;   // pagado, pendiente, fallido
    @Column(length = 50, nullable = false)
    private String method;   // tarjeta, efectivo, etc.
}
```

En esta entidad tambi茅n se puede llegar a usar un `enum` para los m茅todos de pago y los estados de pago.

#### Entidad `Order`

La entidad `Order` representar谩 una orden de compra (transacci贸n) realizada por un cliente. Debe quedar as铆:

```java
package co.edu.uniquindio.application.model;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDate;
import java.util.List;

@Entity
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Table(name = "orders") // "order" es palabra reservada en SQL
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(nullable = false)
    private Customer customer;

    @Column(nullable = false)
    private LocalDate purchaseDate;

    @OneToOne
    private Payment payment;

    @OneToMany(mappedBy = "order")
    private List<OrderItem> items;
}
```

Como se mencion贸 anteriormente, las relaciones entre entidades deben definirse usando las anotaciones de JPA correspondientes. Por ejemplo:

- Se usa la anotaci贸n `@ManyToOne` para establecer una relaci贸n de muchos a uno entre `Order` y `Customer`, lo que significa que un cliente puede tener m煤ltiples 贸rdenes, pero una orden solo puede pertenecer a un cliente.
- Se usa la anotaci贸n `@OneToOne` para establecer una relaci贸n de uno a uno entre `Order` y `Payment`, lo que significa que cada orden tiene un 煤nico pago asociado.
- Se usa la anotaci贸n `@OneToMany` para establecer una relaci贸n de uno a muchos entre `Order` y `OrderItem`, lo que significa que una orden puede tener m煤ltiples art铆culos.

Adem谩s, se usan las anotaciones `@JoinColumn` para especificar las columnas de uni贸n en las relaciones.

#### Entidad `OrderItem`

Por 煤ltimo, la entidad `OrderItem` representar谩 los art铆culos de cada orden (transacci贸n). Debe quedar as铆:

```java
package co.edu.uniquindio.application.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrderItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(nullable = false)
    private Order order;

    @ManyToOne
    @JoinColumn(nullable = false)
    private Product product;

    private int quantity;
    private double subtotal;
}
```

En este caso, cada relaci贸n se explica as铆:

- La relaci贸n entre `OrderItem` y `Order` es de muchos a uno, ya que un art铆culo de la orden pertenece a una 煤nica orden, pero una orden puede tener m煤ltiples art铆culos.
- La relaci贸n entre `OrderItem` y `Product` tambi茅n es de muchos a uno, ya que un art铆culo de la orden se refiere a un 煤nico producto, pero un producto puede estar en m煤ltiples art铆culos de orden.

### 5. Ejecuci贸n del proyecto

Ejecute la aplicaci贸n Spring Boot y verifique que no haya errores en la consola. Luego, vaya al cliente de MariaDB y verifique que las tablas se hayan creado correctamente.

### 6. Creaci贸n de las entidades del proyecto final

Con base en este ejemplo, cree todas las entidades necesarias para el proyecto final. Aseg煤rese de incluir las anotaciones adecuadas y de seguir las mejores pr谩cticas de dise帽o de entidades.

### 7. Confirmar cambios en Git

Recuerde agregar los archivos modificados y nuevos al repositorio de git y hacer commit.

---

## Para la pr贸xima clase
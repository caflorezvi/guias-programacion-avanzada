```
Programa de Ingeniería de Sistemas y Computación
Universidad del Quindío

Título: Implementación de Servicios de negocio en Spring Boot
Duración estimada: 120
Docentes: Carlos Andrés Florez, Christian Andrés Candela
Guía: 06
```
# **Servicios de negocio en Spring Boot**

## **🎯 Objetivo**  
Implementar servicios de negocio en **Spring Boot**. Se explorará la creación de servicios, la lógica de negocio y la validación de datos mediante pruebas unitarias.

---

## **Conceptos Básicos**  

- **Spring Boot:** Framework para desarrollar aplicaciones en Java con una configuración mínima.
- **Servicios REST:** Componentes que exponen los servicios de la aplicación para su uso.
- **Servicios de negocio:** Componentes que encapsulan la lógica empresarial y procesan las reglas del negocio.
- **Inyección de dependencias:** Mecanismo para gestionar la creación y administración de componentes.
- **HTTP (Hypertext Transfer Protocol)**  Protocolo de comunicación para la transferencia de datos en la web. 
- **OpenAPI**  Especificación abierta para describir APIs RESTful.
- **CRUD (Create, Read, Update, Delete)**  Conjunto de operaciones básicas para manipular datos (crear, leer, actualizar y eliminar).

---

## **Contextualización Teórica** 

Los **servicios de negocio** son la capa de una aplicación responsable de la lógica principal. En Spring Boot, estas clases se identifican con la anotación `@Service`, que es una especialización de `@Component`. Al marcar una clase con `@Service`, le estamos indicando a Spring que debe gestionar esta clase como un **bean** de servicio dentro del contexto de la aplicación. De esta forma, se encapsula la lógica de negocio en un solo lugar y permite que otras partes de la aplicación puedan inyectar y utilizar ese servicio fácilmente.

Aquí hay algunas características clave de los servicios de negocio en el contexto de Spring Boot:

- **Lógica de Negocio:** Los servicios de negocio encapsulan la lógica empresarial de la aplicación, implementando operaciones, validaciones y reglas específicas del dominio.

- **Reutilización:** Los servicios de negocio pueden ser diseñados para ser reutilizables en diferentes partes de la aplicación. Esto promueve la modularidad y facilita la gestión de la lógica de negocio.

- **Separación de Responsabilidades:** Spring Boot sigue el principio de separación de responsabilidades, por lo que los servicios de negocio se encargan de la lógica empresarial mientras que otros componentes, como los controladores y las capas de persistencia, se centran en tareas específicas.

- **Inyección de Dependencias:** Spring Boot utiliza la inversión de control (IoC) y la inyección de dependencias para gestionar la creación y administración de componentes. Los servicios de negocio pueden beneficiarse de la inyección de dependencias para obtener fácilmente otras dependencias necesarias.

- **Transacciones:** En aplicaciones empresariales, a menudo es necesario gestionar transacciones. Spring Boot ofrece soporte para la gestión de transacciones, lo que permite que los servicios de negocio participen en transacciones de base de datos de manera coherente.

---

## **Buenas Prácticas y Recomendaciones**  

- **Separación de responsabilidades:** Mantenga la lógica de negocio en los servicios y evite incluirla en los controladores.

- **Uso de excepciones personalizadas:** Cree excepciones específicas para manejar errores en la lógica de negocio.

- **Validaciones en DTOs:** Utilice anotaciones como `@Valid` y `@NotNull` para garantizar la integridad de los datos de entrada.

- **Estructura modular:** Organice el código en paquetes bien definidos (`controllers`, `services`, `model`, `exceptions`).

---

## Procedimiento

#### 1. Definición de la estructura de User

Cree un nuevo paquete con el nombre `model` y dentro de él, cree la clase `User` con la siguiente estructura:

```java
package co.edu.uniquindio.application.model;

import lombok.Builder;
import lombok.Getter;
import lombok.Setter;
import java.time.LocalDate;

@Getter
@Setter
@Builder
public class User {
    private String id;
    private String name;
    private String phone;
    private String email;
    private String password;
    private String photoUrl;
    private LocalDate dateBirth;
    private Role role;
    private UserStatus status;
}
```

Adicionalmente, cree las enumeraciones `Role` y `UserStatus` en el paquete `model`:

```java
package co.edu.uniquindio.application.model;

public enum Role {
    USER,
    HOST,
    ADMIN
}
```

```java
package co.edu.uniquindio.application.model;

public enum UserStatus {
    ACTIVE,
    INACTIVE,
    DELETED
}
```

#### **2. Definición de la interfaz del Servicio de Usuarios**

Con el fin de reducir el acoplamiento en los componentes del sistema, es una buena práctica **definir** los métodos de negocio en una interfaz. Cree el paquete `services` y dentro de él, la interfaz `UserService`.

Para esta guía se implementará un CRUD a manera de ejemplo, por lo tanto, se necesitan los siguientes métodos (para el proyecto final debe agregar más métodos):


```java
package co.edu.uniquindio.application.services;

import co.edu.uniquindio.application.dto.CreateUserDTO;
import co.edu.uniquindio.application.dto.EditUserDTO;
import co.edu.uniquindio.application.dto.UserDTO;
import java.util.List;

public interface UserService {

    void create(CreateUserDTO account) throws Exception;

    UserDTO get(String id) throws Exception;

    void delete(String id) throws Exception;

    List<UserDTO> listAll();

    void edit(String id, EditUserDTO account) throws Exception;

}
```

Debe haber cierta correspondencia entre los métodos definidos en la interfaz del servicio con los métodos que están en el controlador REST, ya que el controlador usa los métodos del servicio para realizar las operaciones.

Como puede ver, algunos métodos tienen un `throws Exception`, esto es debido a que siempre debemos validar y capturar las excepciones que puedan aparecer al momento de manipular la base de datos (consultar, insertar, actualizar o eliminar).

> ⚠️ **Importante:** Es una buena práctica primero definir los servicios por medio de interfaces ya que allí podemos listar todos los requisitos, sus entradas de datos y sus retornos. Básicamente en el interface definimos qué hay que hacer pero no el cómo.

#### **3. Implementación del Servicio de Usuarios**

El siguiente paso es implementar la lógica de cada servicio de negocio. Para esto, cree un paquete nuevo dentro del paquete `services` que se llame `impl` y allí cree la clase `UserServiceImpl`. Esta clase debe implementar todos los métodos de la interfaz `UserService`. Así debe quedar inicialmente:

```java
package co.edu.uniquindio.application.services.impl;

import co.edu.uniquindio.application.services.UserService;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {
    
}
```

Para simular la persistencia se hará uso de una estructura de almacenamiento en memoria (**Map**). Agregue el siguiente atributo a la clase `UserServiceImpl`:

```java
private final Map<String, User> userStore = new ConcurrentHashMap<>();
```

A continuación se muestra una alternativa de implementación de algunos métodos del CRUD:

#### Crear un nuevo usuario

```java
@Override
public void create(CreateUserDTO account) throws Exception {
    if(isEmailDuplicated(account.email())){
        throw new Exception("El correo electrónico ya está en uso.");
    }

    User newUser = User.builder()
            .id(UUID.randomUUID().toString())
            .name(account.name())
            .email(account.email())
            .phone(account.phone())
            .role(account.role())
            .dateBirth(account.dateBirth())
            .photoUrl(account.photoUrl())
            .password(account.password())
            .createdAt(LocalDateTime.now())
            .status(UserStatus.ACTIVE)
            .build();

    userStore.put(newUser.getId(), newUser);
}

private boolean isEmailDuplicated(String email){
    return userStore.values().stream().anyMatch(
            u -> u.getEmail().equalsIgnoreCase(email)
    );
}
```

Se utiliza un método de apoyo para verificar si el correo electrónico ya está en uso antes de crear un nuevo usuario. Esto ayuda a mantener la lógica de negocio separada y reutilizable. Se asume que una regla de negocio es que los correos electrónicos deben ser únicos en el sistema.

Dado que la contraseña debe estar cifrada, se debe usar una dependencia que nos ayude con esto, agregue la siguiente dependencia en el archivo `build.gradle`:

```groovy
implementation 'org.springframework.security:spring-security-crypto'
```

> ⚠️ **Importante:** No olvide sincronizar Gradle después de agregar la dependencia.

Agregue el método `encode` en la clase `UserServiceImpl` para cifrar la contraseña antes de guardarla:

```java
private String encode(String password){
    var passwordEncoder = new BCryptPasswordEncoder();
    return passwordEncoder.encode(password);
}
```

Llame este método en el proceso de creación de usuarios, específicamente al asignar la contraseña del nuevo usuario `newUser`:

```java
password(encode(account.password()))
```

#### Obtener un usuario

Se valida que el usuario existe antes de intentar acceder a sus datos, luego se mapean sus atributos a un objeto DTO.

```java
@Override
public UserDTO get(String id) throws Exception {
    User user = userStore.get(id);

    if (user == null) {
        throw new Exception("Usuario no encontrado.");
    }

    return new UserDTO(
            user.getId(),
            user.getName(),
            user.getPhone(),
            user.getEmail(),
            user.getPhotoUrl(),
            user.getDateBirth(),
            user.getRole()
    );
    
}
```

#### Eliminar un usuario

Se valida que el usuario existe antes de intentar eliminarlo, luego se procede a eliminarlo.

```java
@Override
public void delete(String id) throws Exception {
    User user = userStore.remove(id);
    if (user == null) {
        throw new Exception("Usuario no encontrado.");
    }

    userStore.remove(id);
}
```

Implemente las demás operaciones del CRUD (Actualizar y Listar usuarios) siguiendo la misma lógica de validación y manejo de excepciones.

#### 4. Implementación de Mappers

Es posible centralizar la tarea de transformación de los datos mediante la implementación de un **Mapper**. 

Los mappers son una herramienta fundamental en el desarrollo de aplicaciones, ya que permiten transformar la forma en que representamos la información en diferentes capas de la aplicación. Su principal función es facilitar la conversión entre las estructuras de datos utilizadas en las solicitudes (DTOs - Data Transfer Objects) y las estructuras de datos que se persisten en la base de datos (entidades) y viceversa.

Para esto, agregue las siguientes dependencias en el archivo `build.gradle`:

```groovy
implementation 'org.mapstruct:mapstruct:1.6.3'
annotationProcessor 'org.mapstruct:mapstruct-processor:1.6.3'
```
> ⚠️ **Importante:** No olvide sincronizar Gradle después de agregar la dependencia.

Cree un nuevo paquete `mappers` en el directorio `src/main/java` y dentro de este paquete, cree una interfaz `UserMapper`:

```java
package co.edu.uniquindio.application.mappers;

import co.edu.uniquindio.application.dto.CreateUserDTO;
import co.edu.uniquindio.application.dto.UserDTO;
import co.edu.uniquindio.application.model.User;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingConstants;

@Mapper(componentModel = MappingConstants.ComponentModel.SPRING)
public interface UserMapper {

    @Mapping(target = "id", expression = "java(java.util.UUID.randomUUID().toString())")
    @Mapping(target = "status", constant = "ACTIVE")
    @Mapping(target = "createdAt", expression = "java(java.time.LocalDateTime.now())")
    User toEntity(CreateUserDTO userDTO);

    UserDTO toUserDTO(User user);
}
```

El método `toEntity` convierte un `CreateUserDTO` en un objeto `User`, generando un ID único, asignando la fecha de creación y estableciendo el estado del usuario como activo.

Ahora, se debe actualizar el servicio de usuarios para utilizar el mapper en lugar de realizar las conversiones manualmente.

```java
package co.edu.uniquindio.application.services.impl;

@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    private final UserMapper userMapper;
    private final Map<String, User> userStore = new ConcurrentHashMap<>();

    @Override
    public void create(CreateUserDTO account) throws Exception {
        //Validación del email
        if(isEmailDuplicated(account.email())){
            throw new Exception("El correo electrónico ya está en uso.");
        }

        //Transformación del DTO a User
        User newUser = userMapper.toEntity(account);
        newUser.setPassword(encode(account.password()));

        //Almacenamiento del usuario
        userStore.put(newUser.getId(), newUser);
    }

    @Override
    public UserDTO get(String id) throws Exception {
        User user = userStore.get(id);

        if (user == null) {
            throw new Exception("Usuario no encontrado.");
        }

        //Transformación del User a DTO
        return userMapper.toUserDTO(user);

    }
}
```
Gracias a la implementación de MapStruct, hemos simplificado significativamente el proceso de mapeo entre nuestros DTOs y entidades. Además con la inyección de dependencias de Spring, el uso de mappers se vuelve aún más sencillo y limpio.

> **⚠️ Importante**: Asegúrese que los nombres de los atributos que comparten los DTO y las clases del modelo coincidan. Por ejemplo, la clase `User` tiene el campo name, email, phone, etc. y el DTO `CreateUserDTO` también tiene esos mismos campos. Esto es necesario para que MapStruct pueda hacer el mapeo automáticamente.
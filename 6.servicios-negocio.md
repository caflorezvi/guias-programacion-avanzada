```
Programa de Ingenier铆a de Sistemas y Computaci贸n
Universidad del Quind铆o

T铆tulo: Implementaci贸n de Servicios de negocio en Spring Boot
Duraci贸n estimada: 120
Docentes: Carlos Andr茅s Florez, Christian Andr茅s Candela
Gu铆a: 06
```
# Servicios de negocio en Spring Boot

##  Objetivo 
Implementar servicios de negocio en **Spring Boot**. Se explorar谩 la creaci贸n de servicios, la l贸gica de negocio y la validaci贸n de datos mediante pruebas unitarias.

---

## Conceptos B谩sicos 

- **Spring Boot:** Framework para desarrollar aplicaciones en Java con una configuraci贸n m铆nima.
- **Servicios REST:** Componentes que exponen los servicios de la aplicaci贸n para su uso.
- **Servicios de negocio:** Componentes que encapsulan la l贸gica empresarial y procesan las reglas del negocio.
- **Inyecci贸n de dependencias:** Mecanismo para gestionar la creaci贸n y administraci贸n de componentes.
- **HTTP (Hypertext Transfer Protocol)**  Protocolo de comunicaci贸n para la transferencia de datos en la web. 
- **OpenAPI**  Especificaci贸n abierta para describir APIs RESTful.
- **CRUD (Create, Read, Update, Delete)**  Conjunto de operaciones b谩sicas para manipular datos (crear, leer, actualizar y eliminar).

---

## Contextualizaci贸n Te贸rica 

Los **servicios de negocio** son la capa de una aplicaci贸n responsable de la l贸gica principal. En Spring Boot, estas clases se identifican con la anotaci贸n `@Service`, que es una especializaci贸n de `@Component`. Al marcar una clase con `@Service`, le estamos indicando a Spring que debe gestionar esta clase como un **bean** de servicio dentro del contexto de la aplicaci贸n. De esta forma, se encapsula la l贸gica de negocio en un solo lugar y permite que otras partes de la aplicaci贸n puedan inyectar y utilizar ese servicio f谩cilmente.

Aqu铆 hay algunas caracter铆sticas clave de los servicios de negocio en el contexto de Spring Boot:

- **L贸gica de Negocio:** Los servicios de negocio encapsulan la l贸gica empresarial de la aplicaci贸n, implementando operaciones, validaciones y reglas espec铆ficas del dominio.

- **Reutilizaci贸n:** Los servicios de negocio pueden ser dise帽ados para ser reutilizables en diferentes partes de la aplicaci贸n. Esto promueve la modularidad y facilita la gesti贸n de la l贸gica de negocio.

- **Separaci贸n de Responsabilidades:** Spring Boot sigue el principio de separaci贸n de responsabilidades, por lo que los servicios de negocio se encargan de la l贸gica empresarial mientras que otros componentes, como los controladores y las capas de persistencia, se centran en tareas espec铆ficas.

- **Inyecci贸n de Dependencias:** Spring Boot utiliza la inversi贸n de control (IoC) y la inyecci贸n de dependencias para gestionar la creaci贸n y administraci贸n de componentes. Los servicios de negocio pueden beneficiarse de la inyecci贸n de dependencias para obtener f谩cilmente otras dependencias necesarias.

- **Transacciones:** En aplicaciones empresariales, a menudo es necesario gestionar transacciones. Spring Boot ofrece soporte para la gesti贸n de transacciones, lo que permite que los servicios de negocio participen en transacciones de base de datos de manera coherente.

---

## Buenas Pr谩cticas y Recomendaciones  

- **Separaci贸n de responsabilidades:** Mantenga la l贸gica de negocio en los servicios y evite incluirla en los controladores.

- **Uso de excepciones personalizadas:** Cree excepciones espec铆ficas para manejar errores en la l贸gica de negocio.

- **Validaciones en DTOs:** Utilice anotaciones como `@Valid` y `@NotNull` para garantizar la integridad de los datos de entrada.

- **Estructura modular:** Organice el c贸digo en paquetes bien definidos (`controllers`, `services`, `model`, `exceptions`).

---

## Procedimiento

Continuaremos trabajando en el proyecto creado anteriormente.

### 1. Definici贸n de la estructura de User

Cree un nuevo paquete con el nombre `model` y dentro de 茅l, cree la clase `User` con la siguiente estructura:

```java
package co.edu.uniquindio.application.model;

import lombok.Builder;
import lombok.Getter;
import lombok.Setter;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Getter
@Setter
@Builder
public class User {
    private String id;
    private String name;
    private String phone;
    private String email;
    private String password;
    private String photoUrl;
    private LocalDate dateBirth;
    private LocalDateTime createdAt;
    private Role role;
    private UserStatus status;
}
```

Adicionalmente, cree las enumeraciones `Role` y `UserStatus` en el paquete `model`:

```java
package co.edu.uniquindio.application.model;

public enum Role {
    USER,
    HOST,
    ADMIN
}
```

```java
package co.edu.uniquindio.application.model;

public enum UserStatus {
    REGISTERED,
    ACTIVE,
    INACTIVE,
    DELETED
}
```

### **2. Definici贸n de la interfaz del Servicio de Usuarios**

Con el fin de reducir el acoplamiento en los componentes del sistema, es una buena pr谩ctica **definir** los m茅todos de negocio en una interfaz. Cree el paquete `services` y dentro de 茅l, la interfaz `UserService`.

Para esta gu铆a se implementar谩 un CRUD de usuarios a manera de ejemplo, por lo tanto, se necesitan los siguientes m茅todos (para el proyecto final debe agregar m谩s m茅todos):


```java
package co.edu.uniquindio.application.services;

import co.edu.uniquindio.application.dto.CreateUserDTO;
import co.edu.uniquindio.application.dto.EditUserDTO;
import co.edu.uniquindio.application.dto.UserDTO;
import java.util.List;

public interface UserService {

    void create(CreateUserDTO userDTO) throws Exception;

    UserDTO get(String id) throws Exception;

    void delete(String id) throws Exception;

    List<UserDTO> listAll();

    void edit(String id, EditUserDTO userDTO) throws Exception;

}
```

Debe haber cierta correspondencia entre los m茅todos definidos en la interfaz del servicio con los m茅todos que est谩n en el controlador REST, ya que el controlador usa los m茅todos del servicio para realizar las operaciones.

Como puede ver, algunos m茅todos tienen un `throws Exception`, esto es debido a que siempre debemos validar y capturar las excepciones que puedan aparecer al momento de manipular la base de datos (consultar, insertar, actualizar o eliminar).

> 锔 **Importante:** Es una buena pr谩ctica primero definir los servicios por medio de interfaces ya que all铆 podemos listar todos los requisitos, sus entradas de datos y sus retornos. B谩sicamente en el interface definimos qu茅 hay que hacer pero no el c贸mo.

### **3. Implementaci贸n del Servicio de Usuarios**

El siguiente paso es implementar la l贸gica de cada servicio de negocio. Para esto, cree un paquete nuevo dentro del paquete `services` que se llame `impl` y all铆 cree la clase `UserServiceImpl`. Esta clase debe implementar todos los m茅todos de la interfaz `UserService`. As铆 debe quedar inicialmente:

```java
package co.edu.uniquindio.application.services.impl;

import co.edu.uniquindio.application.services.UserService;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {
    
}
```

Para simular la persistencia se har谩 uso de una estructura de almacenamiento en memoria (**Map**). Agregue el siguiente atributo a la clase `UserServiceImpl`:

```java
private final Map<String, User> userStore = new ConcurrentHashMap<>();
```

A continuaci贸n se muestra una alternativa de implementaci贸n de algunos m茅todos del CRUD:

#### Crear un nuevo usuario

```java
@Override
public void create(CreateUserDTO userDTO) throws Exception {
    if(isEmailDuplicated(userDTO.email())){
        throw new Exception("El correo electr贸nico ya est谩 en uso.");
    }

    User newUser = User.builder()
            .id(UUID.randomUUID().toString())
            .name(userDTO.name())
            .email(userDTO.email())
            .phone(userDTO.phone())
            .role(userDTO.role())
            .dateBirth(userDTO.dateBirth())
            .photoUrl(userDTO.photoUrl())
            .password(userDTO.password())
            .createdAt(LocalDateTime.now())
            .status(UserStatus.REGISTERED)
            .build();

    userStore.put(newUser.getId(), newUser);
}

private boolean isEmailDuplicated(String email){
    return userStore.values().stream().anyMatch(
            u -> u.getEmail().equalsIgnoreCase(email)
    );
}
```

Se utiliza un m茅todo de apoyo `isEmailDuplicated` para verificar si el correo electr贸nico ya est谩 en uso antes de crear un nuevo usuario. Esto ayuda a mantener la l贸gica de negocio separada y reutilizable. Se asume que una regla de negocio es que los correos electr贸nicos deben ser 煤nicos en el sistema.

Dado que la contrase帽a debe estar cifrada, se debe usar una dependencia que nos ayude con esto, agregue la siguiente dependencia en el archivo `build.gradle`:

```groovy
implementation 'org.springframework.security:spring-security-crypto'
```

> 锔 **Importante:** No olvide sincronizar Gradle despu茅s de agregar la dependencia.

Agregue el m茅todo `encode` en la clase `UserServiceImpl` para cifrar la contrase帽a antes de guardarla:

```java
private String encode(String password){
    var passwordEncoder = new BCryptPasswordEncoder();
    return passwordEncoder.encode(password);
}
```

Llame este m茅todo en el proceso de creaci贸n de usuarios, espec铆ficamente al asignar la contrase帽a del nuevo usuario `newUser`:

```java
password(encode(userDTO.password()))
```

#### Obtener un usuario

Se valida que el usuario existe antes de intentar acceder a sus datos, luego se mapean sus atributos a un objeto DTO.

```java
@Override
public UserDTO get(String id) throws Exception {
    User user = userStore.get(id);

    if (user == null) {
        throw new Exception("Usuario no encontrado.");
    }

    return new UserDTO(
            user.getId(),
            user.getName(),
            user.getPhone(),
            user.getEmail(),
            user.getPhotoUrl(),
            user.getDateBirth(),
            user.getRole()
    );
    
}
```

#### Eliminar un usuario

Se valida que el usuario existe antes de intentar eliminarlo, luego se procede a eliminarlo.

```java
@Override
public void delete(String id) throws Exception {
    User user = userStore.remove(id);
    if (user == null) {
        throw new Exception("Usuario no encontrado.");
    }

    userStore.remove(id);
}
```

Implemente las dem谩s operaciones del CRUD (Actualizar y Listar usuarios) siguiendo la misma l贸gica de validaci贸n y manejo de excepciones.

### 4. Implementaci贸n de Mappers

Es posible centralizar la tarea de transformaci贸n de los datos mediante la implementaci贸n de un **Mapper**. 

Los mappers son una herramienta fundamental en el desarrollo de aplicaciones, ya que permiten transformar la forma en que representamos la informaci贸n en diferentes capas de la aplicaci贸n. Su principal funci贸n es facilitar la conversi贸n entre las estructuras de datos utilizadas en las solicitudes (DTOs - Data Transfer Objects) y las estructuras de datos que se persisten en la base de datos (entidades) y viceversa.

Para esto, agregue las siguientes dependencias en el archivo `build.gradle`:

```groovy
implementation 'org.mapstruct:mapstruct:1.6.3'
annotationProcessor 'org.mapstruct:mapstruct-processor:1.6.3'
```
> 锔 **Importante:** No olvide sincronizar Gradle despu茅s de agregar la dependencia.

Cree un nuevo paquete `mappers` en el directorio `src/main/java` y dentro de este paquete, cree una interfaz `UserMapper`:

```java
package co.edu.uniquindio.application.mappers;

import co.edu.uniquindio.application.dto.CreateUserDTO;
import co.edu.uniquindio.application.dto.UserDTO;
import co.edu.uniquindio.application.model.User;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingConstants;

@Mapper(componentModel = MappingConstants.ComponentModel.SPRING)
public interface UserMapper {

    @Mapping(target = "id", expression = "java(java.util.UUID.randomUUID().toString())")
    @Mapping(target = "status", constant = "REGISTERED")
    @Mapping(target = "createdAt", expression = "java(java.time.LocalDateTime.now())")
    User toEntity(CreateUserDTO userDTO);

    UserDTO toUserDTO(User user);
}
```

El m茅todo `toEntity` convierte un `CreateUserDTO` en un objeto `User`, generando un ID 煤nico, asignando la fecha de creaci贸n y estableciendo el estado del usuario como activo.

Ahora, se debe actualizar el servicio de usuarios para utilizar el mapper en lugar de realizar las conversiones manualmente.

```java
package co.edu.uniquindio.application.services.impl;

@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    private final UserMapper userMapper;
    private final Map<String, User> userStore = new ConcurrentHashMap<>();

    @Override
    public void create(CreateUserDTO userDTO) throws Exception {
        //Validaci贸n del email
        if(isEmailDuplicated(userDTO.email())){
            throw new Exception("El correo electr贸nico ya est谩 en uso.");
        }

        //Transformaci贸n del DTO a User
        User newUser = userMapper.toEntity(userDTO);
        newUser.setPassword(encode(userDTO.password()));

        //Almacenamiento del usuario
        userStore.put(newUser.getId(), newUser);
    }

    @Override
    public UserDTO get(String id) throws Exception {
        //Recuperaci贸n del usuario
        User user = userStore.get(id);

        //Validaci贸n del usuario
        if (user == null) {
            throw new Exception("Usuario no encontrado.");
        }

        //Transformaci贸n del usuario a DTO
        return userMapper.toUserDTO(user);
    }
}
```
Gracias a la implementaci贸n de `MapStruct`, hemos simplificado significativamente el proceso de mapeo entre nuestros DTOs y entidades. Adem谩s con la **inyecci贸n de dependencias** de Spring, el uso de mappers se vuelve a煤n m谩s sencillo y limpio.

> **锔 Importante**: Aseg煤rese que los nombres de los atributos que comparten los DTO y las clases del modelo coincidan. Por ejemplo, la clase `User` tiene el campo name, email, phone, etc. y el DTO `CreateUserDTO` tambi茅n tiene esos mismos campos. Esto es necesario para que MapStruct pueda hacer el mapeo autom谩ticamente.

### 5. Implementaci贸n de Operaciones REST

Modifique el controlador `UserController` para **inyectar** la instancia del servicio de negocio creado anteriormente.

**Ejemplo**  

```java
@RestController
@RequestMapping("/users")
@RequiredArgsConstructor
public class UserController {
   private final UserService userService;
   
   // Implementaci贸n de m茅todos
}
```

> **锔 Nota:** En el c贸digo anterior se ha declarado una variable como `final` y dicha variable no se ha inicializado, se ha dejado para que **Spring boot** la inicialice de forma autom谩tica con una instancia de `UserService`. Lo anterior, se hace mediante el constructor de la clase que se ha creado con la anotaci贸n `@RequiredArgsConstructor` de **Lombok**.

Con este patr贸n, se garantiza que la instancia de `UserService` se inyecte correctamente en el controlador, permitiendo su uso en los m茅todos de manejo de solicitudes. 

Modifique todos los m茅todos que est谩n en `UserController` para utilizar `userService`, as铆:

```java
@PostMapping
public ResponseEntity<ResponseDTO<String>> create(@Valid @RequestBody CreateUserDTO userDTO) throws Exception{
    userService.create(userDTO);
    return ResponseEntity.status(HttpStatus.CREATED).body(new ResponseDTO<>(false, "El registro ha sido exitoso"));
}

@GetMapping("/{id}")
public ResponseEntity<ResponseDTO<UserDTO>> get(@PathVariable String id) throws Exception{
    UserDTO userDTO = userService.get(id);
    return ResponseEntity.ok(new ResponseDTO<>(false, userDTO));
}

@DeleteMapping("/{id}")
public ResponseEntity<ResponseDTO<String>> delete(@PathVariable String id) throws Exception{
    userService.delete(id);
    return ResponseEntity.ok(new ResponseDTO<>(false, "El usuario ha sido eliminado"));
}

@GetMapping
public ResponseEntity<ResponseDTO<List<UserDTO>>> listAll(){
    List<UserDTO> list = userService.listAll();
    return ResponseEntity.ok(new ResponseDTO<>(false, list));
}

@PutMapping("/{id}")
public ResponseEntity<ResponseDTO<String>> edit(@PathVariable String id, @Valid @RequestBody EditUserDTO userDTO) throws Exception{
    userService.edit(id, userDTO);
    return ResponseEntity.ok(new ResponseDTO<>(false, "El usuario ha sido actualizado"));
}
```

Los controladores son los encargados de recibir las solicitudes HTTP y delegar la l贸gica de negocio a los servicios correspondientes. No contienen l贸gica de negocio en s铆 mismos, lo que permite mantener un c贸digo m谩s limpio y f谩cil de mantener.

### 6. Prueba de Operaciones

Puede usar Postman o Swagger UI para enviar solicitudes a la API. Para esto, primero debe ejecutar el servidor Spring Boot.

- Accede a Swagger UI en: [http://localhost:8080/swagger-ui.html](http://localhost:8080/swagger-ui.html). 
- Tambi茅n puede ejecutar el archivo `users.http` creado en la gu铆a anterior para probar las operaciones de creaci贸n, obtenci贸n, eliminaci贸n y actualizaci贸n de usuarios.

Pruebe todos los endpoints de usuarios, ingrese datos v谩lidos y observe las respuestas del sistema, luego ingrese datos inv谩lidos para verificar el manejo de errores.

> **锔 Nota:** Si intenta registrar dos usuarios con el mismo email podr谩 ver que se genera una excepci贸n y el sistema retorna un status code 500, lo cual no necesariamente es lo que se desea.

### 7. Personalizando Excepciones

Como buena pr谩ctica se sugiere la personalizaci贸n de las excepciones generadas en los servicios de negocio.

**Ejemplo:** Cree esta excepci贸n en un paquete `exceptions`:
```java
package co.edu.uniquindio.application.exceptions;

public class ValueConflictException extends Exception {
    public ValueConflictException(String message) {
        super(message);
    }
}
```

Modifique su servicio de negocio `UserServiceImpl` para que el m茅todo `create` en lugar de lanzar una excepci贸n gen茅rica lance `ValueConflictException`.

```java
@Override
public void create(CreateUserDTO userDTO) throws Exception {
    //Validaci贸n del email
    if(isEmailDuplicated(userDTO.email())){
        throw new ValueConflictException("El correo electr贸nico ya est谩 en uso.");
    }

    //Transformaci贸n del DTO a User
    User newUser = userMapper.toEntity(userDTO);
    newUser.setPassword(encode(userDTO.password()));

    //Almacenamiento del usuario
    userStore.put(newUser.getId(), newUser);
}
```

Ahora, debe modificar la clase `RestExceptionHandler` para manejar la nueva excepci贸n `ValueConflictException`. Agregue el siguiente m茅todo:

```java
@ExceptionHandler(ValueConflictException.class)
public ResponseEntity<ResponseDTO<String>> handleValueConflictException(ValueConflictException ex) {
    return ResponseEntity.status(HttpStatus.CONFLICT).body( new ResponseDTO<>(true, ex.getMessage()) );
}
```

Con esto, cuando se lance una `ValueConflictException`, el sistema responder谩 con un c贸digo de estado HTTP 409 (Conflict) y el mensaje de error personalizado.

** Ejecute nuevamente la aplicaci贸n e intente registrar dos usuarios con el mismo email para verificar el comportamiento.**

### 8. Avance de proyecto

Personalice todas las excepciones generadas por sus servicios de negocio para gestionar adecuadamente las respuestas del sistema. Por ejemplo, puede crear una excepci贸n `NotFoundException` para manejar casos en los que un recurso no se encuentra.

Adem谩s, cree un nuevo servicio para los alojamientos y haga que el controlador correspondiente use este servicio. Aseg煤rese de seguir las mismas buenas pr谩cticas que se han aplicado en el servicio de usuarios.

---

## Para la pr贸xima clase

Para prepararse para las pr贸ximas clases, los estudiantes deben investigar sobre:

1. Bases de datos relacionales
2. Lenguaje SQL
3. ORM (Object-Relational Mapping)

---

## Referencias Bibliogr谩ficas

- Spring Boot Documentation: [https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot)
- Postman API Testing: [https://www.postman.com/](https://www.postman.com/)
- cURL Command Reference: [https://curl.se/docs/](https://curl.se/docs/)
- Mapstruct: [https://mapstruct.org](https://mapstruct.org)
- Fowler, M. (2012). *Patterns of Enterprise Application Architecture*. Addison-Wesley.  
- Newman, S. (2015). *Building Microservices: Designing Fine-Grained Systems*. O'Reilly Media.  
- Richardson, C. (2018). *Microservices Patterns: With examples in Java*. Manning Publications.  

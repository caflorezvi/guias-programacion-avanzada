```
Programa de Ingenier铆a de Sistemas y Computaci贸n
Universidad del Quind铆o

T铆tulo: Implementaci贸n de Servicios de negocio en Spring Boot
Duraci贸n estimada: 120
Docentes: Carlos Andr茅s Florez, Christian Andr茅s Candela
Gu铆a: 06
```
# **Servicios de negocio en Spring Boot**

## ** Objetivo**  
Implementar servicios de negocio en **Spring Boot**. Se explorar谩 la creaci贸n de servicios, la l贸gica de negocio y la validaci贸n de datos mediante pruebas unitarias.

---

## **Conceptos B谩sicos**  

- **Spring Boot:** Framework para desarrollar aplicaciones en Java con una configuraci贸n m铆nima.
- **Servicios REST:** Componentes que exponen los servicios de la aplicaci贸n para su uso.
- **Servicios de negocio:** Componentes que encapsulan la l贸gica empresarial y procesan las reglas del negocio.
- **Inyecci贸n de dependencias:** Mecanismo para gestionar la creaci贸n y administraci贸n de componentes.
- **HTTP (Hypertext Transfer Protocol)**  Protocolo de comunicaci贸n para la transferencia de datos en la web. 
- **OpenAPI**  Especificaci贸n abierta para describir APIs RESTful.
- **CRUD (Create, Read, Update, Delete)**  Conjunto de operaciones b谩sicas para manipular datos (crear, leer, actualizar y eliminar).

---

## **Contextualizaci贸n Te贸rica** 

Los **servicios de negocio** son la capa de una aplicaci贸n responsable de la l贸gica principal. En Spring Boot, estas clases se identifican con la anotaci贸n `@Service`, que es una especializaci贸n de `@Component`. Al marcar una clase con `@Service`, le estamos indicando a Spring que debe gestionar esta clase como un **bean** de servicio dentro del contexto de la aplicaci贸n. De esta forma, se encapsula la l贸gica de negocio en un solo lugar y permite que otras partes de la aplicaci贸n puedan inyectar y utilizar ese servicio f谩cilmente.

Aqu铆 hay algunas caracter铆sticas clave de los servicios de negocio en el contexto de Spring Boot:

- **L贸gica de Negocio:** Los servicios de negocio encapsulan la l贸gica empresarial de la aplicaci贸n, implementando operaciones, validaciones y reglas espec铆ficas del dominio.

- **Reutilizaci贸n:** Los servicios de negocio pueden ser dise帽ados para ser reutilizables en diferentes partes de la aplicaci贸n. Esto promueve la modularidad y facilita la gesti贸n de la l贸gica de negocio.

- **Separaci贸n de Responsabilidades:** Spring Boot sigue el principio de separaci贸n de responsabilidades, por lo que los servicios de negocio se encargan de la l贸gica empresarial mientras que otros componentes, como los controladores y las capas de persistencia, se centran en tareas espec铆ficas.

- **Inyecci贸n de Dependencias:** Spring Boot utiliza la inversi贸n de control (IoC) y la inyecci贸n de dependencias para gestionar la creaci贸n y administraci贸n de componentes. Los servicios de negocio pueden beneficiarse de la inyecci贸n de dependencias para obtener f谩cilmente otras dependencias necesarias.

- **Transacciones:** En aplicaciones empresariales, a menudo es necesario gestionar transacciones. Spring Boot ofrece soporte para la gesti贸n de transacciones, lo que permite que los servicios de negocio participen en transacciones de base de datos de manera coherente.

---

## **Buenas Pr谩cticas y Recomendaciones**  

- **Separaci贸n de responsabilidades:** Mantenga la l贸gica de negocio en los servicios y evite incluirla en los controladores.

- **Uso de excepciones personalizadas:** Cree excepciones espec铆ficas para manejar errores en la l贸gica de negocio.

- **Validaciones en DTOs:** Utilice anotaciones como `@Valid` y `@NotNull` para garantizar la integridad de los datos de entrada.

- **Estructura modular:** Organice el c贸digo en paquetes bien definidos (`controllers`, `services`, `model`, `exceptions`).

---

## Procedimiento

#### 1. Definici贸n de la estructura de User

Cree un nuevo paquete con el nombre `model` y dentro de 茅l, cree la clase `User` con la siguiente estructura:

```java
package co.edu.uniquindio.application.model;

import lombok.Builder;
import lombok.Getter;
import lombok.Setter;
import java.time.LocalDate;

@Getter
@Setter
@Builder
public class User {
    private String id;
    private String name;
    private String phone;
    private String email;
    private String password;
    private String photoUrl;
    private LocalDate dateBirth;
    private Role role;
    private UserStatus status;
}
```

Adicionalmente, cree las enumeraciones `Role` y `UserStatus` en el paquete `model`:

```java
package co.edu.uniquindio.application.model;

public enum Role {
    USER,
    HOST,
    ADMIN
}
```

```java
package co.edu.uniquindio.application.model;

public enum UserStatus {
    ACTIVE,
    INACTIVE,
    DELETED
}
```

#### **2. Definici贸n de la interfaz del Servicio de Usuarios**

Con el fin de reducir el acoplamiento en los componentes del sistema, es una buena pr谩ctica **definir** los m茅todos de negocio en una interfaz. Cree el paquete `services` y dentro de 茅l, la interfaz `UserService`.

Para esta gu铆a se implementar谩 un CRUD a manera de ejemplo, por lo tanto, se necesitan los siguientes m茅todos (para el proyecto final debe agregar m谩s m茅todos):


```java
package co.edu.uniquindio.application.services;

import co.edu.uniquindio.application.dto.CreateUserDTO;
import co.edu.uniquindio.application.dto.EditUserDTO;
import co.edu.uniquindio.application.dto.UserDTO;
import java.util.List;

public interface UserService {

    void create(CreateUserDTO account) throws Exception;

    UserDTO get(String id) throws Exception;

    void delete(String id) throws Exception;

    List<UserDTO> listAll();

    void edit(String id, EditUserDTO account) throws Exception;

}
```

Debe haber cierta correspondencia entre los m茅todos definidos en la interfaz del servicio con los m茅todos que est谩n en el controlador REST, ya que el controlador usa los m茅todos del servicio para realizar las operaciones.

Como puede ver, algunos m茅todos tienen un `throws Exception`, esto es debido a que siempre debemos validar y capturar las excepciones que puedan aparecer al momento de manipular la base de datos (consultar, insertar, actualizar o eliminar).

> 锔 **Importante:** Es una buena pr谩ctica primero definir los servicios por medio de interfaces ya que all铆 podemos listar todos los requisitos, sus entradas de datos y sus retornos. B谩sicamente en el interface definimos qu茅 hay que hacer pero no el c贸mo.

#### **3. Implementaci贸n del Servicio de Usuarios**

El siguiente paso es implementar la l贸gica de cada servicio de negocio. Para esto, cree un paquete nuevo dentro del paquete `services` que se llame `impl` y all铆 cree la clase `UserServiceImpl`. Esta clase debe implementar todos los m茅todos de la interfaz `UserService`. As铆 debe quedar inicialmente:

```java
package co.edu.uniquindio.application.services.impl;

import co.edu.uniquindio.application.services.UserService;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {
    
}
```

Para simular la persistencia se har谩 uso de una estructura de almacenamiento en memoria (**Map**). Agregue el siguiente atributo a la clase `UserServiceImpl`:

```java
private final Map<String, User> userStore = new ConcurrentHashMap<>();
```

A continuaci贸n se muestra una alternativa de implementaci贸n de algunos m茅todos del CRUD:

#### Crear un nuevo usuario

```java
@Override
public void create(CreateUserDTO account) throws Exception {
    if(isEmailDuplicated(account.email())){
        throw new Exception("El correo electr贸nico ya est谩 en uso.");
    }

    User newUser = User.builder()
            .id(UUID.randomUUID().toString())
            .name(account.name())
            .email(account.email())
            .phone(account.phone())
            .role(account.role())
            .dateBirth(account.dateBirth())
            .photoUrl(account.photoUrl())
            .password(account.password())
            .createdAt(LocalDateTime.now())
            .status(UserStatus.ACTIVE)
            .build();

    userStore.put(newUser.getId(), newUser);
}

private boolean isEmailDuplicated(String email){
    return userStore.values().stream().anyMatch(
            u -> u.getEmail().equalsIgnoreCase(email)
    );
}
```

Se utiliza un m茅todo de apoyo para verificar si el correo electr贸nico ya est谩 en uso antes de crear un nuevo usuario. Esto ayuda a mantener la l贸gica de negocio separada y reutilizable. Se asume que una regla de negocio es que los correos electr贸nicos deben ser 煤nicos en el sistema.

Dado que la contrase帽a debe estar cifrada, se debe usar una dependencia que nos ayude con esto, agregue la siguiente dependencia en el archivo `build.gradle`:

```groovy
implementation 'org.springframework.security:spring-security-crypto'
```

> 锔 **Importante:** No olvide sincronizar Gradle despu茅s de agregar la dependencia.

Agregue el m茅todo `encode` en la clase `UserServiceImpl` para cifrar la contrase帽a antes de guardarla:

```java
private String encode(String password){
    var passwordEncoder = new BCryptPasswordEncoder();
    return passwordEncoder.encode(password);
}
```

Llame este m茅todo en el proceso de creaci贸n de usuarios, espec铆ficamente al asignar la contrase帽a del nuevo usuario `newUser`:

```java
password(encode(account.password()))
```

#### Obtener un usuario

Se valida que el usuario existe antes de intentar acceder a sus datos, luego se mapean sus atributos a un objeto DTO.

```java
@Override
public UserDTO get(String id) throws Exception {
    User user = userStore.get(id);

    if (user == null) {
        throw new Exception("Usuario no encontrado.");
    }

    return new UserDTO(
            user.getId(),
            user.getName(),
            user.getPhone(),
            user.getEmail(),
            user.getPhotoUrl(),
            user.getDateBirth(),
            user.getRole()
    );
    
}
```

#### Eliminar un usuario

Se valida que el usuario existe antes de intentar eliminarlo, luego se procede a eliminarlo.

```java
@Override
public void delete(String id) throws Exception {
    User user = userStore.remove(id);
    if (user == null) {
        throw new Exception("Usuario no encontrado.");
    }

    userStore.remove(id);
}
```

Implemente las dem谩s operaciones del CRUD (Actualizar y Listar usuarios) siguiendo la misma l贸gica de validaci贸n y manejo de excepciones.

#### 4. Implementaci贸n de Mappers

Es posible centralizar la tarea de transformaci贸n de los datos mediante la implementaci贸n de un **Mapper**. 

Los mappers son una herramienta fundamental en el desarrollo de aplicaciones, ya que permiten transformar la forma en que representamos la informaci贸n en diferentes capas de la aplicaci贸n. Su principal funci贸n es facilitar la conversi贸n entre las estructuras de datos utilizadas en las solicitudes (DTOs - Data Transfer Objects) y las estructuras de datos que se persisten en la base de datos (entidades) y viceversa.

Para esto, agregue las siguientes dependencias en el archivo `build.gradle`:

```groovy
implementation 'org.mapstruct:mapstruct:1.6.3'
annotationProcessor 'org.mapstruct:mapstruct-processor:1.6.3'
```
> 锔 **Importante:** No olvide sincronizar Gradle despu茅s de agregar la dependencia.

Cree un nuevo paquete `mappers` en el directorio `src/main/java` y dentro de este paquete, cree una interfaz `UserMapper`:

```java
package co.edu.uniquindio.application.mappers;

import co.edu.uniquindio.application.dto.CreateUserDTO;
import co.edu.uniquindio.application.dto.UserDTO;
import co.edu.uniquindio.application.model.User;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingConstants;

@Mapper(componentModel = MappingConstants.ComponentModel.SPRING)
public interface UserMapper {

    @Mapping(target = "id", expression = "java(java.util.UUID.randomUUID().toString())")
    @Mapping(target = "status", constant = "ACTIVE")
    @Mapping(target = "createdAt", expression = "java(java.time.LocalDateTime.now())")
    User toEntity(CreateUserDTO userDTO);

    UserDTO toUserDTO(User user);
}
```

El m茅todo `toEntity` convierte un `CreateUserDTO` en un objeto `User`, generando un ID 煤nico, asignando la fecha de creaci贸n y estableciendo el estado del usuario como activo.

Ahora, se debe actualizar el servicio de usuarios para utilizar el mapper en lugar de realizar las conversiones manualmente.

```java
package co.edu.uniquindio.application.services.impl;

@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    private final UserMapper userMapper;
    private final Map<String, User> userStore = new ConcurrentHashMap<>();

    @Override
    public void create(CreateUserDTO account) throws Exception {
        //Validaci贸n del email
        if(isEmailDuplicated(account.email())){
            throw new Exception("El correo electr贸nico ya est谩 en uso.");
        }

        //Transformaci贸n del DTO a User
        User newUser = userMapper.toEntity(account);
        newUser.setPassword(encode(account.password()));

        //Almacenamiento del usuario
        userStore.put(newUser.getId(), newUser);
    }

    @Override
    public UserDTO get(String id) throws Exception {
        User user = userStore.get(id);

        if (user == null) {
            throw new Exception("Usuario no encontrado.");
        }

        //Transformaci贸n del User a DTO
        return userMapper.toUserDTO(user);

    }
}
```
Gracias a la implementaci贸n de MapStruct, hemos simplificado significativamente el proceso de mapeo entre nuestros DTOs y entidades. Adem谩s con la inyecci贸n de dependencias de Spring, el uso de mappers se vuelve a煤n m谩s sencillo y limpio.

> **锔 Importante**: Aseg煤rese que los nombres de los atributos que comparten los DTO y las clases del modelo coincidan. Por ejemplo, la clase `User` tiene el campo name, email, phone, etc. y el DTO `CreateUserDTO` tambi茅n tiene esos mismos campos. Esto es necesario para que MapStruct pueda hacer el mapeo autom谩ticamente.